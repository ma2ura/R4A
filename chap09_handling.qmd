---
title: "データハンドリング"
---

```{r include=FALSE}
source("global.R")
```

ここでは、いわゆる**前処理**とよばれる、分析に入る前に、データを整える作業について学びます。
分析前の前処理をどれだけ丁寧に行うかによって、分析が容易になったり、結果が変わったりします。

目標としては、

1. 外部のデータベースなどから入手したcsvファイルやExcelファイルをRに読み込み、
2. データの構造を理解し、
3. データを整理・加工して、

記述統計量を計算したり、グラフを描いたりするのに適したデータを作成することです。
このあたりを学習すれば，MS ExcelよりもRの方がデータを分析するのに向いていることがわかると思います。
今後使うパッケージは，`tidyverse`パッケージです。
ついでに，`knitr`と`kableExtra`パッケージも読み込んでおきます。
```{r tidyverse}
library(tidyverse)
library(knitr)
library(kableExtra)
```

## ここで用いる基本関数

- `head()`: データの先頭を表示する関数
- `str()`: データの構造を表示する関数

ここで用いる`tidyverse`関数

- `readr::read_csv()`: CSVファイルを読み込む関数
- `dplyr::glimpse()`: データの構造を表示する関数
- `dplyr::mutate()`: データに新しい変数を追加する関数
- `dplyr::select()`: データの変数を選択する関数
- `dplyr::filter()`: データの行を選択する関数
- `dplyr::group_by()`: データをグループ化する関数
- `dplyr::summarise()`: データを集約する関数
- `dplyr::arrange()`: データを並び替える関数
- `dplyr::count()`: データの行数を数える関数


## PCを立ち上げる

まずは，VS CodeやRStudioを起動します。

- VS Codeの場合
    1. フォルダを開く
    2. 編集したいファイルを開く
    3. `library()`で必要なパッケージを読み込む
    4. csvファイルを読み込む
    5. 作業開始


- Rstudioの場合
    1. プロジェクトを開く
    2. 編集したいファイルを開く
    3. `library()`で必要なパッケージを読み込む
    4. csvファイルを読み込む
    5. 作業開始

となります。

## データの読み込む

最初にやることは、データを読み込むことです。
データを読み込むには，`tidyverse`の`readr`パッケージの`read_csv()`関数を使います。
関数名のとおり`read_csv`関数は，csvファイルをRに読み込む関数です。
csvファイルとは，カンマで区切られたテキストファイルで、次のようなデータとなっています。

```
会社コード,企業名,決算期,決算種別,連結基準,決算月数,上場コード,日経業種コード,売上高,親会社株主に帰属する当期純利益,資産合計,株主資本
0000001,極洋,2006/03,10,1,12,11,235341,152899,2007,65049,14852
0000001,極洋,2007/03,10,1,12,11,235341,157088,2000,66459,16339
0000001,極洋,2008/03,10,1,12,11,235341,147767,1497,57373,16873
```

csvファイルは，MS Excelで作成することができますが、日経NEEDSからダウンロードしたcsvファイルをExcelで開いてしまうと、勝手にいろいろな処理が勝手に行われてしまうので、注意が必要です。

![read_csv](img/read_csv.png)

`read_csv()`関数の引数は非常に多く、設定次第では効率的に前処理ができますが、ここではシンプルに読み込むだけの方法を使います。
読み込んだデータは、`df`という名前のオブジェクトに代入します。

```{r read_csv}
#| cache: true
df <- read_csv("https://so-ichi.com/presemi_part_two.csv")
```

結果の1行目に`Rows: 44527 Columns: 12`とあるように、`df`には44527行12列のデータが読み込まれています。


## データを確認する

この`df`のクラスを確認してみます。

```{r class_df}
class(df)
```

すると、`"spec_tbl_df"`、`"tbl_df"`、`"tbl"`、`"data.frame"`という方が与えられていることがわかります。
ここでは、`data.frame`であるということだけ覚えておいてください。

:::{.column-margin}
`read_csv()`関数の引数には、次のようなものがあります。

- `file`: 読み込むファイルの名前、あるいはパス
- `col_names`: 列名を指定するかどうか
- `col_types`: 列の型を指定するかどうか
- `locale`: ファイルのエンコーディングを指定するかどうか
- `na`: 欠損値の文字列を指定するかどうか
:::

<!--
- `quoted_na`: 欠損値の文字列を引用符で囲むかどうか
- `quote`: 引用符の文字を指定するかどうか
- `comment`: コメント文字を指定するかどうか
- `trim_ws`: 空白を削除するかどうか
- `skip`: 読み飛ばす行数を指定するかどうか
- `n_max`: 読み込む行数を指定するかどうか
- `guess_max`: 列の型を推測する際に読み込む行数を指定するかどうか
- `progress`: 進捗状況を表示するかどうか
-->

読み込んだデータを簡単にチェックする方法として、`head()`関数があります。
これは、データの先頭の行を表示する関数です。
デフォルトでは、先頭の6行が表示されます。引数`n`で表示する行数を指定することができます。
```{r head_df}
head(df, n = 4)
```

より詳細な構造を理解するためには、`str()`関数や`dplyr::glimpse()`関数を使います。
基本関数`str()`だと、

```{r str_df}
str(df)
```

のように、変数ごとにデータの型、データの個数、データがいくつか表示されます。
`glimpse()`関数も同様に、変数ごとにデータの型やデータのいくつかが表示されます。

```{r glimpse_df}
glimpse(df)
```

これで、変数の名前やタイプ、どんなデータが入っているのかをサクッと確認しておきましょう。


## データの整理・加工する

データの整理・加工には、`dplyr`パッケージの関数を使います。
`dplyr`パッケージは、データの整理・加工に特化したパッケージで、`tidyverse`パッケージに含まれています。
ここからは，基本的に**パイプ演算子**を使います。
`dplyr`パッケージの関数は，パイプ演算子を使って処理をつなげることで，データの整理・加工の処理が分かりやすくなります。

### `select()`関数

`select()`関数は、データの変数を選択する関数です。

![select関数](img/select.png){width=80%}

引数には、選択したい変数名を直接していするか、以下の関数をつかって変数名の一部を指定することができます。

- `starts_with()` : 指定した文字列で始まる変数
- `ends_with()` : 指定した文字列で終わる変数

複数の変数を具体的に指定する場合は，`c()`で変数名を指定します。

先ほど読み込んだ`df`から，企業名，決算期，売上高の3つの変数を選択する場合は，次のように書きます。
読み込んだデータを`df_sale`というオブジェクトに代入します。
基本的に，読み込んだオリジナルのデータは加工せず，加工したデータフレームは新しいオブジェクトに代入していきます。

```{r}
df_sale <- df |>
    select(企業名, 決算期, 売上高, 資産合計)
```

これで，4変数からなる`df_sale`が作成されました。

### `filter()`関数

`filter()`関数は，データの行(つまり観測値)を抽出する関数です。

![filter関数](img/filter.png)

`filter()`関数の引数は，行を抽出する条件式です。
データフレームの章で学習したものと同様に，以下のような条件を指定することで，必要とされる行のみを抽出できます。

- `==` や `!=` : 等しいかそれ以外か
- `>`や`>=` や`<`や`<=` : 大小関係
- `%in%` : ベクトルの中に含まれるかどうか
- `is.na()` : 欠損値かどうか

また条件式を複数指定することもできます。

- `&`はAND つまり「かつ」
- `|`はOR つまり「あるいは」

これらの条件式を組み合わせることで、複雑な条件を指定することができます。
例えば，先ほど作成した`df_sale`から，トヨタ自動車で，**かつ**売上高が30兆円以上のデータを抽出する場合，
```{r}
df_sale_toyota <- df_sale |>
    filter(企業名 == "トヨタ自動車" & 売上高 >= 3e7)
df_sale_toyota
```
のように書きます。
財務データは単位が100万円なので，30兆円は30000000となりますが，ゼロが多すぎて一見何円か分からないので，指数表記の`3e7`としています。
これは$3 \times 10^7$という意味で，3の後ろにゼロが7こあるという意味です。

`filter()`関数を使った結果，売上高が30兆円以上だった年度が2019年度と2022年度だったことがわかりました。




### `mutate()`関数

`mutate()`関数は、データに新しい変数を追加する関数です。

![mutate関数](img/mutate.png)

すでにある変数を使って新しい変数を作成したり、変数の値を変換したり、新規の変数を追加したりすることができます。

`mutate()`関数の引数は、

- `新しい変数名 = 変数の値を計算する式`

となります。
たとえば，先ほど作成した`df_sale_toyota`のデータを用いて，総資産回転率を計算する場合は，次のように書きます。

:::{.column-margin}
総資産回転率は，売上高を資産合計で除したものです。
:::

```{r}
df_sale_toyota <- df_sale_toyota |>
    mutate( # 変数の作成
        総資産回転率 = round(売上高 / 資産合計, digits = 3) # 計算式
        )
df_sale_toyota
```

`mutate()`関数には次のようなオプションも用意されています。

- `.before` と `.after` : 変数を追加する位置を指定
    - `.before = 売上高` : `売上高`の前に追加
    - `.after = 売上高` : `売上高`の後に追加
- `.keep`   : 新しい変数を追加する際に、元の変数を残すかどうか
    - `keep = "all"` : 元の変数を残す
    - `keep = "used"`: 使った変数だけ残す
    - `keep = "unused"`: 変数の作成に使った変数を除外する
    - `keep = "none"`: 新変数のみを残す


これは見た方が早いので、`mutate()`のヘルプにある例で確認してみましょう。
次のような1行2列のデータフーレムを用意します。



::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex <- data.frame(x = 1, y = 2)
df_ex
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex <- data.frame(x = 1, y = 2)
df_ex
```
:::
::::

#### `mutate()`のデフォルト動作

まずはデフォルトの動作を確認します。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |> mutate(z = x + y)
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex |> mutate(z = x + y) |>
    kable() |> column_spec(3, bold = TRUE, background = 'mistyrose')
```
:::
::::

一番右の列に`z`が追加されました。これがデフォルトの動作となります。

#### `.before`と`.after`

次に、`.before = 1`を指定してみます。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |>
    mutate(z = x + y, .before = 1) # 1の前に3が追加
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex |>
    mutate(z = x + y, .before = 1) |>
    kable() |>
    column_spec(1, bold = TRUE, background = 'mistyrose')
```
:::
::::

1の前に新変数`z`が追加されました。
次に、`.after = x`を指定してみます。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |>
    mutate(z = x + y, .after = x) # xの後に3が追加
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex |>
    mutate(z = x + y, .after = x) |>
    kable() |>
    column_spec(2, bold = TRUE, background = 'mistyrose')
```
:::
::::

xの後に新変数`z`が追加されました。
このように、`.before`と`.after`を使うことで、新変数を追加する位置を指定することができます。





#### `.keep`

最後に、`.keep`を指定してみます。
確認ように，次のような1行4列のデータフーレムを用意します。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex <- data.frame( # x,y,a,bの４変数
    x = 1,
    y = 2,
    a = "a",
    b = "b"
    )
df_ex
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex <- data.frame( # x,y,a,bの４変数
    x = 1,
    y = 2,
    a = "a",
    b = "b"
    )
df_ex |> kable(align = "cccc") |> kable_styling(position = "center")
```
:::
::::


こちらもデフォルトの動作から確認していきます。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |>
    mutate(z = x + y, .keep = "all") # デフォルトの動作
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex <- data.frame( # x,y,a,bの４変数
    x = 1, y = 2,
    a = "a", b = "b"
    )
df_ex |>
    mutate(z = x + y, .keep = "all") |>
    kable(align = "ccccc") |> column_spec(5, bold = TRUE, background = 'mistyrose')
```
:::
::::

新変数`z`が一番右に追加され、もともとの変数もすべて残っています。
これがデフォルトの動作となります。

次に、`.keep = "used"`を指定してみます。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |>
    mutate(z = x + y, .keep = "used") # 計算に使わなかった変数が除外
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex |>
    mutate(z = x + y, .keep = "used") |>
    kable(align = "ccc") |> column_spec(3, bold = TRUE, background = 'mistyrose')
```
:::
::::

新変数`z`とそれを作成するために使った変数`x`と`y`が残り、
計算に使われなかった変数`a`と`b`が除外されています。
新変数作成に用いられない変数を一括で除外したいときは、`.keep = "used"`を指定します。

次に、`.keep = "unused"`を指定してみます。

::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |>
    mutate(z = x + y, .keep = "unused") # 計算に使わなかった変数が除外
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex |>
    mutate(z = x + y, .keep = "unused") |>
    kable(align = "ccc") |> column_spec(3, bold = TRUE, background = 'mistyrose')
```
:::
::::

新変数`z`を作成するために使った`x`と`y`が除外されています。
新しい変数を作成したあとに、計算の元になった変数を使わない場合は、`.keep = "unused"`を指定するとよいでしょう。

最後に、`.keep = "none"`を指定してみます。


::::{.columns}
:::{.column width="49%"}
**コード**
```{r}
#| eval: false
df_ex |>
    mutate(z = x + y, .keep = "none") # 計算に使わなかった変数が除外
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
**結果**
```{r}
#| echo: false
df_ex |>
    mutate(z = x + y, .keep = "none") |>
    kable(align = "c") |> column_spec(1, bold = TRUE, background = 'mistyrose')
```
:::
::::

`.keep = "none"`を指定すると、`mutate()`で新たに作成した変数のみが残り、元の変数はすべて除外されます。
新変数以外は必要ない、という場合は`.keep = "none"`を指定するとよいでしょう。

### `group_by()`と`summarise()`

#### `group_by()`関数

`group_by()`関数は、データをグループ化する関数です。
ある変数がカテゴリー変数となっている場合に，そのカテゴリーごとにデータ処理を行うために使います。
基本的には，`group_by()`関数でグループ化した後に，`summarise()`関数で集約することになります。

![group_byとsummarise](img/group_by_sum.png){width=80%}

`group_by()`関数の引数は，グループ化する変数名です。

-  `group_by(グループ化する変数名)`

オプションとして，`.add`と`.drop`を指定することができます。
デフォルトでは，`.add = FALSE`と`.drop = TRUE`となっています。
`.add`は，既存のグループに新しいグループを追加するかどうかを指定します。
`.drop`は，既存のグループを削除するかどうかを指定します。

#### `summarise()`関数

`summarise()`関数の引数は，集約する変数名です。
`mutate()`関数と同じように新しい変数を作成するのですが，`mutate()`関数と違って，集約された値が作成されます。
そのため，`summarise()`関数は，`mutate()`関数と違って，データの行数が減ることに注意してください。

`summarise()`関数の引数は，

- `新しい変数名 = 集約関数(集約する変数名)`

となります。
集約関数には，`mean()`や`median()`，`sd()`などの統計量を計算する関数を指定します。
もちろん，`trim`や`na.rm`などのオプションも指定することができます。

また，`summarise()`関数のオプションとして，`.groups`を指定することができます。
`.groups`は，集約後のデータの行数を指定します。

- `.groups = "drop"` : 集約後のデータの行数を指定しない
- `.groups = "keep"` : 集約後のデータの行数を指定する
- `.groups = "rows"` : 集約後のデータの行数を指定する
- `.groups = "drop_last"` : 集約後のデータの行数を指定する
- `.groups = "keep_last"` : 集約後のデータの行数を指定する
- `.groups = "rows_last"` : 集約後のデータの行数を指定する
- `.groups = "drop_first"` : 集約後のデータの行数を指定する

これも具体例を見ながら確認してみましょう。

#### `group_by()`と`summarise()`の具体例

上で作成した`df`を用いて，産業別の売上高平均を表す表を作成してみましょう。
手順としては，

1. 産業中分類を表す変数を作成し，
2. 産業中分類ごとにグループ化し，
3. グループごとに平均売上高を計算し，
4. 平均売上高を大きい順(降順)に並び替える，

:::{.column-margin}
データフレームを特定の変数の値に基づいて並び替えるには，`arrange()`関数を使います。
`arrange()`関数はデフォルトで昇順に並び替えるので，降順に並び替える場合は，`desc()`関数を使います。
したがって，ここでは，`arrange(desc(平均売上高))`となります。
:::

となります。

:::{.column-margin}
日経業種コードは，6ケタの数値で出来ており，最初の1ケタは大分類，次の2ケタは中分類，最後の3ケタが小分類を表しています。
中分類を表すカテゴリー変数を作りたいので，`substr()`関数を使って，日経業種コードの2ケタ目と3ケタ目を抽出します。
`substr(文字列，開始位置，終了位置)`という関数で，文字列の指定した位置の文字を抽出することができます。
:::


```{r}
df |>
    mutate( # substr()で産業中分類を作成
        産業中分類 = substr(日経業種コード, 2, 3)
        ) |>
    group_by(産業中分類) |> # 産業中分類ごとにグループ化
    summarise( # 平均売上高を計算
        平均売上高 = mean(売上高, na.rm = TRUE) # 平均売上高を計算
        ) |>
    arrange(desc(平均売上高)) |> # 平均売上高で降順に並び替え
    head(5) |> # 上位5社を表示
    kable(format.args = list(big.mark = ",")) |> # 3桁ごとにカンマを表示
    kable_styling(full_width = FALSE)  # 表の幅を自動調整
```

日経産業中分類の11は石油，67は電力，27は自動車・自動車部品，65は通信，61は空輸を表しています。

各種オプションの効果を確認するために，`group_by()`と`summarise()`のヘルプにある例を確認してみましょう。

#### `group_by()`のオプション

練習用データ`mtcars`を用いて，`group_by()`のオプションを確認してみましょう。

:::{.column-margin}
`mtcars`は32行11列のデータフレームであり，変数として，`"mpg","cyl","disp","hp","drat","wt","qsec","vs","am","gear","carb"`をもっています。
`mpg`は燃費，`cyl`はシリンダー数，`disp`は排気量，`hp`は馬力，`drat`は変速機のギア比，`wt`は重量，`qsec`は1/4マイル走のタイム，`vs`はV型エンジンか直列エンジンか，`am`は変速機が自動か手動か，`gear`は変速機のギア数，`carb`はキャブレターの数を表しています。
:::

シリンダー数でグループ化したものを`by_cyl`というオブジェクトに代入します。

```{r}
by_cyl <- mtcars |> group_by(cyl)
glimpse(by_cyl)
```
出力の3行目に`Groups: cyl [3]`とあるように，`cyl`でグループ化されていることがわかります。
このグループごとに，排気量`disp`と馬力`hp`の平均を計算してみましょう。

```{r}
by_cyl |> summarise(
  disp = mean(disp),
  hp = mean(hp)
)
```

3グループごとに2変数の平均を計算したので，3行3列のデータフレームが作成されました。
次に，`max()`関数を使ってグループ内で最大の排気量を持つデータを抽出してみましょう。
```{r}
by_cyl |>
  filter(
    disp == max(disp) # 最大の排気量を持つデータを抽出
    ) |> kable()
```
3つのグループ内で最大の`disp`をもつ行が`filter()`により抽出され，データフレームが3行になっていことが分かります。


<!-- Each call to summarise() removes a layer of grouping -->
グルーピング化を解除する効果について確認してみましょう。
次のように，`vs`と`am`でグループ化した`by_vs_am`を作成し，`n()`を使ってグループごとのデータ数を計算します。

```{r}
by_vs_am <- mtcars |>
    group_by(vs, am) # vsとamでグループ化
by_vs <- by_vs_am |>
    summarise(n = n()) # グループ内のデータ数を計算
```

英語のメッセージが出力されました。
メッセージの内容は，「`summarise()`関数は，`vs`でグループ化されたデータを出力しているので，グループ化を上書きしたいなら，`.groups`引数を使え」ということです。

作成した`by_vs`の中を確認してみましょう。

```{r}
group_vars(by_vs) # グループ数
by_vs |> kable()
```

グループが`vs`となっており，`am`でのグループ化が行われていないことがわかります。
そのため，
```{r}
by_vs |> summarise(n = sum(n))
```

とすると，`vs`ごとの合計データ数が集計されています。
グループ化を解除するには，`ungroup()`関数を使います。

```{r}
by_vs |>
  ungroup() |> #グループ化を解除
  summarise(n = sum(n)) |>
  kable(table.attr = "style='width:40%;'") |> kable_styling(full_width = FALSE)
```

グループが解除されたので，データの個数はデータフレーム全体のデータ数を表します。

```{r}
mtcars |> nrow()
```

デフォルトでは，`group_by()`は既存のグループ化を上書きします。

```{r}
by_cyl |> # cylでグループ化済み
  group_by(vs, am) |> # vsとamでグループ化
  group_vars() # グループ化されている変数を確認
```

`cyl`でグループ化されていた`by_cyl`が，`vs`と`am`でグループで上書きされています。
`add = TRUE`を指定すると，既存のグループ化に新しいグループ化を追加します。

```{r}
by_cyl |>
  group_by(vs, am, .add = TRUE) |>
  group_vars()
```

グループが`cyl`，`vs`，`am`の3つになっていることがわかります。

`group_by()`関数には，式を指定することもできます。
次の例では，`vs`と`am`の値を足した値でグループ化しています。

```{r}
mtcars |>
  group_by(vsam = vs + am) |>
  head() |>
  kable() |> kable_styling(font_size = 20) |>
  column_spec(12, bold = TRUE, background = 'mistyrose')
```



<!-- The implicit mutate() step is always performed on the ungrouped data. Here we get 3 groups: -->
`mutate()`はグループ化されていないデータに対して常に実行されるので，行数は変わりません。

次の例では，`group_by()`に`hp_cut = cut(hp,3)`という式を指定することで，`hp`を3等分したカテゴリーを表す変数`hp_cut`を作成しています。

```{r}
by_hp3 <- mtcars |>
  group_by(vs) |>
  group_by(hp_cut = cut(hp, 3))
by_hp3 |>
  head() |> # 先頭６行のみ表示
  kable() |> # 表形式
  kable_styling(font_size = 20) |> # フォントサイズ
  column_spec(12, bold = TRUE, background = 'mistyrose')
```

`by_hp3`の一番右の列に`hp_cut`が追加され、`(51.7,146]`や`(146,241]`といったカテゴリーが作成されているのがわかります。
この`hp_cut`の中に含まれるデータ数を`table()`関数で確認してみましょう。

```{r}
table(by_hp3$hp_cut)
```
`by_hp3`の`hp_cut`が3つのグループに分けられていることがわかります。

グループごとに`mutate()`を実行したい場合は，明示的に`mutate()`を使う必要があります。
たとえば，`vs`の値(0か1)ごとに`hp`を3等分したカテゴリーを表す変数`hp_cut`を作成するには，次のように書きます。

```{r}
by_hp6 <- mtcars |>
  group_by(vs) |> # vsでグループ化
  mutate(hp_cut = cut(hp, 3)) |> # hpを3等分したカテゴリーを表す変数hp_cutを作成
  group_by(hp_cut)

by_hp6 |>
  head() |>
  kable() |>
  kable_styling(font_size = 20) # hp_cutでグループ化
```

`by_hp6`の一番右の列に`hp_cut`が追加され、`(51.7,146]`や`(146,241]`といったカテゴリーが作成されているのがわかります。
先と同様に、`hp_cut`の中に含まれるデータ数を`table()`関数で確認してみましょう。

```{r}
table(by_hp6$hp_cut)
```

つぎは`vs`と`hp_cut`でグループ化したため、6グループに分けられていることがわかります。

<!-- when factors are involved and .drop = FALSE, groups can be empty -->

`group_by()`関数のオプション`.drop`は，グループ化されたデータの行数が0になった場合に，グループを削除するかどうかを指定します。
各グループがどの行を含んでいるのかを`group_rows()`で確認します。

```{r}
tbl <- tibble(
  x = 1:10, # 1から10の数列
  y = factor(
    rep(c("a", "c"), each  = 5), # "a"と"c"を5回繰り返す
    levels = c("a", "b", "c") # レベルには"a"と"b"と"c"を指定
    ) # レベルを指定
)
tbl |> kable() |> kable_styling(font_size = 20)
```

`tbl`のカテゴリー数が3となっていますが，カテゴリー変数`y`には`a`と`c`しか存在しない，というデータを作りました。
そのカテゴリー変数`y`のグループごとの行数を確認してみましょう。

:::{.column-margin}
ヘルプにあるとおりに`group_rows()`を使うとエラーがでますが、これは`group_rows()`が`dplyr`パッケージにあるものではなく基本関数`group_rows()`を使っているためです。
したがって，`dplyr::group_rows()`とすることでエラーを回避できます。
:::

```{r}
tbl |>
  group_by(y, .drop = FALSE) |>
  dplyr::group_rows()
```

出力がリスト型になっており，`[[2]]`の結果が`integer(0)`となっています。


### `group_by()`と`mutate()`

`group_by()`を用いてグループ化することで，`mutate()`関数を使ってグループごとに新しい変数を作成することができます。
