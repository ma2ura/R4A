[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Empirical Accounting Research",
    "section": "",
    "text": "Rによる実証会計入門\nこのサイトは、立命館大学経営学部の「プレゼミ」のために作成したサイトです。 松浦プレゼミでは， 会計学 \\times 統計分析をテーマとして，プログラミング言語Rを使って実証分析を行います。 1年次に学習した「基礎統計」の知識に，1年次と2年次春学期に学習した様々な専門科目の知識を組み合わせ， 現実に生じている経営現象を引き起こすメカニズムをデータから明らかにする方法を学習します。\nこのサイトは、Posit社が開発したQuartoというツールを使って作成しています。 Quartoでウェブサイトを作成するための情報についてはこのサイトを参考にしてください。https://quarto.org/docs/websites",
    "crumbs": [
      "Rによる実証会計入門"
    ]
  },
  {
    "objectID": "chap05_packages.html#よく使うパッケージ",
    "href": "chap05_packages.html#よく使うパッケージ",
    "title": "\n5  パッケージ\n",
    "section": "\n5.1 よく使うパッケージ",
    "text": "5.1 よく使うパッケージ\nRはパッケージを使うことで、様々な機能を追加することができます。 ここでは、よく使うパッケージを紹介します。\n\n5.1.1 パッケージのインストール\nパッケージをインストールするには、install.packages()を使います。 packagesのsを忘れないようにしましょう。 \nRのバージョンをアップデートしない限り、一度インストールすれば、次回からはインストールする必要はありません。\n例として、今後必ず使うtidyverseというパッケージをインストールしてみます。\n\ninstall.packages(\"tidyverse\")\n\ninstall.packages()関数の引数にインストールしたいパッケージ名を\"\"で囲んで指定します。 tidyverseはある一貫した哲学のもとに開発されたパッケージ群で、データの可視化や加工、モデリングなどの機能を提供します。非常に有用なので、導入しておきましょう。\n\n5.1.2 パッケージの読み込み\nパッケージをインストールしただけでは、パッケージの機能を使うことはできません。 パッケージの機能を使うには、library()関数を使ってパッケージを読み込む必要があります。 library()でパッケージを読み込むときは、\"\"で囲む必要はありません。\n\n\nlibrary\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n表示されたメッセージをみると、コアパッケージとして以下のものが読み込まれていることがわかります。\n\n\n\n✔ dplyr     1.1.4\n✔ forcats   1.0.0\n✔ ggplot2   3.4.4\n✔ lubridate 1.9.3\n✔ purrr     1.0.2\n\n\n\n\n\n✔ readr     2.1.4\n✔ stringr   1.5.1\n✔ tibble    3.2.1\n✔ tidyr     1.3.0\n\n\n\nまた、Conflictsとして基本関数と関数名が重複しているものとして、filter()とlag()が表示されています。\n\n✖ dplyr::filter() masks stats::filter()\n\n✖ dplyr::lag()    masks stats::lag()\n\n\nこれらの関数は、dplyrパッケージの関数を使うことで、基本関数の機能を上書きしてしまうので、注意が必要です。 明示的に特定のパッケージの関数を使いたい場合は、パッケージ名::関数名()という形で指定します。\n\n\nパッケージを指定\n\n毎回、library()関数を使ってパッケージを読み込むのは面倒なので、Rの設定ファイルに読み込むパッケージを記述しておくこともできますが、ここでは省略します。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>パッケージ</span>"
    ]
  },
  {
    "objectID": "chap05_packages.html#tidyverseパッケージ群",
    "href": "chap05_packages.html#tidyverseパッケージ群",
    "title": "\n5  パッケージ\n",
    "section": "\n5.2 tidyverseパッケージ群",
    "text": "5.2 tidyverseパッケージ群\nこれで、次の非常に便利なパッケージを使うことができるようになります。\n\n\ndplyrパッケージ\n\n\nmutate()関数：新しい変数を作成・追加する\n\nfilter()関数：条件に合うデータを抽出する\n\nselect()関数：特定の変数を抽出する\n\narrange()関数：データを並び替える\n\ngroup_by()関数：グループ化する\n\nsummarise()関数：統計量を計算する\n\n\n\ntidyrパッケージ\n\n\npivot_wider()関数：ロングをワイドに変換\n\npivot_longer()関数：ワイドをロングに変換\n\n\n\nggplot2パッケージ\n\n\nggplot()関数：作図する\n\n\n\nlubridateパッケージ\n\n\nymd()関数：年月日を表す文字列を日付型に変換\n\nymd_hms()関数：年月日時分秒を表す文字列を日時型に変換\n\n\n\nreadrパッケージ\n\n\nread_csv()関数：csvファイルを読み込む\n\nwrite_csv()関数：csvファイルを書き出す\n\n\n\npurrrパッケージ\n\n\nmap()関数：関数をベクトルの各要素に適用する\n\nmap_dbl()関数：関数をベクトルの各要素に適用し、数値ベクトルを返す\n\nmap_df()関数：関数をベクトルの各要素に適用し、データフレームを返す\n\n\n\nstringrパッケージ\n\n\nstr_detect()関数：文字列にパターンが含まれるかどうかを判定する\n\nstr_replace()関数：文字列の一部を置換する\n\nstr_extract()関数：文字列からパターンにマッチする部分を抽出する\n\nstr_sub()関数：文字列の一部を抽出する\n\nstr_split()関数：文字列を分割する\n\n\n\nこれらの関数は、tidyverseパッケージを読み込むことで、自動的に使えるようになります。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>パッケージ</span>"
    ]
  },
  {
    "objectID": "chap05_packages.html#おすすめパッケージ",
    "href": "chap05_packages.html#おすすめパッケージ",
    "title": "\n5  パッケージ\n",
    "section": "\n5.3 おすすめパッケージ",
    "text": "5.3 おすすめパッケージ\n他にも、次のようなパッケージを使います。\n\n5.3.1 テキストマイニング・自然言語処理\n\n\nRMecabパッケージ\n\n\nmecab()関数：形態素解析を行う\n\nmecabDic()関数：辞書を作成する\n\n\n\ntidytextパッケージ\n\n\nunnest_tokens()関数：テキストを単語に分割する\n\ncount()関数：単語の出現頻度を計算する\n\nanti_join()関数：データフレームの結合を行う\n\n\n\n5.3.2 多変量解析\n\n\npsychパッケージ\n\n\ndescribe()関数：データの要約統計量を計算する\n\nalpha()関数：クロンバックのα係数を計算する\n\nfa()関数：因子分析を行う\n\n\n\nlavaanパッケージ\n\n\ncfa()関数：検証的因子分析を行う\n\nsem()関数：構造方程式モデルを推定する\n\n\n\nsemPlotパッケージ\n\n\nsemPaths()関数：構造方程式モデルを可視化する\n\n\n\ngmodelsパッケージ\n\n\nCrossTable()関数：クロス集計表を作成する\n\n\n\n5.3.3 機械学習\n\n\nRWekaパッケージ\n\n\nJ48()関数：決定木を作成する\n\nRandomForest()関数：ランダムフォレストを作成する\n\nLogistic()関数：ロジスティック回帰を作成する\n\n\n\ncaretパッケージ\n\n\ntrain()関数：機械学習モデルを学習する\n\npredict()関数：機械学習モデルを使って予測する\n\n\n\n5.3.4 作表・作図\n\n\nmodelsummaryパッケージ\n\n\nmodelsummary()関数：モデルの結果を表形式で表示する\n\n\n\nknitrパッケージ\n\n\nkable()関数：データフレームを表形式で表示する\n\n\n\nkableExtraパッケージ\n\n\nkable_styling()関数：kable()関数で作成した表を装飾する\n\n\n\npatchworkパッケージ\n\n\n+演算子で複数のグラフを結合できる\n\n\n\nggrepelパッケージ\n\n\ngeom_text_repel()関数：重ならないようにテキストを配置する\n\n\n\nplotlyパッケージ\n\n\nggplotly()関数：ggplot2で作成したグラフをインタラクティブにする",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>パッケージ</span>"
    ]
  },
  {
    "objectID": "chap05_packages.html#まとめてインストール",
    "href": "chap05_packages.html#まとめてインストール",
    "title": "\n5  パッケージ\n",
    "section": "\n5.4 まとめてインストール",
    "text": "5.4 まとめてインストール\n複数のパッケージをインストールしたり、読み込んだりするのは面倒ですが、pacmanパッケージを使えば、一度にまとめて行うことができます。\n\n# install.packages(\"pacman\")\npacman::p_load(tidyverse, psych, ggthemes, knitr, kableExtra)\n\n読みだそうとしているパッケージがインストールされていない場合は、自動的にインストールしてくれます。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>パッケージ</span>"
    ]
  },
  {
    "objectID": "chap06_function.html#rの関数",
    "href": "chap06_function.html#rの関数",
    "title": "\n6  関数\n",
    "section": "\n6.1 Rの関数",
    "text": "6.1 Rの関数\nRには、様々な関数が用意されています。 関数とその使い方は覚えるしかありません。 ここでは、よく使う関数を紹介しつつ、Rの基本的な使い方を学んでいきます。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "chap06_function.html#関数と引数と戻り値",
    "href": "chap06_function.html#関数と引数と戻り値",
    "title": "\n6  関数\n",
    "section": "\n6.2 関数と引数と戻り値",
    "text": "6.2 関数と引数と戻り値\n関数(function)は、引数(ひきすう, argument)を与えると、何らかの処理を行い、結果を返してくれます。 返ってくる結果を戻り値(return value)と呼びます。\n\n6.2.1 用語\n\n関数\n引数\n戻り値\n\n\n関数\n\nこの資料では、関数をmean()のように、紫色のモノフォントで関数名と丸括弧で表しています。\nプログラミングの関数は数学の関数と同じで、xを引数とする関数f(x)がf(x) = a + bxという関数系を持っているとすると、引数xに値を代入するとb倍してaを加えた値が返ってくる、という処理を行います。\n関数がどのような引数を受けるのかは、関数のヘルプを参照するのが一番確実です。 ヘルプは、help(関数名)で表示できます。 たとえば、ベクトルの算術平均を返す関数mean()のヘルプをみてみましょう。\n\nhelp(mean)\n\n\n\nhelp()はヘルプを表示する関数です。?関数名でも同じ結果が得られます。\nすると、以下のようなヘルプが表示されます。\n\n\n\n\n\n\nArithmetic Mean\n\n\n\nDescription\nGeneric function for the (trimmed) arithmetic mean.\nUsage\nmean(x, ...)\nDefault S3 method:\nmean(x, trim = 0, na.rm = FALSE, ...)\nArguments\nx An R object. Currently there are methods for numeric/logical vectors and date, date-time and time interval objects. Complex vectors are allowed for trim = 0, only.\ntrim the fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed. Values of trim outside that range are taken as the nearest endpoint.\nna.rm a logical evaluating to TRUE or FALSE indicating whether NA values should be stripped before the computation proceeds.\n... further arguments passed to or from other methods.\n\n\n\nこの関数は(トリムされた)算術平均(arithmetic mean)を返す関数であることがわかります。 使い方は、mean(x)と書きます。 引数には順に、\n\n\nx : 数値などのベクトル\n\ntrim : トリムする割合(0から0.5の間)\n\nna.rm : NAを除外するかどうか\n\nの3つがあり、 デフォルトでは、trim = 0、na.rm = FALSEとなっています。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "chap06_function.html#引数の順番",
    "href": "chap06_function.html#引数の順番",
    "title": "\n6  関数\n",
    "section": "\n6.3 引数の順番",
    "text": "6.3 引数の順番\n関数に引数を与えるときは、引数の順番に注意する必要があります。mean()の場合は上の順番がデフォルトです。\n例として、1から9と100の整数ベクトルの合計と算術平均を求めてみましょう。データのサイズは10です。\n\nx &lt;- c(1:9,100) # 1から9と100の整数ベクトル\nsum(x) # 合計\n\n[1] 145\n\nmean(x) # 算術平均\n\n[1] 14.5\n\n\n単純に平均を求めるだけならこれで十分ですが、データに異常値があると平均がおかしな値になり、またデータに欠損値NAがあるとmean()はエラーを返します。 そこで、mean()の引数trimとna.rmを使って、異常値を除外した平均を求めてみましょう。\n\nmean(x, trim = 0.1, na.rm = TRUE)\n\n[1] 5.5\n\n\ntrim = 0.1は、データの上位と下位の10%を除外することを意味します。ここでは、1と100が除外され、2から9の平均が求められています。 na.rm = TRUEは、NAを除外することを意味します。\n引数の並びを変更しない場合は、引数名を省略して引数を与えることができます。\n\nmean(x, 0.1, TRUE) # 上と同じ結果\n\n[1] 5.5\n\n\n引数を省略せずに与える場合は、引数の順番を変更することが可能です。 たとえば、mean(x, trim=0.1, na.rm=TRUE)とmean(x, na.rm=TRUE, trim=0.1)は同じ結果を返します。\nやってみましょう。\n\nmean(na.rm = TRUE, trim = 0.1, x)\n\n[1] 5.5\n\n\nしかし、引数の表記を省略する場合は、引数のデフォルトの順番どおりに書く必要があります。次のように書くとエラーになります。\n\nmean(x, TRUE, 0.1) # エラー\n\nとにかく、ヘルプを読んで関数の使い方を確認することが大切です。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "chap06_function.html#自作関数を作る",
    "href": "chap06_function.html#自作関数を作る",
    "title": "\n6  関数\n",
    "section": "\n6.4 自作関数を作る",
    "text": "6.4 自作関数を作る\nプログラミングの重要な役割の1つが関数を作ることです。 行いたい処理や計算が、既存の関数では実現できない場合、自分で関数を作る必要があります。 一度関数を作成しておけば、何度も同じソースコードを書く必要はなくなり、また別のプログラムでも使いまわすことができます。\n関数を作るには、function()を使います。 function()の引数には、関数に与える引数を書きます。 たとえば、xとyを引数に取り、xとyの和を返す関数を作るには、以下のように書きます。\n\nadd &lt;- function(x, y) {\n  x + y\n}\n\n関数を作成するときは、関数の名前を決める必要があります。 関数の名前は、変数の名前と同じように、英数字とピリオド(.)、アンダースコア(_)からなる文字列で、数字で始まることはできません。 関数の名前は、関数を呼び出すときに使います。 たとえば、上の関数をadd()という名前にしたので、add(1, 2)と書くと、1 + 2の結果が返ってきます。\n\nadd(1, 2)\n\n[1] 3\n\n\n2回サイコロを振って出た目の合計を返す関数を作ってみましょう。\n\ndice = 1:6 # サイコロの目\nroll_dice &lt;- function() {\n  sum(sample(dice, 2, replace = TRUE))\n}\nroll_dice()\n\n[1] 8\n\n\n\n\nsample()は、ベクトルからランダムに要素を抽出する関数です。replace = TRUEとすると、同じ要素を何度も抽出することができます。\nsum()は、ベクトルの要素の和を返す関数です。\n上記のように、引数を取らない関数も作ることができます。 引数を取らない関数を作るときは、引数の丸括弧を省略することができます。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "chap06_function.html#初期値を設定する",
    "href": "chap06_function.html#初期値を設定する",
    "title": "\n6  関数\n",
    "section": "\n6.5 初期値を設定する",
    "text": "6.5 初期値を設定する\n関数を作成するときは、引数の初期値を設定することができます。初期値を設定しておけば、引数を省略して関数を呼び出すことができます。\nたとえば、xとyの和を返す関数を作成するとき、yの初期値を0に設定しておけば、xだけを与えて関数を呼び出すことができます。\n\nadd &lt;- function(x, y = 3) {\n  x + y\n}\nadd(1) # 1 + 3\n\n[1] 4",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>関数</span>"
    ]
  },
  {
    "objectID": "chap07_pipe.html#パイプ演算子の種類",
    "href": "chap07_pipe.html#パイプ演算子の種類",
    "title": "\n7  パイプ演算子\n",
    "section": "\n7.1 パイプ演算子の種類",
    "text": "7.1 パイプ演算子の種類\n関数の適用結果を次の関数の第一引数に渡す演算を行うパイプ演算子を紹介します。 パイプ演算子を使うことで，可読性が高く，メンテナンスしやすいコードを書くことが出来るので，ぜひ慣れておきましょう。\nRには\n\n|&gt;\n%&gt;%\n\nの2種類のパイプ演算子があります。 |&gt;はR 4.1.0から導入されたいパイプ演算子です。 %&gt;%はtidyverseパッケージ群magrittrパッケージに含まれるパイプ演算子です。 この|&gt;と%&gt;%はほぼ同じ機能をもっているので，ここでは基本関数の|&gt;を使うことにします。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>パイプ演算子</span>"
    ]
  },
  {
    "objectID": "chap07_pipe.html#パイプ演算子",
    "href": "chap07_pipe.html#パイプ演算子",
    "title": "\n7  パイプ演算子\n",
    "section": "\n7.2 パイプ演算子",
    "text": "7.2 パイプ演算子\nパイプ演算子を使うと、どのような処理になるのか、確認してみましょう。 パイプ演算子は、左辺の関数の結果を右辺の関数の第一引数に渡します。 例えば、3つの引数を必要とする関数だと、次のように書きます。\n\n\n関数\n\nたとえば、正規分布にしたがう乱数を発生させるrnorm()関数は、引数に標本サイズ、分布の平均、分布の標準偏差をとり、rnorm(n = 100, mean = 0, sd = 1)のように書きます。\nこれをパイプ演算子を使うと，次のように書けます。\n\n100 |&gt; rnorm(mean = 0, sd = 1)\n\n図で表すと次のようになります。\n\n\nパイプ演算子\n\n\n\n第1引数に代入される値を関数の外に出すことで、引数が複数ある関数の場合でも、関数のネストを避けることができ、可読性が高くなります。\nもう一つの例として，データフレームの先頭の数行を表示するhead()を使ってみましょう。 head()は引数として\n\nデータフレームやベクトル\n表示する行数\n\nの2つをとります。 省略せずにすべて書くと，次のようになります。\n\n\nmean()関数\n\nパイプ演算子を使うと，次のように書けます。\n\n\nパイプでmean()",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>パイプ演算子</span>"
    ]
  },
  {
    "objectID": "chap07_pipe.html#複数の処理をパイプでつなげる",
    "href": "chap07_pipe.html#複数の処理をパイプでつなげる",
    "title": "\n7  パイプ演算子\n",
    "section": "\n7.3 複数の処理をパイプでつなげる",
    "text": "7.3 複数の処理をパイプでつなげる\n複数の関数を組み合わせた処理を行う場合、複雑なコードになりがちなのを簡潔に書くことが出来ます。 たとえば，次のような処理を考えてみましょう。\n\n平均ゼロ、標準偏差1の標準正規分布から100個の乱数を発生させる\nその乱数の平均を求める\n小数点以下2桁で丸める\n\nパイプ演算子を使わずに書くと、次のようになります。\n\nset.seed(123) # 乱数の再現性を確保\nn &lt;- 100\nround(mean(rnorm(n, mean = 0, sd = 1)), 2)\n\n[1] 0.09\n\n\n関数が重なって(ネストして)いるので、読みにくいですね。 可読性の低いコードはエラーを見つけにくく、メンテナンスが困難になります。\n\n\n\n\nset.seed()：乱数の再現性を確保\n\nrnorm()：正規分布にしたがう乱数を発生\n\nmean()：算術平均を計算\n\nround()：小数点以下を丸める\n\nこのコードをパイプ演算子を使って書き直すと、次のように書けます。パイプ演算子の直後に改行し、インデントを揃えると、可読性が高くなります。\n\nset.seed(123) # 乱数の再現性を確保\nn &lt;- 100\nn |&gt; \n    rnorm(mean = 0, sd = 1) |&gt; # 正規分布から乱数\n    mean() |&gt; # 平均を計算\n    round(2) # 小数点以下第2位で丸める\n\n[1] 0.09\n\n\n縦に長いコードになってしまいましたが、関数が重なっていないので可読性が高く、またコメントも書きやすくなります。\n\n7.3.1 練習\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>パイプ演算子</span>"
    ]
  },
  {
    "objectID": "chap07_pipe.html#パイプ演算子の相違点と注意点",
    "href": "chap07_pipe.html#パイプ演算子の相違点と注意点",
    "title": "\n7  パイプ演算子\n",
    "section": "\n7.4 パイプ演算子の相違点と注意点",
    "text": "7.4 パイプ演算子の相違点と注意点\n基本Rの|&gt;とmagrittrパッケージの%&gt;%はほぼ同じ機能をもっていますが、いくつかの相違点があります。\n\n\nx %&gt;% meanはOKだけれど、x \\&gt; meanはエラーになる。x |&gt; mean()と関数であることを明示する必要がある。\n\n%&gt;%はx %&gt;% rnorm(100, mean = 0, sd =.)のように、.を使って左辺のxを右辺のどこに代入するかを指定できるが、|&gt;は関数の第1引数のみに代入される。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>パイプ演算子</span>"
    ]
  },
  {
    "objectID": "chap08_tidydata.html#整然データとは",
    "href": "chap08_tidydata.html#整然データとは",
    "title": "\n8  整然データ\n",
    "section": "\n8.1 整然データとは",
    "text": "8.1 整然データとは\n\n\n整然データセットはみんな似ているが，汚いデータセットはみんな独特で散らかっている。 — Hadley Wickham\n\nR神Hadley Wickham氏は，データの型を理解することを，データ分析の第一歩とし，その一貫として整然データ(tidy data)という考え方を提唱しています。 整然データとは，次のようなルールに従って構築されたデータのことです(Wickham, 2014), 参考https://id.fnshr.info/2017/01/09/tidy-data-intro/。\n\n\n\n\n\n\n\n重要\n\n\n\n\n各観測値(observation)は行(row)であり、各行は1つの観測値である。\n各変数(variable)は列(column)であり、各列は1つの変数である。\n各値(value)はセル(cell)であり、1セルは1つの値である。\n\n\n\n\n\n\n\n\n\n\n\n1.観測値\n\n\n\n\n\n2.変数\n\n\n\n\n\n3.値\n\n\n\n\n整然データのルールを満たすデータは，データの整理や可視化が容易になります。 そして整然データを扱うために非常に強力なツールを提供してくれるのが，tidyverseパッケージ群です。 以下では，tidyverseパッケージ群の中でも，データの整理に特化したtidyrパッケージを使って，整然データを作成する方法を学びます。\n\nlibrary(tidyr)\n\n\n8.1.1 long形式とwide形式\n人間には読みやすいけれどパソコンは読みにくい，というデータの形式があります。例えば下の表を見てみましょう。\n\n自動車会社3社の売上高\n\n地点\n2022\n2023\n\n\n\nトヨタ自動車\n31379507\n37154298\n\n\n日産自動車\n8424585\n10596695\n\n\n本田技研工業\n14552696\n16907725\n\n\n\nこのような形のデータをワイド形式(wide)といいます。 この表は，人間にとっては分かりやすいですが，実はコンピュータにとっては，分かりにくいものです。 またこのデータは、列が変数になっていないので整然データではありません。\nコンピュータが理解しやすいデータとして表すなら，次のような表になります。\n\n自動車会社のロング型の表\n\n企業名\n年度\n売上高\n\n\n\nトヨタ自動車\n2022\n31379507\n\n\nトヨタ自動車\n2023\n37154298\n\n\n日産自動車\n2022\n8424585\n\n\n日産自動車\n2023\n10596695\n\n\n本田技研工業\n2022\n14552696\n\n\n本田技研工業\n2023\n16907725\n\n\n\nこのような形式のデータをロング型(long)といいます。\n上の表は，行が、トヨタの2022年度の売上高、といったように1つの行が1つの観測を表しています(ルール1)。 企業名、年度、売上高の3列から構成されていて、1列が1つの変数を意味している(ルール2)。 各セルには1つの値が入っています(ルール3)。 よって，これが整然データとなります。\n上のロング型のデータを使って，ロングからワイド，ワイドからロングの操作を学びましょう。 data.frame()関数を使って，3つの変数name，year，saleをもつデータフレームを作ります。\n\nlibrary(knitr)\nlibrary(kableExtra)\ndf_car &lt;- data.frame(\n    # rep(\"札幌\",3)は\"札幌\"を3回繰り返すという意味\n    name = c(rep(\"トヨタ\",2),rep(\"日産\",2),rep(\"ホンダ\",2)),\n    year = rep(c(\"2022\", \"2023\"),3), # 時点\n    sale = c(31379507,37154298,8424585,10596695,14552696,16907725) # 気温\n)\ndf_car |&gt; kable() |&gt; kable_styling(font_size = 20)\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725\n\n\n\n\n\nこれはロング型の整然データとなります。\nロングからワイド pivot_wider\n\nRで使うならこのままでよいのですが，あえてこれをワイド型に変えてみましょう。\n\n\nワイド型をロング型に\n\n\nデータフレームをロング型からワイド型に変換するには、tidyrパッケージのpivot_wider()関数を使います。\n\n\n以前は、reshap2パッケージのdcast()関数や、その改良版のtidyrパッケージのspread()関数が使われていました。しかし、これらは根本的に設計ミスがあるとして、新たに設計しなおされたtidyrのpivot_wider()が現在のベストプラクティスです。\npivot_wider()の主な引数は，\n\nnames_from\nvalues_from\n\nです。 names_fromは，ワイド型に変換するときに，どの変数の値を列にするかを指定します。 values_fromは、names_fromで指定した変数の値が列になったとき、どの値をもつ変数にするのかを指定します。\n以下のコードでは，year変数の値(つまり2022と2023)を列に，その変数がsale変数の値をもつように指定し，df_wideという変数に代入しています。\n\ndf_wide &lt;- df_car |&gt;\n    pivot_wider(\n        names_from = year, # 列にする変数\n        values_from = sale # 変数がもつ値\n        )\ndf_wide |&gt; kable() |&gt; kable_styling(font_size = 20)\n\n\n\nname\n2022\n2023\n\n\n\nトヨタ\n31379507\n37154298\n\n\n日産\n8424585\n10596695\n\n\nホンダ\n14552696\n16907725\n\n\n\n\n\nこれでワイド型に変換できました。\nワイドからロング pivot_longer\n\n次に，このワイド型のデータをロング型に変換してみます。\n\n\nワイド型をロング型に\n\nデータフレームをワイド型からロング型に変換するには、tidyrパッケージのpivot_longer()関数を使います。\n\n\n以前は、reshap2パッケージのmelt()関数や、その改良版のtidyrパッケージのgahter()関数が使われていました。しかし、これらは根本的に設計ミスがあるとして、新たに設計しなおされたtidyrのpivot_longer()が現在のベストプラクティスです。\nば\npivot_longer()の引数は，colsとnames_toとvalues_toです。\n\n\ncolsは，ロング型に変換するときに，どの変数を行にするかを指定\n\nnames_toは，ロング型に変換するときに，どの変数の値を使うかを指定\n\nvalues_toは，ロング型に変換するときに，どの変数の値を使うかを指定\n\n以下のコードでは，2022，2023の2つの変数を行に，yearという変数の値を列に，saleという変数の値を値にして，df_longという変数に代入しています。\n\ndf_long &lt;- df_wide |&gt;\n    pivot_longer(\n        cols = c(\"2022\",\"2023\"), # 縦にする変数\n        names_to = \"year\", # 縦にした変数名\n        values_to = \"sale\") # 値\ndf_long |&gt; kable() |&gt; kable_styling(font_size = 20)\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725\n\n\n\n\n\n元のロング型に戻りました。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>整然データ</span>"
    ]
  },
  {
    "objectID": "chap08_tidydata.html#練習してみよう",
    "href": "chap08_tidydata.html#練習してみよう",
    "title": "\n8  整然データ\n",
    "section": "\n8.2 練習してみよう。",
    "text": "8.2 練習してみよう。\nまず、\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>整然データ</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html",
    "href": "chap09_handling.html",
    "title": "\n9  データハンドリング\n",
    "section": "",
    "text": "10 If you want it to be performed by groups, you have to use an explicit mutate() call.\nグループごとにmutate()を実行したい場合は，明示的にmutate()を使う必要があります。 たとえば，vsの値(0か1)ごとにhpを3等分したカテゴリーを表す変数hp_cutを作成するには，次のように書きます。\nmtcars |&gt;\n  group_by(vs) |&gt; # vsでグループ化\n  mutate(hp_cut = cut(hp, 3)) |&gt; # hpを3等分したカテゴリーを表す変数hp_cutを作成\n  group_by(hp_cut) # hp_cutでグループ化\n\n\n\n\n\nmpg\n\n\ncyl\n\n\ndisp\n\n\nhp\n\n\ndrat\n\n\nwt\n\n\nqsec\n\n\nvs\n\n\nam\n\n\ngear\n\n\ncarb\n\n\nhp_cut\n\n\n\n\n\n21.0\n\n\n6\n\n\n160.0\n\n\n110\n\n\n3.90\n\n\n2.620\n\n\n16.46\n\n\n0\n\n\n1\n\n\n4\n\n\n4\n\n\n(90.8,172]\n\n\n\n\n21.0\n\n\n6\n\n\n160.0\n\n\n110\n\n\n3.90\n\n\n2.875\n\n\n17.02\n\n\n0\n\n\n1\n\n\n4\n\n\n4\n\n\n(90.8,172]\n\n\n\n\n22.8\n\n\n4\n\n\n108.0\n\n\n93\n\n\n3.85\n\n\n2.320\n\n\n18.61\n\n\n1\n\n\n1\n\n\n4\n\n\n1\n\n\n(75.7,99.3]\n\n\n\n\n21.4\n\n\n6\n\n\n258.0\n\n\n110\n\n\n3.08\n\n\n3.215\n\n\n19.44\n\n\n1\n\n\n0\n\n\n3\n\n\n1\n\n\n(99.3,123]\n\n\n\n\n18.7\n\n\n8\n\n\n360.0\n\n\n175\n\n\n3.15\n\n\n3.440\n\n\n17.02\n\n\n0\n\n\n0\n\n\n3\n\n\n2\n\n\n(172,254]\n\n\n\n\n18.1\n\n\n6\n\n\n225.0\n\n\n105\n\n\n2.76\n\n\n3.460\n\n\n20.22\n\n\n1\n\n\n0\n\n\n3\n\n\n1\n\n\n(99.3,123]\n\n\n\n\n14.3\n\n\n8\n\n\n360.0\n\n\n245\n\n\n3.21\n\n\n3.570\n\n\n15.84\n\n\n0\n\n\n0\n\n\n3\n\n\n4\n\n\n(172,254]\n\n\n\n\n24.4\n\n\n4\n\n\n146.7\n\n\n62\n\n\n3.69\n\n\n3.190\n\n\n20.00\n\n\n1\n\n\n0\n\n\n4\n\n\n2\n\n\n(51.9,75.7]\n\n\n\n\n22.8\n\n\n4\n\n\n140.8\n\n\n95\n\n\n3.92\n\n\n3.150\n\n\n22.90\n\n\n1\n\n\n0\n\n\n4\n\n\n2\n\n\n(75.7,99.3]\n\n\n\n\n19.2\n\n\n6\n\n\n167.6\n\n\n123\n\n\n3.92\n\n\n3.440\n\n\n18.30\n\n\n1\n\n\n0\n\n\n4\n\n\n4\n\n\n(99.3,123]\n\n\n\n\n17.8\n\n\n6\n\n\n167.6\n\n\n123\n\n\n3.92\n\n\n3.440\n\n\n18.90\n\n\n1\n\n\n0\n\n\n4\n\n\n4\n\n\n(99.3,123]\n\n\n\n\n16.4\n\n\n8\n\n\n275.8\n\n\n180\n\n\n3.07\n\n\n4.070\n\n\n17.40\n\n\n0\n\n\n0\n\n\n3\n\n\n3\n\n\n(172,254]\n\n\n\n\n17.3\n\n\n8\n\n\n275.8\n\n\n180\n\n\n3.07\n\n\n3.730\n\n\n17.60\n\n\n0\n\n\n0\n\n\n3\n\n\n3\n\n\n(172,254]\n\n\n\n\n15.2\n\n\n8\n\n\n275.8\n\n\n180\n\n\n3.07\n\n\n3.780\n\n\n18.00\n\n\n0\n\n\n0\n\n\n3\n\n\n3\n\n\n(172,254]\n\n\n\n\n10.4\n\n\n8\n\n\n472.0\n\n\n205\n\n\n2.93\n\n\n5.250\n\n\n17.98\n\n\n0\n\n\n0\n\n\n3\n\n\n4\n\n\n(172,254]\n\n\n\n\n10.4\n\n\n8\n\n\n460.0\n\n\n215\n\n\n3.00\n\n\n5.424\n\n\n17.82\n\n\n0\n\n\n0\n\n\n3\n\n\n4\n\n\n(172,254]\n\n\n\n\n14.7\n\n\n8\n\n\n440.0\n\n\n230\n\n\n3.23\n\n\n5.345\n\n\n17.42\n\n\n0\n\n\n0\n\n\n3\n\n\n4\n\n\n(172,254]\n\n\n\n\n32.4\n\n\n4\n\n\n78.7\n\n\n66\n\n\n4.08\n\n\n2.200\n\n\n19.47\n\n\n1\n\n\n1\n\n\n4\n\n\n1\n\n\n(51.9,75.7]\n\n\n\n\n30.4\n\n\n4\n\n\n75.7\n\n\n52\n\n\n4.93\n\n\n1.615\n\n\n18.52\n\n\n1\n\n\n1\n\n\n4\n\n\n2\n\n\n(51.9,75.7]\n\n\n\n\n33.9\n\n\n4\n\n\n71.1\n\n\n65\n\n\n4.22\n\n\n1.835\n\n\n19.90\n\n\n1\n\n\n1\n\n\n4\n\n\n1\n\n\n(51.9,75.7]\n\n\n\n\n21.5\n\n\n4\n\n\n120.1\n\n\n97\n\n\n3.70\n\n\n2.465\n\n\n20.01\n\n\n1\n\n\n0\n\n\n3\n\n\n1\n\n\n(75.7,99.3]\n\n\n\n\n15.5\n\n\n8\n\n\n318.0\n\n\n150\n\n\n2.76\n\n\n3.520\n\n\n16.87\n\n\n0\n\n\n0\n\n\n3\n\n\n2\n\n\n(90.8,172]\n\n\n\n\n15.2\n\n\n8\n\n\n304.0\n\n\n150\n\n\n3.15\n\n\n3.435\n\n\n17.30\n\n\n0\n\n\n0\n\n\n3\n\n\n2\n\n\n(90.8,172]\n\n\n\n\n13.3\n\n\n8\n\n\n350.0\n\n\n245\n\n\n3.73\n\n\n3.840\n\n\n15.41\n\n\n0\n\n\n0\n\n\n3\n\n\n4\n\n\n(172,254]\n\n\n\n\n19.2\n\n\n8\n\n\n400.0\n\n\n175\n\n\n3.08\n\n\n3.845\n\n\n17.05\n\n\n0\n\n\n0\n\n\n3\n\n\n2\n\n\n(172,254]\n\n\n\n\n27.3\n\n\n4\n\n\n79.0\n\n\n66\n\n\n4.08\n\n\n1.935\n\n\n18.90\n\n\n1\n\n\n1\n\n\n4\n\n\n1\n\n\n(51.9,75.7]\n\n\n\n\n26.0\n\n\n4\n\n\n120.3\n\n\n91\n\n\n4.43\n\n\n2.140\n\n\n16.70\n\n\n0\n\n\n1\n\n\n5\n\n\n2\n\n\n(90.8,172]\n\n\n\n\n30.4\n\n\n4\n\n\n95.1\n\n\n113\n\n\n3.77\n\n\n1.513\n\n\n16.90\n\n\n1\n\n\n1\n\n\n5\n\n\n2\n\n\n(99.3,123]\n\n\n\n\n15.8\n\n\n8\n\n\n351.0\n\n\n264\n\n\n4.22\n\n\n3.170\n\n\n14.50\n\n\n0\n\n\n1\n\n\n5\n\n\n4\n\n\n(254,335]\n\n\n\n\n19.7\n\n\n6\n\n\n145.0\n\n\n175\n\n\n3.62\n\n\n2.770\n\n\n15.50\n\n\n0\n\n\n1\n\n\n5\n\n\n6\n\n\n(172,254]\n\n\n\n\n15.0\n\n\n8\n\n\n301.0\n\n\n335\n\n\n3.54\n\n\n3.570\n\n\n14.60\n\n\n0\n\n\n1\n\n\n5\n\n\n8\n\n\n(254,335]\n\n\n\n\n21.4\n\n\n4\n\n\n121.0\n\n\n109\n\n\n4.11\n\n\n2.780\n\n\n18.60\n\n\n1\n\n\n1\n\n\n4\n\n\n2\n\n\n(99.3,123]\n結果のGroups:   hp_cut [6]から，vsとhp_cutで6つのグループになっていることがわかります。\ngroup_by()関数のオプション.dropは，グループ化されたデータの行数が0になった場合に，グループを削除するかどうかを指定します。 各グループがどの行を含んでいるのかをgroup_rows()で確認します。\ntbl &lt;- tibble(\n  x = 1:10, # 1から10の数列\n  y = factor(\n    rep(c(\"a\", \"c\"), each  = 5), # \"a\",\"c\"を5回繰り返す\n    levels = c(\"a\", \"b\", \"c\")\n    ) # レベルを指定\n)\ntbl\n\n\n\n\nx\n\n\ny\n\n\n\n\n\n1\n\n\na\n\n\n\n\n2\n\n\na\n\n\n\n\n3\n\n\na\n\n\n\n\n4\n\n\na\n\n\n\n\n5\n\n\na\n\n\n\n\n6\n\n\nc\n\n\n\n\n7\n\n\nc\n\n\n\n\n8\n\n\nc\n\n\n\n\n9\n\n\nc\n\n\n\n\n10\n\n\nc\ntblのカテゴリー数が3となっていますが，カテゴリー変数yにはaとcしか存在しない，というデータを作りました。 そのカテゴリー変数yのグループごとの行数を確認してみましょう。\ntbl |&gt;\n  group_by(y, .drop = FALSE) |&gt;\n  dplyr::group_rows()\n\n&lt;list_of&lt;integer&gt;[3]&gt;\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\ninteger(0)\n\n[[3]]\n[1]  6  7  8  9 10\n出力がリスト型になっており，[[2]]の結果がinteger(0)となっています。",
    "crumbs": [
      "第2部 前処理と記述統計量と可視化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "part01.html#第1部の目次",
    "href": "part01.html#第1部の目次",
    "title": "第1部 R言語の基礎",
    "section": "第1部の目次",
    "text": "第1部の目次\n\n第2章 準備と基本操作\n第3章 コード作成の作法\n第4章 Rの基礎\n第5章 データフレーム",
    "crumbs": [
      "第1部 R言語の基礎"
    ]
  },
  {
    "objectID": "chap02_intro.html#rの準備",
    "href": "chap02_intro.html#rの準備",
    "title": "1  準備",
    "section": "1.1 Rの準備",
    "text": "1.1 Rの準備\n\n1.1.1 Rのインストール\nRは、The Comprehensive R Archive Network (CRAN)からダウンロードできます。 Rをインストールする際のベストプラクティスについては様々なウェブサイトで紹介されているので、そちらを参照してください。 オススメとして、高知工科大学の矢内勇生先生のウェブサイトこちらの「RとRstudioのインストール方法の解説」でPDFにまとめられている資料があります。\n松浦のプレゼミで使うのは、以下のアプリケーションです。\n\nR\nRstudio\nQuarto\nVS Code\n\nインストールが上手くいかない、インストールが面倒・困難である、何もインストールしたくない、という方は、\n\nPosit Cloud\nGoogle Colaboratory\n\nのどちらかを使ってください。 アカウントを作成すると、ブラウザ上でRを実行することができます。Google ColaboratoryはPythonの実行環境ですが、一手間かければRも実行できます。以下のサイトを参考にしてください。\nRによる統計入門\n\n\n1.1.2 テキストエディタ\nR言語でプログラムを書くには、R専用のIDE(Integrated Development Environment)であるRstudioを使うのが一般的ですが、より汎用的なテキストエディタを使うという選択肢もあります。 テキストエディタとは文字通り、文字を編集するためのソフトウェアです。 有名なものとしては、\n\nVisual Studio Code (Microsoft)\nSublime Text (Sublime HQ)\nVim (Bram Moolenaar) 上級者向け\nEmacs (GNU) 上級者向け\n\nなどがあり、松浦はVisual Studio Code(以下、VS Code)を使ってます。\n\n\n\nVS Code\n\n\nとはいうものの、やはり最初はRstudioを使う方が設定などが簡単なので、以下ではRstudioの設定を紹介します。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備と基本操作</span>"
    ]
  },
  {
    "objectID": "chap02_intro.html#rstudioの準備",
    "href": "chap02_intro.html#rstudioの準備",
    "title": "1  準備",
    "section": "1.2 Rstudioの準備",
    "text": "1.2 Rstudioの準備\nRtsudioを起動すると、以下のような画像が表示されます。\n\n\n\nRtsudio\n\n\n次の画像で赤丸で囲まれているマークをクリックすると、コード画面が表示されます。\n\n\n\nRstudio\n\n\nRstudioは4つの画面で構成されています。\n\nスクリプトエディタ\nコンソール\n環境\nプロットなど\n\n\n\n\nRstudio\n\n\n上のメニューバーから「Tools」→「Global Options」を選択すると、以下のような画面が表示されます。\n\n\n\nRstudio\n\n\n「General」の「Save workspace to .RData on exit」を「Never」に変更しておいてください。\nまた、Rstudioの画面を見やすくするため、先のOptionsの画面の左側メニューの「Pane Layout」を選び、以下のように設定しておくとよいでしょう。\n\n\n\nRstudio\n\n\n設定の「Appearance」で画面の見た目やフォントなどを変更することで、自分の好みの設定にすることができます。 松浦は、テーマにmonokai、フォントにFira Fontを使用してます。 Fira Fontはリガチャに対応したモノスペースフォントなので、Rstudioのコードエディタで&lt;-などが綺麗に表示されます。\n\n\n\nRstudio\n\n\n\n1.2.1 Rstudioのプロジェクト機能\nRstudioにはプロジェクトと呼ばれる機能があり、プロジェクトを作成しておくと、ファイル管理や作業履歴の管理がしやすくなります。\nプロジェクトを作成するには、Rstudioの画面上部の「File」→「New Project」を選択するか、以下の図にあるとおり、右上の「Project」をクリックします。\n\n\n\nRstudio TOP\n\n\nすると、以下のようなウインド出てきます。\n\n\n\nRstudio Project\n\n\n「New Project…」を選択すると、次のウインドが表示されます。\n\n\n\nRstudio Project\n\n\n「New Directory」を選択して、プロジェクトを保存するディレクトリを選択します。\n\n\n\nRstudio Project\n\n\nここでは、新しいプロジェクトを作るので、「New Project」を選択すると、次の「Create New Project」のウインドが表示されます。\n\n\n後で解説するQuartoを使って論文やウェブサイトを作成するときは、「Quarto Website」や「Quarto Book」を選択します。\n\n\n\nRstudio Project\n\n\nDirectory name:のところに、Rで生成されるファイルなどを保存するフォルダー名を入力します。 半角英数の名前にするほうが、エラー回避になります。\nCreate project as subdirectory of:: のところに、プロジェクトを保存する場所(これをディレクトリといいます)を選択します。好きな場所を指定することができますが、やはり日本語名のフォルダなどは避けた方がよいでしょう。\n\n\n\nRstudio Project\n\n\n最後に「Create Project」をクリックすると、プロジェクトが作成されます。\n\n\n\nRstudio Project\n\n\nプロジェクトが作成されると、プロジェクト名のフォルダーが作成され、その中に.Rprojという拡張子のファイルが作成されます。 これで、プロジェクトの作成は完了です。 今後、作成した.Rprojファイルをダブルクリックするか、Rstudioの画面上部の「File」→「Open Project」を選択して、.Rprojファイルを選択するだけで、プロジェクトが開き、作業ディレクトリの場所が設定されます。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備と基本操作</span>"
    ]
  },
  {
    "objectID": "chap02_intro.html#vs-codeの準備",
    "href": "chap02_intro.html#vs-codeの準備",
    "title": "1  準備",
    "section": "1.3 VS Codeの準備",
    "text": "1.3 VS Codeの準備\n\n1.3.1 VS Codeのインストール\nVisual Studio Code(以下、VS Code)をインストールするには、Microsoftの公式サイトからダウンロードできます。\n\n\n\nVS Code\n\n\nウェブサイトの「Visual Studio Code をダウンロードする」をクリックすると、アクセスしているコンピューターのOSに合わせたインストーラーをダウンロードできるサイトに移動します。\n\n\n\nVS Code Download\n\n\nMacOSの場合、Intel Mac用とApple Silicon用(M1とかM2)とどちらでも動作するユニバーサル版の3つを選択できます。\nWindowsPCの場合は、32bit版と64bit版、そしてSurface Proなどに搭載されているArmチップ用の3つを選択できます。\n\n\n1.3.2 VS Codeの設定\nVS Codeを起動すると、以下のような画面が表示されます。\n\n\n\nVS Code top\n\n\n左側のメニューから「拡張機能」を選択すると、以下のような画面が表示されます。\n\n\n\nVS Code Extension\n\n\nこの画面上部の検索窓に文字を入力して、Enterキーを押すと、拡張パッケージが検索されます。\n\n\n\nVS Code Extention Search\n\n\nオススメ拡張パッケージは以下の通りです。\n\nJapanese Language Pack for Visual Studio Code : 日本語化\nR: R言語の実行環境\nQuarto : VS CodeでQuartoファイルを作成・実行する\nindent-rainbow : インデントを虹色にする\nvscode-icons : ファイルのアイコンを変更する\nRainbow CSV : CSVファイルを読みやすくする\nColor Highlight : カラーコードを色で表示する",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備と基本操作</span>"
    ]
  },
  {
    "objectID": "chap04_dataframe.html#データフレームとは",
    "href": "chap04_dataframe.html#データフレームとは",
    "title": "\n4  データフレーム\n",
    "section": "\n4.1 データフレームとは",
    "text": "4.1 データフレームとは\nRでよく使われるデータの形式にデータフレーム(data frame)があります。 データフレームは、行と列からなる表形式のデータで、Excelのシートのようなものです。\n\n\nRにもともと備わっているdata.frameの拡張版として、tidyverseではtibbleというデータフレームの拡張版が使われていますが、初心者のうちはほとんど違いを意識することがないと思うので、ここではdata.frameを使います。\n\n\nデータフレームの例",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データフレーム</span>"
    ]
  },
  {
    "objectID": "chap04_dataframe.html#データフレームの作成",
    "href": "chap04_dataframe.html#データフレームの作成",
    "title": "\n4  データフレーム\n",
    "section": "\n4.2 データフレームの作成",
    "text": "4.2 データフレームの作成\n通常、外部のデータベースから取得したExcelデータやCSVデータをRで読み込むと、データフレームとして読み込まれます。 ここでは練習のために、data.frame()を使ってデータフレームを作成します。 data.frame()関数の引数は主に，\n\n\n... : 列に格納するデータ\n\nrow.names : 行名\n\ncheck.rows : 行数をチェックするかどうか\n\ncheck.names : 列名をチェックするかどうか\n\nstringsAsFactors : 文字列を因子型に変換するかどうか\n\nfix.empty.names : 空の列名を修正するかどうか\n\n以下では、3つの自動車メーカーの2022年と2023年の売上高をデータフレームdf_carに代入します。\n\ndf_car &lt;- data.frame( # データフレームを作成\n    name = c(rep(\"トヨタ\",2),rep(\"日産\",2),rep(\"ホンダ\",2)), # 企業名\n    year = rep(c(\"2022\", \"2023\"),3), # 年度\n    sale = c(31379507,37154298,8424585,10596695,14552696,16907725)  # 売上高\n)\ndf_car\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n\n\n\n\n\n\nrep()は、ベクトルの要素を繰り返す関数です。引数は、rep(繰り返すベクトル, 繰り返す回数)です。\nデータフレームdf_carには、3つの変数があります。\n\nname : 自動車メーカー名\nyear : 決算年\nsale : 売上高(百万円)\n\n次に、このデータフレームの中の特定の変数や値にアクセスする方法を説明します。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データフレーム</span>"
    ]
  },
  {
    "objectID": "chap04_dataframe.html#変数へのアクセス",
    "href": "chap04_dataframe.html#変数へのアクセス",
    "title": "\n4  データフレーム\n",
    "section": "\n4.3 変数へのアクセス",
    "text": "4.3 変数へのアクセス\nデータフレームの中の特定の変数にアクセスするには、$を使います。\n\n\nデータフレームの変数\n\nたとえば、df_carのname変数を表示するには、次のようにします。\n\ndf_car$name\n\n[1] \"トヨタ\" \"トヨタ\" \"日産\"   \"日産\"   \"ホンダ\" \"ホンダ\"\n\n\nあるいは、データフレームの列数を指定することで、特定の変数にアクセスすることもできます。 Rのデータフレームは行と列に1から順に番号が振られています。\n\n\nデータフレームの位置\n\n特定の行、列、値にアクセスするには、[行,列]を指定します。\n\n\n変数へのアクセス\n\n例えば、df_carの1列目(つまりname変数)を表示するには、次のようにします。\n\ndf_car[,1] # 1列目の変数\n\n[1] \"トヨタ\" \"トヨタ\" \"日産\"   \"日産\"   \"ホンダ\" \"ホンダ\"\n\n\n\n\n列のアクセス\n\n同様に、1行目（つまりトヨタの2022年の行）を表示するには、次のようにします。\n\ndf_car[1,] # 1列目の変数\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\n\n\n\n行のアクセス\n\nさらに、df_carの特定の値にアクセスするには、次のようにします。\n\ndf_car[2,3] # 2行目の3列目の値\n\n[1] 37154298\n\n\n\n\n値のアクセス\n\n条件を指定して、特定の行を抽出することもできます。\n\n\n条件の指定\n\nたとえば、name変数がトヨタの行を抽出するには、次のようにします。\n\ndf_car[df_car$name == \"トヨタ\",]\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n\n\n\n\n条件式の書き方には、主に以下のようなものがあります。\n\n\n== : 等しい\n\n!= : 等しくない\n\n&lt; : より小さい\n\n&lt;= : 以下\n\n&gt; : より大きい\n\n&gt;= : 以上\n\n%in% : ベクトルの中に含まれる\n\nたとえば、name変数がトヨタまたは日産の行を抽出するには、次のようにします。\n\ndf_car[df_car$name %in% c(\"トヨタ\", \"日産\"),]\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\n\n\n日産\n\n\n2023\n\n\n10596695",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>データフレーム</span>"
    ]
  },
  {
    "objectID": "chap04_dataframe.html#データフレームの結合",
    "href": "chap04_dataframe.html#データフレームの結合",
    "title": "\n5  データフレーム\n",
    "section": "\n5.4 データフレームの結合",
    "text": "5.4 データフレームの結合\n次に、重要かつよく使うのだけれど、結構ややこしいデータフレームの結合について説明します。\n\n5.4.1 データを縦に結合する\nたとえば、先のdf_carに、各社2024年の売上高のデータdf_car_2024を追加したいとします。 2024年度の(仮想)データが入ったデータフレームを作成します。\n\ndf_car_2024 &lt;- data.frame(\n    name = c(\"トヨタ\", \"日産\", \"ホンダ\"),\n    year = c(rep(2024,3)),\n    sale = c(40000000, 13000000, 20000000)\n)\ndf_car_2024\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2024\n\n\n4.0e+07\n\n\n\n\n日産\n\n\n2024\n\n\n1.3e+07\n\n\n\n\nホンダ\n\n\n2024\n\n\n2.0e+07\n\n\n\n\n\n\n\n\nデータフレームの縦結合\n\nこのように追加されるデータフレームが元のデータフレームの変数が一致している場合、簡単にデータを縦に結合することができます。\n\nlibrary(knitr) # データフレームをキレイに表示\nlibrary(kableExtra) # row_specをつかうため\ndf_car_add &lt;- rbind(df_car, df_car_2024)\ndf_car_add |&gt; kable() |&gt;\n    row_spec(7:9, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725\n\n\nトヨタ\n2024\n40000000\n\n\n日産\n2024\n13000000\n\n\nホンダ\n2024\n20000000\n\n\n\n\n\nデータフレームに下から新たなデータが加わっていることが分かります。\n\n5.4.2 データを横に結合する\nデータを横に結合するには、cbind()を使います。 例えば、売上高saleに加えて、各社の(親会社株主に帰属する)当期純利益niもデータフレームに追加したいとします。 niを変数とするデータフレームを作成します。\n\ndf_car_ni &lt;- data.frame(\n    name = c(rep(\"トヨタ\",3),rep(\"日産\",3),rep(\"ホンダ\",3)),\n    year = rep(c(\"2022\", \"2023\", \"2024\"),3), # 時点\n    ni = c(2850110, 2451318, 3300000,\n           215533, 221900, 230000,\n           707067, 651416, 800000)\n)\ndf_car_ni\n\n\n\n\nname\n\n\nyear\n\n\nni\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n2850110\n\n\n\n\nトヨタ\n\n\n2023\n\n\n2451318\n\n\n\n\nトヨタ\n\n\n2024\n\n\n3300000\n\n\n\n\n日産\n\n\n2022\n\n\n215533\n\n\n\n\n日産\n\n\n2023\n\n\n221900\n\n\n\n\n日産\n\n\n2024\n\n\n230000\n\n\n\n\nホンダ\n\n\n2022\n\n\n707067\n\n\n\n\nホンダ\n\n\n2023\n\n\n651416\n\n\n\n\nホンダ\n\n\n2024\n\n\n800000\n\n\n\n\n\n\nこれをdf_car_addに右から結合します。\n\n\nデータフレームの横結合\n\n\ndf_cbind &lt;- cbind(df_car_add, df_car_ni)\ndf_cbind\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\nname\n\n\nyear\n\n\nni\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\nトヨタ\n\n\n2022\n\n\n2850110\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\nトヨタ\n\n\n2023\n\n\n2451318\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\nトヨタ\n\n\n2024\n\n\n3300000\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n日産\n\n\n2022\n\n\n215533\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n日産\n\n\n2023\n\n\n221900\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n日産\n\n\n2024\n\n\n230000\n\n\n\n\nトヨタ\n\n\n2024\n\n\n40000000\n\n\nホンダ\n\n\n2022\n\n\n707067\n\n\n\n\n日産\n\n\n2024\n\n\n13000000\n\n\nホンダ\n\n\n2023\n\n\n651416\n\n\n\n\nホンダ\n\n\n2024\n\n\n20000000\n\n\nホンダ\n\n\n2024\n\n\n800000\n\n\n\n\n\n\ndf_carの右側にdf_car_niが結合されていることが分かります。 しかし、この結合に問題があることは一目瞭然です。 重複した変数があるうえに、nameやyearの順番がバラバラです。 つまり行が観測値を表しておらず、整然データではなくなりました。\nこの問題を解決するためには、nameとyearの2つの変数をキーとして、データを結合する必要があります。 このような結合をマージと呼びます。以下では、マージの方法を説明します。\n\n5.4.3 JOIN関数を使う\nデータフレームの結合は基本関数でもできますが、tidyverseのdplyrパッケージのJOIN関数が便利です。\n\n5.4.4 JOIN関数\ndplyrパッケージのJOIN関数には、以下の4つがあります。\n\n\ninner_join() : 内部結合\n\nleft_join() : 左外部結合\n\nright_join() : 右外部結合\n\nfull_join() : 完全外部結合\n\nそれぞれの結合の結果をベン図で表すと以下のようになります。\n\n\n結合\n\n結合のイメージ図は以下の通りです(この図は、Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemundによる”R for Data Science”の図を引用しています)。\n\n\n結合結果\n\n内部結合は、2つのデータフレームの共通の変数の値が一致する行のみを抽出するため、結合後のデータフレームが非常に小さくなりがちであるため、ほとんど使用しません。 最も利用する可能性が高いのは、結合元のデータフレームのすべての行を残す左外部結合です。 これはdplyr::left_join()で実行できます。\n\n5.4.4.1 左外部結合\nleft_join()の引数は、以下の通りです。\n\n\nx : 結合元のデータフレーム\n\ny : 結合するデータフレーム\n\nby : 結合する変数\n\ndf_carとdf_car_niをnameとyearの2つの変数をキーとして左外部結合します。 ここで重要なことは，キーとなる変数で観測値がユニークになっている，ということです。 ここの例だと，nameがトヨタ，yearが2023，という観測値(つまり行)は1つだけになっている，ということです。\n\n\n左外部結合\n\ndplyrパッケージのleft_join()関数次のようにします。\n\nlibrary(dplyr) # left_joinを使うためにdplyrパッケージを読み込む\ndf_car_left &lt;- left_join(df_car_add, df_car_ni, by = c(\"name\", \"year\"))\ndf_car_left\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\nni\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n2850110\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n2451318\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\n215533\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n221900\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n707067\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n651416\n\n\n\n\nトヨタ\n\n\n2024\n\n\n40000000\n\n\n3300000\n\n\n\n\n日産\n\n\n2024\n\n\n13000000\n\n\n230000\n\n\n\n\nホンダ\n\n\n2024\n\n\n20000000\n\n\n800000\n\n\n\n\n\n\nこの結果をみると、うえで行ったcbind()関数とは異なり、結合のキーに指定したnameとyearの順番が揃っていることが分かります。\n\n\n左外部結合の結果\n\n\n5.4.5 異なるサイズのデータフレームの結合\ndf_car_addとdf_car_niは、同じサイズのデータフレームでしたが、異なるサイズのデータフレームを結合することもできます。 たとえば、元のdf_carに、マツダの2022年と2023年の売上高を追加してみます。\n\ndf_car_mazda &lt;- data.frame(\n    name = c(\"マツダ\", \"マツダ\"),\n    year = c(2022, 2023),\n    sale = c(3120349, 3826752)\n)\ndf_car_mazda &lt;- rbind(df_car,df_car_mazda)\ndf_car_mazda\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n\n\nマツダ\n\n\n2022\n\n\n3120349\n\n\n\n\nマツダ\n\n\n2023\n\n\n3826752\n\n\n\n\n\n\nこれにdf_car_niを左外部結合するとどうなるか確認してみましょう\n\n\nマツダのデータ\n\n\ndf_car_mazda_left &lt;- left_join(df_car_mazda, df_car_ni, by = c(\"name\", \"year\"))\ndf_car_mazda_left |&gt; kable() |&gt;\n    row_spec(7:8, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\nni\n\n\n\nトヨタ\n2022\n31379507\n2850110\n\n\nトヨタ\n2023\n37154298\n2451318\n\n\n日産\n2022\n8424585\n215533\n\n\n日産\n2023\n10596695\n221900\n\n\nホンダ\n2022\n14552696\n707067\n\n\nホンダ\n2023\n16907725\n651416\n\n\nマツダ\n2022\n3120349\nNA\n\n\nマツダ\n2023\n3826752\nNA\n\n\n\n\n\n結果を見てみると、df_car_niにはマツダのデータがないため、NAが入っていることが分かります。またdf_car_niに入っていた2024年のデータは、df_car_mazdaにはないため、結合後のデータフレームには含まれていません。 基本的に主となるデータフレームのデータを維持したいことがおおいため，左外部結合を使うことが多いです。\n\n5.4.6 観測値がユニークでない場合\n結合するデータフレームのキーとなる変数で観測値がユニークでない場合は，結合後のデータフレームの行数が増えてしまいます。\n\ndf_car_duplicate &lt;- data.frame( # データフレームを作成\n    name = c(rep(\"トヨタ\",2),rep(\"日産\",2),rep(\"ホンダ\",3)),\n    year = c(rep(c(\"2022\", \"2023\"),3), 2023), # 時点\n    sale = c(31379507,37154298,8424585,10596695,14552696,16907725,18706224) # 気温\n)\ndf_car_duplicate\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n\n\nホンダ\n\n\n2023\n\n\n18706224\n\n\n\n\n\n\nこのデータフレームには，ホンダの2023年のデータが2つあります。 たとえば，IFRS採用直後だと日本基準とIFRSのデータが記載されていることがあり，このように企業名と年度だけでは観測値がユニークにならないことがあります。\nこのデータフレームにdf_car_niを左外部結合するとどうなるか確認してみましょう\n\ndf_car_duplicate_left &lt;- left_join(df_car_duplicate, df_car_ni, by = c(\"name\", \"year\"))\ndf_car_duplicate_left |&gt; kable() |&gt;\n    row_spec(6:7, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\nni\n\n\n\nトヨタ\n2022\n31379507\n2850110\n\n\nトヨタ\n2023\n37154298\n2451318\n\n\n日産\n2022\n8424585\n215533\n\n\n日産\n2023\n10596695\n221900\n\n\nホンダ\n2022\n14552696\n707067\n\n\nホンダ\n2023\n16907725\n651416\n\n\nホンダ\n2023\n18706224\n651416\n\n\n\n\n\n結合元のデータフレームが結合するキーにでユニークになっていないので，エラーになるかと思いきや，エラーにならずに結合され，ホンダの2023年の2つの観測値に同じ当期純利益の数値が入っています。\n逆のケースもやってみましょう。 結合元のデータフレームはユニークだが，結合するデータフレームがユニークではない場合です。 先ほどの例とは逆に，df_car_niにdf_car_duplicateを左外部結合するとどうなるか確認してみましょう\n\n# 左外部結合\ndf_car_ni_duplicate_left &lt;- left_join(df_car_ni, df_car_duplicate, by = c(\"name\", \"year\"))\n# 結合後のデータフレーム\ndf_car_ni_duplicate_left |&gt;\n    kable() |&gt;\n    row_spec(c(3,6,10), bold = TRUE, background = 'lightcyan') |&gt;\n    row_spec(8:9, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nni\nsale\n\n\n\nトヨタ\n2022\n2850110\n31379507\n\n\nトヨタ\n2023\n2451318\n37154298\n\n\nトヨタ\n2024\n3300000\nNA\n\n\n日産\n2022\n215533\n8424585\n\n\n日産\n2023\n221900\n10596695\n\n\n日産\n2024\n230000\nNA\n\n\nホンダ\n2022\n707067\n14552696\n\n\nホンダ\n2023\n651416\n16907725\n\n\nホンダ\n2023\n651416\n18706224\n\n\nホンダ\n2024\n800000\nNA\n\n\n\n\n\n結合元のdf_car_niは2024年のデータがありますが，結合するdf_car_duplicateには2024年のデータがないため，左外部結合したデータフレームの2024年のsaleは欠損値NAになっています(青色の行)。\nまた注目すべきは，結合元のホンダの2023年のniは1つだけだったのにたいして，結合後には2つになっており，そこにsaleが左から結合されています(オレンジの行)。\nこのように，結合するデータフレームのキーとなる変数で観測値がユニークでない場合は，dplyr::left_join()関数は，自動的にデータを補完して結合してしまうため，それを理解して使う必要があります。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>データフレーム</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#変数の種類と記述統計",
    "href": "chap11_visualization.html#変数の種類と記述統計",
    "title": "\n11  データの可視化・視覚化\n",
    "section": "\n11.1 変数の種類と記述統計",
    "text": "11.1 変数の種類と記述統計\nデータには「カテゴリ変数」(category variable)と「量的変数」(quantitative variable)あるいは「連続変数」(continuous variable)があり，それぞれに対して適切なグラフの種類があります。\n\n11.1.1 カテゴリー変数と量的変数\nカテゴリー変数(category variable)とは、観測値が属するカテゴリーを表す変数です。 たとえば、日経産業中分類の「水産」は35、鉱業は37，建設は41ですが、これらの数値は足したり引いたりすることに意味はありません。\n量的変数(quantitative variable)とは、観測値が数値で表される変数です。 たとえば、売上高や株価は金額で表されるため、足したり引いたり、平均や分散を計算することに意味があります。\nしたがって、手元にあるデータベースの各変数がカテゴリー変数か量的変数かを把握することは極めて重要です。 Rでは自動で両者を区別したりはしてくれないので、データを読み込んだ後に変数の種類を確認し、自分で指定します。\n練習用データの読み込み\nここでは、教科書とは違う、企業の財務データを使いながら、データの可視化を学びます。 財務データが収録されたcsvファイルを，tidyverseのread_csv()関数を使って読み込みます。 read_csv()関数の引数として，ファイルの場所とファイル名を直接パスあるいは相対パスを指定します。\n\ndf &lt;- read_csv(\"data/RD_2022.csv\")\n\nRows: 57823 Columns: 23\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): 会社コード, 企業名, 決算期\ndbl (20): 決算種別, 連結基準, 決算月数, 上場コード, 日経業種コード, 現金預金, 資産合計, 資本金, 資本剰余金, 利益剰余金, 自...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nglimpse(df) # データの概要\n\nRows: 57,823\nColumns: 23\n$ 会社コード                     &lt;chr&gt; \"0000001\", \"0000001\", \"0000001\", \"00000…\n$ 企業名                         &lt;chr&gt; \"極洋\", \"極洋\", \"極洋\", \"極洋\", \"極洋\",…\n$ 決算期                         &lt;chr&gt; \"1999/03\", \"2000/03\", \"2001/03\", \"2002/…\n$ 決算種別                       &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,…\n$ 連結基準                       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ 決算月数                       &lt;dbl&gt; 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,…\n$ 上場コード                     &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,…\n$ 日経業種コード                 &lt;dbl&gt; 235341, 235341, 235341, 235341, 235341,…\n$ 現金預金                       &lt;dbl&gt; 6307, 4951, 3818, 4185, 4015, 3456, 277…\n$ 資産合計                       &lt;dbl&gt; 62109, 60885, 60599, 57069, 55373, 5856…\n$ 資本金                         &lt;dbl&gt; 5664, 5664, 5664, 5664, 5664, 5664, 566…\n$ 資本剰余金                     &lt;dbl&gt; NA, NA, NA, NA, 742, 742, 742, 743, 749…\n$ 利益剰余金                     &lt;dbl&gt; 2739, 4238, 4812, 5485, 6254, 6378, 727…\n$ 自己株式                       &lt;dbl&gt; NA, NA, -79, -154, -387, -464, -368, -2…\n$ 売上高                         &lt;dbl&gt; 171944, 171031, 166644, 158006, 162773,…\n$ 経常利益                       &lt;dbl&gt; 1600, 2299, 1947, 2333, 3314, 2895, 335…\n$ 法人税等                       &lt;dbl&gt; 620, 606, 908, 856, 1234, 1302, 1422, 1…\n$ 法人税等調整額                 &lt;dbl&gt; NA, -178, -114, 44, -272, -234, 136, -3…\n$ 親会社株主に帰属する当期純利益 &lt;dbl&gt; -251, 327, 927, 1026, 1122, 1248, 1388,…\n$ 研究開発費IFRS                 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ 研究開発費                     &lt;dbl&gt; 210, 201, 190, 179, 197, 212, 201, 193,…\n$ `開発費・試験研究費`           &lt;dbl&gt; 210, 105, 119, 153, 176, 156, 122, 148,…\n$ 現金及び現金同等物の期末残高   &lt;dbl&gt; NA, 4865, 3729, 4097, 3923, 3359, 2725,…\n\n\n23個の変数があり、データの個数は57,823となっています。 以下ではこのデータを使って、データの可視化を学びます。\n\n11.1.2 基本的な統計量の確認\nはじめにsummary()で基本的な統計量を確認します。\n\nsummary(df)\n\n  会社コード           企業名             決算期             決算種別 \n Length:57823       Length:57823       Length:57823       Min.   :10  \n Class :character   Class :character   Class :character   1st Qu.:10  \n Mode  :character   Mode  :character   Mode  :character   Median :10  \n                                                          Mean   :10  \n                                                          3rd Qu.:10  \n                                                          Max.   :10  \n                                                                      \n    連結基準        決算月数       上場コード    日経業種コード  \n Min.   :1.000   Min.   : 1.00   Min.   :11.00   Min.   :101001  \n 1st Qu.:1.000   1st Qu.:12.00   1st Qu.:11.00   1st Qu.:121204  \n Median :1.000   Median :12.00   Median :11.00   Median :241403  \n Mean   :1.062   Mean   :11.98   Mean   :11.46   Mean   :190751  \n 3rd Qu.:1.000   3rd Qu.:12.00   3rd Qu.:12.00   3rd Qu.:257561  \n Max.   :3.000   Max.   :17.00   Max.   :13.00   Max.   :271704  \n                                                                 \n    現金預金           資産合計             資本金          資本剰余金     \n Min.   :       4   Min.   :       70   Min.   :      1   Min.   :-161917  \n 1st Qu.:    2023   1st Qu.:    14062   1st Qu.:   1198   1st Qu.:    965  \n Median :    5370   Median :    39028   Median :   3363   Median :   2995  \n Mean   :   38172   Mean   :   363536   Mean   :  16481   Mean   :  20259  \n 3rd Qu.:   16467   3rd Qu.:   125705   3rd Qu.:  10090   3rd Qu.:   9927  \n Max.   :68502665   Max.   :303846980   Max.   :3500000   Max.   :4503856  \n NA's   :193        NA's   :44          NA's   :198       NA's   :7714     \n   利益剰余金          自己株式            売上高            経常利益      \n Min.   : -972773   Min.   :-3306037   Min.   :       1   Min.   :-869562  \n 1st Qu.:    2250   1st Qu.:   -1368   1st Qu.:   13366   1st Qu.:    425  \n Median :    9163   Median :    -279   Median :   38209   Median :   1626  \n Mean   :   75680   Mean   :   -5144   Mean   :  237440   Mean   :  14070  \n 3rd Qu.:   34436   3rd Qu.:     -39   3rd Qu.:  127091   3rd Qu.:   6126  \n Max.   :26453126   Max.   :      -1   Max.   :31379507   Max.   :5670456  \n NA's   :299        NA's   :10800      NA's   :27         NA's   :21       \n    法人税等       法人税等調整額       親会社株主に帰属する当期純利益\n Min.   : -21709   Min.   :-1139009.0   Min.   :-1708029              \n 1st Qu.:    159   1st Qu.:    -134.5   1st Qu.:     163              \n Median :    586   Median :      -7.0   Median :     823              \n Mean   :   4827   Mean   :    -114.7   Mean   :    7707              \n 3rd Qu.:   2170   3rd Qu.:      91.0   3rd Qu.:    3372              \n Max.   :1190782   Max.   : 1097414.0   Max.   : 4987962              \n NA's   :391       NA's   :3736         NA's   :29                    \n 研究開発費IFRS     研究開発費      開発費・試験研究費\n Min.   :    48   Min.   :      1   Min.   :     1    \n 1st Qu.:  2440   1st Qu.:    131   1st Qu.:   169    \n Median : 24628   Median :    547   Median :   651    \n Mean   : 91248   Mean   :   8441   Mean   :  7528    \n 3rd Qu.:108096   3rd Qu.:   2330   3rd Qu.:  2710    \n Max.   :806905   Max.   :1124262   Max.   :662610    \n NA's   :57583    NA's   :21525     NA's   :38296     \n 現金及び現金同等物の期末残高\n Min.   :    -292            \n 1st Qu.:    1913            \n Median :    5328            \n Mean   :   39185            \n 3rd Qu.:   16954            \n Max.   :68419223            \n NA's   :1591                \n\n\n文字列となっている変数以外の量的変数については、最小値、第1四分位、中央値、平均値、第3四分位、最大値、欠損値の数、といった項目が計算されています。 数値データのうち、カテゴリー変数の統計量については意味が無いです。\n23個の変数の型を確認すると、大部分の財務データは数値&lt;dbl&gt;ですが、\n\n会社コード\n企業名\n決算期\n\nの3つは文字列&lt;chr&gt;となっています。 また、数値となっているけれど、実際はカテゴリー変数であるものとして、\n\n決算種別 : 10 = 本決算\n\n連結基準 : 1 = 日本基準, 2 = 米国基準, 3 = IFRS, 0 = 単独\n\n上場コード : 11 = 東証1部, 12 = 東証2部, 13 = 東証マザーズ,\n日経業種コード : 後で説明あり\n\nがあります。 文字列となっている変数以外の量的変数については、最小値、第1四分位、中央値、平均値、第3四分位、最大値、欠損値の数、といった項目が計算されています。 数値データとなっているカテゴリー変数である決算種別，連結基準，上場コード，日経業種コードの統計量も計算されていますが，もちろん意味は無いので，Rにカテゴリー変数であることを明示するためにファクター型に変換する必要があります。\nとりあえず、数値データのうち、カテゴリー変数ではないものについて、統計量を計算してみます。 主要な統計量を返す関数には以下のものがあります。\n\n\nmean() : 算術平均を計算する\n\nmedian() : 中央値を計算する\n\nsd() : (不偏)標準偏差を計算する\n\nvar() : (不偏)分散を計算する\n\nmin() : 最小値を計算する\n\nmax() : 最大値を計算する\n\nでは、売上高の平均を計算してみましょう。 データフレームdfの売上高にアクセスするには、df$売上高のように、$を使って変数名を指定します。 Excelでいうと，dfがシート名，売上高が列名に相当します。\n\nmean(df$売上高)\n\n[1] NA\n\n\nNAが帰ってきましたね。 実は、このmean()関数は、引数となるベクトル変数の中に欠損値NAがあると、NAを返します。 欠損値を意味するNAは，その観測値が存在しないことを表します。 このような場合、NAを除外して平均を計算する必要があるので、na.rm = TRUEという引数を追加します。\n\nmean(df$売上高, na.rm = TRUE)\n\n[1] 237440.1\n\n\nこれで、売上高の平均が2.3744011^{5}となりました。\n同じように、\n\nmedian(df$売上高, na.rm = TRUE) # 中央値\n\n[1] 38209\n\nsd(df$売上高, na.rm = TRUE) # 標準偏差\n\n[1] 938244.4\n\n\nとすることで、中央値と標準偏差が求められます。\n\n11.1.3 カテゴリ変数の内容確認\nカテゴリー変数について見ていきましょう。 ここでは日経業種コードを例にとります。 日経業種コードは6ケタの数字ですが、最初の1ケタが大分類、次の2ケタ目が中分類、最後の3ケタ目が小分類を表します。つまり1 + 32 + 344のような構造になっています。 実証会計研究では、産業中分類をよく使うので、ここでは中分類を抽出してみましょう。 またしてもsubstr()関数を使って、2〜3ケタ目を抽出し、中分類という変数に格納します。 ついでに，決算期のデータがYYYY/MMという形式になっているので，最初の4桁を抽出して，年度という変数に格納します。\n\ndf &lt;- df %&gt;%\n  mutate(\n    中分類 = substr(日経業種コード, 2, 3), #2〜3ケタ目を抽出\n    年度 = substr(決算期, 1, 4) # 最初の4桁を抽出\n    )\n\nこの中分類の内容を確認するには、table()関数を使います。\n\ntable(df$中分類) # 中分類の表\n\n\n   01    03    05    07    09    11    13    15    17    19    21    23    25 \n 2215   934   432  3915   947   178   459  1066   906  2174  4338  5016    96 \n   27    29    31    33    35    37    41    43    45    52    53    55    57 \n 1651   253  1035  1936   203   131  2715  5926  3501   832  1674   670   640 \n   59    61    63    65    67    69    71 \n  261    96   746   625   285   214 11753 \n\n\nこのように、中分類ごとの企業数が計算されました。 このカテゴリー変数の型をclass()関数で確認します。\n\nclass(df$中分類) # 中分類の型\n\n[1] \"character\"\n\n\ncharacterつまり文字列となっています。これをファクター型に変えて、カテゴリー変数であることを明示します。as.factor()関数を使うと、ファクター型に変換できますが，産業コードだけだとどの産業なのか分かりづらいままです。 そこで、factor()関数を使って、カテゴリー変数の内容を指定します。 ついでに，上場コードや連結基準もファクター型に変換しておきます。\nまずどんな中分類があるのかを確認します。 ある変数にどんなカテゴリーがあるのかを確認するには、unique()関数を使います。\n\nchu_level &lt;- sort(unique(df$中分類)) # 中分類のカテゴリーを抽出\n\nこの中分類コードに対応する産業名称を指定するには，factor()関数の引数として，levels =とlabels =を指定します。 以下では，mutate()と組み合わせて，中分類をファクター型に変換します。\n産業名称をベクトルとして収納しておきます。\n\nchu_name &lt;- c(\n  \"食品\",\"繊維\",\"パルプ・紙\",\"化学工業\",\"医薬品\",\"石油\",\"ゴム\",\"窯業\",\"鉄鉱業\",\"非金属及び金属製品\",\"機械\",\"電気機器\",\"造船\",\"自動車・自動車部品\",\"その他輸送用機器\",\"精密機器\",\"その他製造業\",\"水産\",\"鉱業\",\"建設\",\"商社\",\"小売業\",\"その他金融業\",\"不動産\",\"鉄道・バス\",\"陸運\",\"海運\",\"空輸\",\"倉庫・運輸関連\",\"通信\",\"電力\",\"ガス\",\"サービス業\")\n\n\ndf &lt;- df %&gt;%\n  arrange(中分類) %&gt;%\n  mutate(\n    中分類 = factor( # 中分類をファクター型に変換\n      中分類,\n      levels = chu_level, # カテゴリーの種類\n      labels = chu_name), # カテゴリーの名称\n    上場コード = factor(\n      上場コード,\n      levels = c(11,12,13), # カテゴリーの種類\n      labels = c(\"1部\",\"2部\",\"マザーズ\")), # カテゴリーの名称\n    連結基準 = factor(\n      連結基準,\n      levels = c(1,2,3,0),\n      labels = c(\"日本基準\",\"米国基準\",\"IFRS\",\"単独\"))\n      )\n\nカテゴリー変数がファクター型に変換されたので，再度summary()関数を使って，概要統計量を確認してみましょう。\n\nsummary(df)\n\n  会社コード           企業名             決算期             決算種別 \n Length:57823       Length:57823       Length:57823       Min.   :10  \n Class :character   Class :character   Class :character   1st Qu.:10  \n Mode  :character   Mode  :character   Mode  :character   Median :10  \n                                                          Mean   :10  \n                                                          3rd Qu.:10  \n                                                          Max.   :10  \n                                                                      \n     連結基準        決算月数        上場コード    日経業種コード  \n 日本基準:55727   Min.   : 1.00   1部     :33171   Min.   :101001  \n 米国基準:  581   1st Qu.:12.00   2部     :22529   1st Qu.:121204  \n IFRS    : 1515   Median :12.00   マザーズ: 2123   Median :241403  \n 単独    :    0   Mean   :11.98                    Mean   :190751  \n                  3rd Qu.:12.00                    3rd Qu.:257561  \n                  Max.   :17.00                    Max.   :271704  \n                                                                   \n    現金預金           資産合計             資本金          資本剰余金     \n Min.   :       4   Min.   :       70   Min.   :      1   Min.   :-161917  \n 1st Qu.:    2023   1st Qu.:    14062   1st Qu.:   1198   1st Qu.:    965  \n Median :    5370   Median :    39028   Median :   3363   Median :   2995  \n Mean   :   38172   Mean   :   363536   Mean   :  16481   Mean   :  20259  \n 3rd Qu.:   16467   3rd Qu.:   125705   3rd Qu.:  10090   3rd Qu.:   9927  \n Max.   :68502665   Max.   :303846980   Max.   :3500000   Max.   :4503856  \n NA's   :193        NA's   :44          NA's   :198       NA's   :7714     \n   利益剰余金          自己株式            売上高            経常利益      \n Min.   : -972773   Min.   :-3306037   Min.   :       1   Min.   :-869562  \n 1st Qu.:    2250   1st Qu.:   -1368   1st Qu.:   13366   1st Qu.:    425  \n Median :    9163   Median :    -279   Median :   38209   Median :   1626  \n Mean   :   75680   Mean   :   -5144   Mean   :  237440   Mean   :  14070  \n 3rd Qu.:   34436   3rd Qu.:     -39   3rd Qu.:  127091   3rd Qu.:   6126  \n Max.   :26453126   Max.   :      -1   Max.   :31379507   Max.   :5670456  \n NA's   :299        NA's   :10800      NA's   :27         NA's   :21       \n    法人税等       法人税等調整額       親会社株主に帰属する当期純利益\n Min.   : -21709   Min.   :-1139009.0   Min.   :-1708029              \n 1st Qu.:    159   1st Qu.:    -134.5   1st Qu.:     163              \n Median :    586   Median :      -7.0   Median :     823              \n Mean   :   4827   Mean   :    -114.7   Mean   :    7707              \n 3rd Qu.:   2170   3rd Qu.:      91.0   3rd Qu.:    3372              \n Max.   :1190782   Max.   : 1097414.0   Max.   : 4987962              \n NA's   :391       NA's   :3736         NA's   :29                    \n 研究開発費IFRS     研究開発費      開発費・試験研究費\n Min.   :    48   Min.   :      1   Min.   :     1    \n 1st Qu.:  2440   1st Qu.:    131   1st Qu.:   169    \n Median : 24628   Median :    547   Median :   651    \n Mean   : 91248   Mean   :   8441   Mean   :  7528    \n 3rd Qu.:108096   3rd Qu.:   2330   3rd Qu.:  2710    \n Max.   :806905   Max.   :1124262   Max.   :662610    \n NA's   :57583    NA's   :21525     NA's   :38296     \n 現金及び現金同等物の期末残高        中分類          年度          \n Min.   :    -292             サービス業:11753   Length:57823      \n 1st Qu.:    1913             商社      : 5926   Class :character  \n Median :    5328             電気機器  : 5016   Mode  :character  \n Mean   :   39185             機械      : 4338                     \n 3rd Qu.:   16954             化学工業  : 3915                     \n Max.   :68419223             小売業    : 3501                     \n NA's   :1591                 (Other)   :23374                     \n\n\nカテゴリー変数はカテゴリーの種類と個数が表示されています。\n\n11.1.4 2つのカテゴリー変数の関係を確かめる\n2つの変数から表を作成する方法について学びます。 典型的な表として，2変数のクロス集計表があります。 例えば，連結基準，つまり企業が採用している会計基準の種類と，上場コード，つまり企業が上場している市場の種類，の2変数について，それぞれのカテゴリーごとの企業数を計算することができます。\n\ntable(df$連結基準, df$上場コード)\n\n          \n             1部   2部 マザーズ\n  日本基準 31290 22432     2005\n  米国基準   580     0        1\n  IFRS      1301    97      117\n  単独         0     0        0\n\n\n圧倒的に，日本基準で上場している企業が多いことがわかります。 2020年度のデータだけを抽出して，同じようにクロス集計表を作成してみましょう。\n\ndf %&gt;%\n  filter(年度 == 2020) %&gt;%\n  with(table(連結基準, 上場コード))\n\n          上場コード\n連結基準  1部  2部 マザーズ\n  日本基準 1474 1177      259\n  米国基準   11    0        0\n  IFRS      194   15       22\n  単独        0    0        0\n\n\n東証1部に上場している企業に注目すると，日本基準採用企業が1474社，米国基準採用企業が11社，IFRS採用企業が194社となっていることがわかりました。\nこのように，table()関数の引数として2つのカテゴリー変数を指定すると，そこから2 \\times 2のグループに属する企業数を計算し，表を作成してくれます。\nここで急に登場したwith()関数ですが，with()関数は主として次の2つの引数をとります。\n\nデータ\n式\n\n例えば，先の表を作る場合を考えてみましょう。 普通に書くと\n\ntable(df$連結基準, df$上場コード)\n\nとかきましたが，何度もdf$を書くことが面倒なので，with()関数を使って\n\nwith(df, table(連結基準, 上場コード))\n\nと，第1引数にdfを指定すれば，第2引数の式の中でdf$を書く必要がなくなります。したがって，パイプ演算子を使って，\n\ndf %&gt;% with(table(連結基準, 上場コード))\n\nと処理をつなげることができます。 便利ですね。\n\n11.1.5 カテゴリー別に量的変数の値を調べる\n次は，量的変数をカテゴリーごとに分析したいときがあります。 たとえば，産業別や年度別に売上高の平均値を知りたい，ということが何度もあります。 任意のグループごとに処理を繰り返したいときは，dplyrパッケージのgroup_by()関数を使います。 group_by()関数は，第1引数にグループ化したい変数を指定します。\nそしてgroup_by()関数と同時に使うことで，グループごとの統計量を計算するために便利なのがdplyrパッケージのsummarize()関数です。 summarize()関数は，次のような引数をとり，各種統計量を計算してくれます。\n\n\nmean = : 平均\n\nmedian = : 中央値\n\nsd = : 標準偏差\n\nvar = : 分散\n\nn() : グループごとの観測値の個数\n\n例えば，上場場所ごとに売上高の平均値を計算するには，次のようにします。\n\ndf %&gt;%\n  group_by(上場コード) %&gt;% # 上場場ごとに\n  summarize(\n    企業数 = n(), #\n    平均売上高 = mean(売上高, na.rm = TRUE) # 平均\n    ) %&gt;%\n  ungroup() %&gt;% # グループ化解除\n  knitr::kable(booktabs = TRUE) # 表を作成\n\n\n\n上場コード\n企業数\n平均売上高\n\n\n\n1部\n33171\n393156.220\n\n\n2部\n22529\n29884.533\n\n\nマザーズ\n2123\n5459.012\n\n\n\n\n\n結果を見れば分かるとおり，group_by()で上場場所ごとにグループ化し，summarize()で企業数と平均売上高を計算しているので，上場場所，企業数，平均売上高の3変数が3つの観測値をもつ3 \\times 3の表が作成されています。 group_by()とsummarize()を組み合わせると，結果としてグループ数に応じた統計量を計算した結果となり，元のデータよりも小さなデータフレームとなって返ってきます。\nついでに，産業別の売上高合計，利益平均値，利益中央値，利益の標準偏差を計算してみましょう。\n\ndf %&gt;%\n  group_by(中分類) %&gt;% # 産業中分類ごとに\n  summarize(\n    企業数 = n(), # n()で要素数\n    売上合計 = sum(売上高, na.rm = TRUE), # 合計\n    利益平均値 = mean(親会社株主に帰属する当期純利益, na.rm = TRUE), # 平均\n    利益中央値 = median(親会社株主に帰属する当期純利益, na.rm = TRUE), # 中央値\n    利益標準偏差 = sd(親会社株主に帰属する当期純利益, na.rm = TRUE) # 標準偏差\n    ) %&gt;%\n  arrange(desc(売上合計)) %&gt;% # 売上合計で降順に並び替え\n  ungroup() %&gt;% # グループ化解除\n  knitr::kable(booktabs = TRUE) # 表を作成\n\n\n\n\n\n\n\n\n\n\n\n中分類\n企業数\n売上合計\n利益平均値\n利益中央値\n利益標準偏差\n\n\n\n電気機器\n5016\n1941560030\n10167.927\n1084.0\n62674.007\n\n\n商社\n5926\n1909721701\n6754.815\n738.0\n43249.527\n\n\n自動車・自動車部品\n1651\n1688864541\n39250.629\n1851.0\n210604.044\n\n\n小売業\n3501\n793035711\n4590.688\n880.0\n14968.112\n\n\n化学工業\n3915\n736860746\n7564.608\n1445.0\n23530.649\n\n\nサービス業\n11753\n694250494\n2578.502\n361.0\n17729.118\n\n\n通信\n625\n647052927\n67415.843\n3040.0\n284105.640\n\n\n機械\n4338\n616584704\n5310.454\n1007.0\n20211.162\n\n\n建設\n2715\n597371111\n4868.903\n1073.5\n22122.402\n\n\n食品\n2215\n553185961\n8370.878\n1211.0\n32427.752\n\n\n電力\n285\n435223159\n24108.284\n21988.0\n127809.199\n\n\n非金属及び金属製品\n2174\n333425028\n3537.316\n704.0\n15694.021\n\n\n鉄道・バス\n670\n309477897\n16710.421\n3660.0\n61053.123\n\n\n鉄鉱業\n906\n306858163\n8887.185\n903.0\n47067.285\n\n\n石油\n178\n247483911\n14830.657\n1510.5\n81496.356\n\n\n医薬品\n947\n199368660\n20915.376\n4157.0\n48451.048\n\n\nその他製造業\n1936\n189462230\n2630.949\n595.0\n8999.953\n\n\n不動産\n1674\n181588397\n5826.409\n1192.0\n20315.917\n\n\n窯業\n1066\n145506672\n4485.089\n909.5\n13623.277\n\n\nその他金融業\n832\n142861287\n9388.689\n1657.5\n47428.745\n\n\nゴム\n459\n133429682\n12362.357\n1381.0\n43652.986\n\n\n精密機器\n1035\n132220025\n6338.030\n1015.0\n17597.021\n\n\n陸運\n640\n118243116\n4662.080\n1285.5\n9675.867\n\n\n繊維\n934\n115700455\n2405.079\n542.0\n10837.288\n\n\n海運\n261\n104869365\n15152.031\n1012.0\n93497.186\n\n\nパルプ・紙\n432\n100989604\n3345.630\n693.5\n9869.195\n\n\nガス\n214\n89266508\n16210.327\n3620.0\n26366.794\n\n\n空輸\n96\n70396355\n13813.062\n1053.0\n105853.201\n\n\n造船\n96\n50404788\n4001.927\n968.5\n18613.163\n\n\n倉庫・運輸関連\n746\n48088368\n1876.247\n622.0\n3991.522\n\n\n水産\n203\n35003357\n2327.473\n1122.0\n4202.917\n\n\nその他輸送用機器\n253\n27993041\n4227.802\n1102.0\n12600.550\n\n\n鉱業\n131\n26740727\n15827.588\n2096.0\n46860.380\n\n\n\n\n\n次のグラフ作成のためのデータを作成するため，年度別ごとに，ROEの平均値を計算し，その結果をdf_yearという変数に代入します。 ROEは，ある年度の親会社に帰属する当期純利益を期首株主資本で割った値です。 株主資本は，資本金と資本剰余金，利益剰余金，自己株式の合計で計算しますが，欠損値になっている会社もあるので，replace_na()関数を使って欠損値にはゼロを代入します。\n\ndf &lt;- df %&gt;%\n  replace_na(list(資本剰余金 = 0, 利益剰余金 = 0, 自己株式 = 0)) %&gt;% # 欠損値をゼロに置き換え\n  group_by(企業名) %&gt;% # 会社ごとに\n  mutate( # 新変数作成\n    株主資本 = 資本金 + 資本剰余金 + 利益剰余金 + 自己株式, # 株主資本を計算\n    ) %&gt;%\n    filter(株主資本 &gt;0 ) %&gt;% # 株主資本がマイナスの企業を除外\n  mutate(\n    ROE = 親会社株主に帰属する当期純利益 / lag(株主資本) # ROEを計算\n    ) %&gt;%\n  ungroup() # グループ化解除\n\ndf_year &lt;- df %&gt;%\n  group_by(年度) %&gt;% # 年ごとに\n  summarize( # 統計量を計算\n    平均ROE = mean(ROE, na.rm = TRUE)\n    ) %&gt;%\n  ungroup() # グループ化解除\n\nこれで，年度ごと，上場場所ごとに，平均ROEを計算したデータフレームdf_yearができました。\nここで注意しなければならない点として，group_by(企業名)とした上で，lag()関数を使っている点です。 lag()関数は，引数として指定した変数の値の1つ前の値に変換します。 したがって，group_by()を使わないと次のような結果になります。\n\n\n\n\n\n\n\n\n\n\n\n企業名\n年度\n親会社株主に帰属する当期純利益\n株主資本\nROE\n\n\n\nニップン\n2020\n8941\n129587\n0.0723101\n\n\nニップン\n2021\n8636\n135597\n0.0666425\n\n\nニップン\n2022\n9327\n142166\n0.0687847\n\n\n日清製粉グループ本社\n1999\n7327\n156543\n0.0515383\n\n\n日清製粉グループ本社\n2000\n10822\n175112\n0.0691312\n\n\n日清製粉グループ本社\n2001\n11136\n177671\n0.0635936\n\n\n\n\n\nここで問題になっているのが，日清製粉グループ本社の1999年のROEが計算されている点である。 ROEは分子に親会社株主に帰属する当期純利益，分母に期首株主資本，つまりは前期末の株主資本を使います。 したがって，1999年のROEを計算するためには，1998年の株主資本を使う必要がありますが，データは1999年からしか存在しないので欠損値にならないといけないのに，計算されてしまっています。 つまり，一つ上のニップンの2022年の株主資本のデータを使っているのです。 そこで，group_by()により企業ごとにグループ化して，lag()関数を使って，一つ前の観測値を使うようにし，1999年のROEは欠損値になるようにします。\n\n\n\n\n企業名\n年度\n株主資本\nROE\n\n\n\nニップン\n2020\n129587\n0.0723101\n\n\nニップン\n2021\n135597\n0.0666425\n\n\nニップン\n2022\n142166\n0.0687847\n\n\n日清製粉グループ本社\n1999\n156543\nNA\n\n\n日清製粉グループ本社\n2000\n175112\n0.0691312\n\n\n日清製粉グループ本社\n2001\n177671\n0.0635936",
    "crumbs": [
      "第2部 データハンドリング",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データの可視化・視覚化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#変数の可視化視覚化",
    "href": "chap11_visualization.html#変数の可視化視覚化",
    "title": "\n11  データの可視化・視覚化\n",
    "section": "\n11.2 変数の可視化・視覚化",
    "text": "11.2 変数の可視化・視覚化\nカテゴリー変数のファクター化，with()関数とtable()関数を使ったクロス集計表の作成，group_by()関数とsummarize()関数を使ったグループごとの統計量の計算について学んだので，これらの結果を使ってグラフを作ることで，読者に伝わるデータの可視化を行いたいと思います。 キレイなグラフを比較的簡単に作ることができるggplot2パッケージを使います。\n\n11.2.1 ggplot()関数の基本的な使い方と変数の特徴把握\nggplot2パッケージのggplot()関数は，次のような引数をとります。\n\n\ndata = : データフレーム\n\nmapping = aes() : グラフの構成要素を指定する関数\n\ngeom_*** : グラフの種類を指定する関数\n各種オプション\n\n最初の注意点として，ggplot()関数は，第1引数data =でtibbleかdata.frameを指定する必要があります。 データの型に気をつけましょう。\nでは，年度ごとに平均ROEを示した折れ線グラフを作図していきます。 まず土台となるデータフレームを指定します。\n\nggplot(data = df_year)\n\n\n\n\n\n\n\n土台ができましたが，まだ何も表示されていません。 次に，グラフの構成要素を指定するために，mapping = aes()で，軸を指定します。 今回は，横軸に年度，縦軸に平均ROEを指定します。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE))\n\n\n\n\n\n\n\n縦軸と横軸が表示されました。 軸のラベルが文字化けしているので，最初に作成しておいたスタイルmystyleを適用します。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE)) + mystyle\n\n\n\n\n\n\n\n次に，グラフを作成するために，geom_line()関数を使います。 ggplot関数では，次のようなgeom_***()関数を使って，グラフの種類を指定します。\n\n\ngeom_point() : 散布図\n\ngeom_line() : 折れ線グラフ\n\ngeom_bar() : 棒グラフ\n\ngeom_boxplot() : 箱ひげ図\n\ngeom_histogram() : ヒストグラム\n\ngeom_density() : カーネル密度推定図\n\ngeom_violin() : バイオリンプロット\n\ngeom_smooth() : 平滑化曲線\n\nここでは横軸が年度という文字列，縦軸が平均ROEという量的変数となるグラフを作るので，geom_bar()を使います。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE)) +\n  geom_bar(stat = \"identity\") + mystyle\n\nWarning: Removed 1 rows containing missing values (`position_stack()`).\n\n\n\n\n\n\n\n\n横軸が順序に意味のある変数であれば，geom_line()で折れ線グラフを作るほうが良いでしょう。 この場合，年度は文字列ですが，本来は順序に意味のあるカテゴリー変数ですので，factor()関数を使って，ファクター型に変換します。\n\ndf_year &lt;- df_year %&gt;%\n  mutate(年度f = factor(年度,\n  levels = c(1999:2022),\n  ordered = TRUE))\n\n横軸が順序付きのファクターの年度fとなったので，geom_line()を使って折れ線グラフを作成します。 ここで，オプションとして，group = 1を指定して，データ全体が1つのグループであることを明示します。 横軸がファクター型であるときは，group = 1をつける，というおまじないを覚えておきましょう。\n\nggplot(data = df_year, mapping = aes(x = 年度f, y = 平均ROE, group = 1)) +\n  geom_line() + geom_point() + xlab(\"年度\") + ylab(\"平均ROE\") + mystyle\n\nWarning: Removed 1 row containing missing values (`geom_line()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n上のコードは，必要な引数を省略せずに書きましたが，省略できるものを省略しつつ， すべての要素を+でつなぐよりも，レイヤーごとに代入していくほうが，コードが読みやすくなります。\n\ng &lt;- ggplot(df_year) + aes(年度f, 平均ROE, group = 1) # 基本要素\ng &lt;- g + geom_line() + geom_point() # 折れ線グラフと散布図\ng &lt;- g + xlab(\"年度\") + ylab(\"平均ROE\") + mystyle # 見た目の調整\nprint(g)\n\nWarning: Removed 1 row containing missing values (`geom_line()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n11.2.2 ヒストグラム\n次に，前年度のROEのヒストグラムを作成してみましょう。\n\ng &lt;- ggplot(df) +\n  aes(ROE) + # 1変数 ROE を指定\n  geom_histogram(fill=\"skyblue\", color = \"black\") + # ヒストグラム\n  xlim(-1,1) + mystyle # x軸の範囲とスタイルを指定\nprint(g)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 3829 rows containing non-finite values (`stat_bin()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`).\n\n\n\n\n\n\n\n\n\n11.2.3 箱ひげ図とバイオリンプロット\n次に，上場場所別ROEの分布を箱ひげ図とバイオリンプロットで比較してみましょう。 箱ひげ図は，geom_boxplot()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE) + geom_boxplot() + mystyle\nprint(g)\n\nWarning: Removed 3350 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\nROEのばらつきが大きく，極端にROEが大きかったり小さかったりする異常値のせいで，箱ひげ図がうまく描写されていません。 そこで異常値を除外するため，ROEの範囲を[-0.5,0.5]に限定してみましょう。 先ほど箱ひげ図を作成するために作ったオブジェクトgにylim()を追加して，Y軸の範囲を指定します。\n\ng &lt;- g + ylim(-.5,.5) # y軸の範囲を指定\nprint(g)\n\nWarning: Removed 4996 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n箱ひげ図の箱の下辺は第1四分位(Q1)で，上辺は第3四分位(Q3)です。 真ん中の太い横棒は中央値です。 箱から出ているひげはデータの四分位範囲を超えた値の範囲ですが，黒丸は外れ値を表しています。\n次に，バイオリンプロットを作成します。 バイオリンプロットもほぼ箱ひげ図と同じですが，geom_violin()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE)\ng &lt;- g + geom_violin() + ylim(-.5,.5) + mystyle\nprint(g)\n\nWarning: Removed 4996 rows containing non-finite values (`stat_ydensity()`).\n\n\n\n\n\n\n\n\n箱ひげ図やバイオリンプロットから，東証1部と東証2部の上場企業のROEは中央値に差があるものの，分布の形は似ていますが，マザーズの企業は，ROEの分布が大きく異なることがわかります。\n\n11.2.4 図の保存\n最後に，作成した図を保存するには，ggsave()関数を使います。 ggsave()関数は，次のような引数をとります。\n\n\nfilename = : 保存するファイル名\n\nplot = : 保存する図\n\nwidth = : 図の幅\n\nheight = : 図の高さ\n\ndpi = : 解像度\n\n日本語を含まないグラフであったり，Windowsならこれでうまくいくのですが，Macで日本語を含むggplotのグラフを保存するには一手間必要です。\nMacの場合\nMacの場合，ggsave()関数を使っても，日本語が文字化けしてしまいます。 そこでquartz()関数を用いて，次のようにすれば，日本語を含むグラフを保存することができます。 quartz()は以下の引数を取ります。\n\n\nfilename = : 保存するファイル名\n\nwidth = : 図の幅\n\nheight = : 図の高さ\n\npointsize = : フォントサイズ\n\nfamily = : フォントファミリー\n\ntype = : ファイルタイプ\n\nantialias = : アンチエイリアス\n\n\nquartz(\"violin_plot.pdf\", width = 10, height = 6, pointsize = 10)\nprint(g)\ndev.off()\n\nこれで作業ディレクトリにviolin_plot.pdfが保存されました。",
    "crumbs": [
      "第2部 データハンドリング",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データの可視化・視覚化</span>"
    ]
  },
  {
    "objectID": "chap10_stats.html#変数の種類と記述統計",
    "href": "chap10_stats.html#変数の種類と記述統計",
    "title": "\n10  データの可視化・視覚化\n",
    "section": "\n10.1 変数の種類と記述統計",
    "text": "10.1 変数の種類と記述統計\nデータには「カテゴリ変数」(category variable)と「量的変数」(quantitative variable)あるいは「連続変数」(continuous variable)があり，それぞれに対して適切なグラフの種類があります。\n\n10.1.1 カテゴリー変数と量的変数\nカテゴリー変数(category variable)とは、観測値が属するカテゴリーを表す変数です。 たとえば、日経産業中分類の「水産」は35、鉱業は37，建設は41ですが、これらの数値は足したり引いたりすることに意味はありません。\n量的変数(quantitative variable)とは、観測値が数値で表される変数です。 たとえば、売上高や株価は金額で表されるため、足したり引いたり、平均や分散を計算することに意味があります。\nしたがって、手元にあるデータベースの各変数がカテゴリー変数か量的変数かを把握することは極めて重要です。 Rでは自動で両者を区別したりはしてくれないので、データを読み込んだ後に変数の種類を確認し、自分で指定します。\n練習用データの読み込み\nここでは、教科書とは違う、企業の財務データを使いながら、データの可視化を学びます。 財務データが収録されたcsvファイルを，tidyverseのread_csv()関数を使って読み込みます。 read_csv()関数の引数として，ファイルの場所とファイル名を直接パスあるいは相対パスを指定します。\n\ndf &lt;- read_csv(\"data/RD_2022.csv\")\n\nRows: 57823 Columns: 23\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): 会社コード, 企業名, 決算期\ndbl (20): 決算種別, 連結基準, 決算月数, 上場コード, 日経業種コード, 現金預金, 資産合計, 資本金, 資本剰余金, 利益剰余金, 自...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nglimpse(df) # データの概要\n\nRows: 57,823\nColumns: 23\n$ 会社コード                     &lt;chr&gt; \"0000001\", \"0000001\", \"0000001\", \"00000…\n$ 企業名                         &lt;chr&gt; \"極洋\", \"極洋\", \"極洋\", \"極洋\", \"極洋\",…\n$ 決算期                         &lt;chr&gt; \"1999/03\", \"2000/03\", \"2001/03\", \"2002/…\n$ 決算種別                       &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,…\n$ 連結基準                       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ 決算月数                       &lt;dbl&gt; 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,…\n$ 上場コード                     &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,…\n$ 日経業種コード                 &lt;dbl&gt; 235341, 235341, 235341, 235341, 235341,…\n$ 現金預金                       &lt;dbl&gt; 6307, 4951, 3818, 4185, 4015, 3456, 277…\n$ 資産合計                       &lt;dbl&gt; 62109, 60885, 60599, 57069, 55373, 5856…\n$ 資本金                         &lt;dbl&gt; 5664, 5664, 5664, 5664, 5664, 5664, 566…\n$ 資本剰余金                     &lt;dbl&gt; NA, NA, NA, NA, 742, 742, 742, 743, 749…\n$ 利益剰余金                     &lt;dbl&gt; 2739, 4238, 4812, 5485, 6254, 6378, 727…\n$ 自己株式                       &lt;dbl&gt; NA, NA, -79, -154, -387, -464, -368, -2…\n$ 売上高                         &lt;dbl&gt; 171944, 171031, 166644, 158006, 162773,…\n$ 経常利益                       &lt;dbl&gt; 1600, 2299, 1947, 2333, 3314, 2895, 335…\n$ 法人税等                       &lt;dbl&gt; 620, 606, 908, 856, 1234, 1302, 1422, 1…\n$ 法人税等調整額                 &lt;dbl&gt; NA, -178, -114, 44, -272, -234, 136, -3…\n$ 親会社株主に帰属する当期純利益 &lt;dbl&gt; -251, 327, 927, 1026, 1122, 1248, 1388,…\n$ 研究開発費IFRS                 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ 研究開発費                     &lt;dbl&gt; 210, 201, 190, 179, 197, 212, 201, 193,…\n$ `開発費・試験研究費`           &lt;dbl&gt; 210, 105, 119, 153, 176, 156, 122, 148,…\n$ 現金及び現金同等物の期末残高   &lt;dbl&gt; NA, 4865, 3729, 4097, 3923, 3359, 2725,…\n\n\n23個の変数があり、データの個数は57,823となっています。 以下ではこのデータを使って、データの可視化を学びます。\n\n10.1.2 基本的な統計量の確認\nはじめにsummary()で基本的な統計量を確認します。\n\nsummary(df)\n\n  会社コード           企業名             決算期             決算種別 \n Length:57823       Length:57823       Length:57823       Min.   :10  \n Class :character   Class :character   Class :character   1st Qu.:10  \n Mode  :character   Mode  :character   Mode  :character   Median :10  \n                                                          Mean   :10  \n                                                          3rd Qu.:10  \n                                                          Max.   :10  \n                                                                      \n    連結基準        決算月数       上場コード    日経業種コード  \n Min.   :1.000   Min.   : 1.00   Min.   :11.00   Min.   :101001  \n 1st Qu.:1.000   1st Qu.:12.00   1st Qu.:11.00   1st Qu.:121204  \n Median :1.000   Median :12.00   Median :11.00   Median :241403  \n Mean   :1.062   Mean   :11.98   Mean   :11.46   Mean   :190751  \n 3rd Qu.:1.000   3rd Qu.:12.00   3rd Qu.:12.00   3rd Qu.:257561  \n Max.   :3.000   Max.   :17.00   Max.   :13.00   Max.   :271704  \n                                                                 \n    現金預金           資産合計             資本金          資本剰余金     \n Min.   :       4   Min.   :       70   Min.   :      1   Min.   :-161917  \n 1st Qu.:    2023   1st Qu.:    14062   1st Qu.:   1198   1st Qu.:    965  \n Median :    5370   Median :    39028   Median :   3363   Median :   2995  \n Mean   :   38172   Mean   :   363536   Mean   :  16481   Mean   :  20259  \n 3rd Qu.:   16467   3rd Qu.:   125705   3rd Qu.:  10090   3rd Qu.:   9927  \n Max.   :68502665   Max.   :303846980   Max.   :3500000   Max.   :4503856  \n NA's   :193        NA's   :44          NA's   :198       NA's   :7714     \n   利益剰余金          自己株式            売上高            経常利益      \n Min.   : -972773   Min.   :-3306037   Min.   :       1   Min.   :-869562  \n 1st Qu.:    2250   1st Qu.:   -1368   1st Qu.:   13366   1st Qu.:    425  \n Median :    9163   Median :    -279   Median :   38209   Median :   1626  \n Mean   :   75680   Mean   :   -5144   Mean   :  237440   Mean   :  14070  \n 3rd Qu.:   34436   3rd Qu.:     -39   3rd Qu.:  127091   3rd Qu.:   6126  \n Max.   :26453126   Max.   :      -1   Max.   :31379507   Max.   :5670456  \n NA's   :299        NA's   :10800      NA's   :27         NA's   :21       \n    法人税等       法人税等調整額       親会社株主に帰属する当期純利益\n Min.   : -21709   Min.   :-1139009.0   Min.   :-1708029              \n 1st Qu.:    159   1st Qu.:    -134.5   1st Qu.:     163              \n Median :    586   Median :      -7.0   Median :     823              \n Mean   :   4827   Mean   :    -114.7   Mean   :    7707              \n 3rd Qu.:   2170   3rd Qu.:      91.0   3rd Qu.:    3372              \n Max.   :1190782   Max.   : 1097414.0   Max.   : 4987962              \n NA's   :391       NA's   :3736         NA's   :29                    \n 研究開発費IFRS     研究開発費      開発費・試験研究費\n Min.   :    48   Min.   :      1   Min.   :     1    \n 1st Qu.:  2440   1st Qu.:    131   1st Qu.:   169    \n Median : 24628   Median :    547   Median :   651    \n Mean   : 91248   Mean   :   8441   Mean   :  7528    \n 3rd Qu.:108096   3rd Qu.:   2330   3rd Qu.:  2710    \n Max.   :806905   Max.   :1124262   Max.   :662610    \n NA's   :57583    NA's   :21525     NA's   :38296     \n 現金及び現金同等物の期末残高\n Min.   :    -292            \n 1st Qu.:    1913            \n Median :    5328            \n Mean   :   39185            \n 3rd Qu.:   16954            \n Max.   :68419223            \n NA's   :1591                \n\n\n文字列となっている変数以外の量的変数については、最小値、第1四分位、中央値、平均値、第3四分位、最大値、欠損値の数、といった項目が計算されています。 数値データのうち、カテゴリー変数の統計量については意味が無いです。\n23個の変数の型を確認すると、大部分の財務データは数値&lt;dbl&gt;ですが、\n\n会社コード\n企業名\n決算期\n\nの3つは文字列&lt;chr&gt;となっています。 また、数値となっているけれど、実際はカテゴリー変数であるものとして、\n\n決算種別 : 10 = 本決算\n\n連結基準 : 1 = 日本基準, 2 = 米国基準, 3 = IFRS, 0 = 単独\n\n上場コード : 11 = 東証1部, 12 = 東証2部, 13 = 東証マザーズ,\n日経業種コード : 後で説明あり\n\nがあります。 文字列となっている変数以外の量的変数については、最小値、第1四分位、中央値、平均値、第3四分位、最大値、欠損値の数、といった項目が計算されています。 数値データとなっているカテゴリー変数である決算種別，連結基準，上場コード，日経業種コードの統計量も計算されていますが，もちろん意味は無いので，Rにカテゴリー変数であることを明示するためにファクター型に変換する必要があります。\nとりあえず、数値データのうち、カテゴリー変数ではないものについて、統計量を計算してみます。 主要な統計量を返す関数には以下のものがあります。\n\n\nmean() : 算術平均を計算する\n\nmedian() : 中央値を計算する\n\nsd() : (不偏)標準偏差を計算する\n\nvar() : (不偏)分散を計算する\n\nmin() : 最小値を計算する\n\nmax() : 最大値を計算する\n\nでは、売上高の平均を計算してみましょう。 データフレームdfの売上高にアクセスするには、df$売上高のように、$を使って変数名を指定します。 Excelでいうと，dfがシート名，売上高が列名に相当します。\n\nmean(df$売上高)\n\n[1] NA\n\n\nNAが帰ってきましたね。 実は、このmean()関数は、引数となるベクトル変数の中に欠損値NAがあると、NAを返します。 欠損値を意味するNAは，その観測値が存在しないことを表します。 このような場合、NAを除外して平均を計算する必要があるので、na.rm = TRUEという引数を追加します。\n\nmean(df$売上高, na.rm = TRUE)\n\n[1] 237440.1\n\n\nこれで、売上高の平均が2.3744011^{5}となりました。\n同じように、\n\nmedian(df$売上高, na.rm = TRUE) # 中央値\n\n[1] 38209\n\nsd(df$売上高, na.rm = TRUE) # 標準偏差\n\n[1] 938244.4\n\n\nとすることで、中央値と標準偏差が求められます。\n\n10.1.3 カテゴリ変数の内容確認\nカテゴリー変数について見ていきましょう。 ここでは日経業種コードを例にとります。 日経業種コードは6ケタの数字ですが、最初の1ケタが大分類、次の2ケタ目が中分類、最後の3ケタ目が小分類を表します。つまり1 + 32 + 344のような構造になっています。 実証会計研究では、産業中分類をよく使うので、ここでは中分類を抽出してみましょう。 またしてもsubstr()関数を使って、2〜3ケタ目を抽出し、中分類という変数に格納します。 ついでに，決算期のデータがYYYY/MMという形式になっているので，最初の4桁を抽出して，年度という変数に格納します。\n\ndf &lt;- df %&gt;%\n  mutate(\n    中分類 = substr(日経業種コード, 2, 3), #2〜3ケタ目を抽出\n    年度 = substr(決算期, 1, 4) # 最初の4桁を抽出\n    )\n\nこの中分類の内容を確認するには、table()関数を使います。\n\ntable(df$中分類) # 中分類の表\n\n\n   01    03    05    07    09    11    13    15    17    19    21    23    25 \n 2215   934   432  3915   947   178   459  1066   906  2174  4338  5016    96 \n   27    29    31    33    35    37    41    43    45    52    53    55    57 \n 1651   253  1035  1936   203   131  2715  5926  3501   832  1674   670   640 \n   59    61    63    65    67    69    71 \n  261    96   746   625   285   214 11753 \n\n\nこのように、中分類ごとの企業数が計算されました。 このカテゴリー変数の型をclass()関数で確認します。\n\nclass(df$中分類) # 中分類の型\n\n[1] \"character\"\n\n\ncharacterつまり文字列となっています。これをファクター型に変えて、カテゴリー変数であることを明示します。as.factor()関数を使うと、ファクター型に変換できますが，産業コードだけだとどの産業なのか分かりづらいままです。 そこで、factor()関数を使って、カテゴリー変数の内容を指定します。 ついでに，上場コードや連結基準もファクター型に変換しておきます。\nまずどんな中分類があるのかを確認します。 ある変数にどんなカテゴリーがあるのかを確認するには、unique()関数を使います。\n\nchu_level &lt;- sort(unique(df$中分類)) # 中分類のカテゴリーを抽出\n\nこの中分類コードに対応する産業名称を指定するには，factor()関数の引数として，levels =とlabels =を指定します。 以下では，mutate()と組み合わせて，中分類をファクター型に変換します。\n産業名称をベクトルとして収納しておきます。\n\nchu_name &lt;- c(\n  \"食品\",\"繊維\",\"パルプ・紙\",\"化学工業\",\"医薬品\",\"石油\",\"ゴム\",\"窯業\",\"鉄鉱業\",\"非金属及び金属製品\",\"機械\",\"電気機器\",\"造船\",\"自動車・自動車部品\",\"その他輸送用機器\",\"精密機器\",\"その他製造業\",\"水産\",\"鉱業\",\"建設\",\"商社\",\"小売業\",\"その他金融業\",\"不動産\",\"鉄道・バス\",\"陸運\",\"海運\",\"空輸\",\"倉庫・運輸関連\",\"通信\",\"電力\",\"ガス\",\"サービス業\")\n\n\ndf &lt;- df %&gt;%\n  arrange(中分類) %&gt;%\n  mutate(\n    中分類 = factor( # 中分類をファクター型に変換\n      中分類,\n      levels = chu_level, # カテゴリーの種類\n      labels = chu_name), # カテゴリーの名称\n    上場コード = factor(\n      上場コード,\n      levels = c(11,12,13), # カテゴリーの種類\n      labels = c(\"1部\",\"2部\",\"マザーズ\")), # カテゴリーの名称\n    連結基準 = factor(\n      連結基準,\n      levels = c(1,2,3,0),\n      labels = c(\"日本基準\",\"米国基準\",\"IFRS\",\"単独\"))\n      )\n\nカテゴリー変数がファクター型に変換されたので，再度summary()関数を使って，概要統計量を確認してみましょう。\n\nsummary(df)\n\n  会社コード           企業名             決算期             決算種別 \n Length:57823       Length:57823       Length:57823       Min.   :10  \n Class :character   Class :character   Class :character   1st Qu.:10  \n Mode  :character   Mode  :character   Mode  :character   Median :10  \n                                                          Mean   :10  \n                                                          3rd Qu.:10  \n                                                          Max.   :10  \n                                                                      \n     連結基準        決算月数        上場コード    日経業種コード  \n 日本基準:55727   Min.   : 1.00   1部     :33171   Min.   :101001  \n 米国基準:  581   1st Qu.:12.00   2部     :22529   1st Qu.:121204  \n IFRS    : 1515   Median :12.00   マザーズ: 2123   Median :241403  \n 単独    :    0   Mean   :11.98                    Mean   :190751  \n                  3rd Qu.:12.00                    3rd Qu.:257561  \n                  Max.   :17.00                    Max.   :271704  \n                                                                   \n    現金預金           資産合計             資本金          資本剰余金     \n Min.   :       4   Min.   :       70   Min.   :      1   Min.   :-161917  \n 1st Qu.:    2023   1st Qu.:    14062   1st Qu.:   1198   1st Qu.:    965  \n Median :    5370   Median :    39028   Median :   3363   Median :   2995  \n Mean   :   38172   Mean   :   363536   Mean   :  16481   Mean   :  20259  \n 3rd Qu.:   16467   3rd Qu.:   125705   3rd Qu.:  10090   3rd Qu.:   9927  \n Max.   :68502665   Max.   :303846980   Max.   :3500000   Max.   :4503856  \n NA's   :193        NA's   :44          NA's   :198       NA's   :7714     \n   利益剰余金          自己株式            売上高            経常利益      \n Min.   : -972773   Min.   :-3306037   Min.   :       1   Min.   :-869562  \n 1st Qu.:    2250   1st Qu.:   -1368   1st Qu.:   13366   1st Qu.:    425  \n Median :    9163   Median :    -279   Median :   38209   Median :   1626  \n Mean   :   75680   Mean   :   -5144   Mean   :  237440   Mean   :  14070  \n 3rd Qu.:   34436   3rd Qu.:     -39   3rd Qu.:  127091   3rd Qu.:   6126  \n Max.   :26453126   Max.   :      -1   Max.   :31379507   Max.   :5670456  \n NA's   :299        NA's   :10800      NA's   :27         NA's   :21       \n    法人税等       法人税等調整額       親会社株主に帰属する当期純利益\n Min.   : -21709   Min.   :-1139009.0   Min.   :-1708029              \n 1st Qu.:    159   1st Qu.:    -134.5   1st Qu.:     163              \n Median :    586   Median :      -7.0   Median :     823              \n Mean   :   4827   Mean   :    -114.7   Mean   :    7707              \n 3rd Qu.:   2170   3rd Qu.:      91.0   3rd Qu.:    3372              \n Max.   :1190782   Max.   : 1097414.0   Max.   : 4987962              \n NA's   :391       NA's   :3736         NA's   :29                    \n 研究開発費IFRS     研究開発費      開発費・試験研究費\n Min.   :    48   Min.   :      1   Min.   :     1    \n 1st Qu.:  2440   1st Qu.:    131   1st Qu.:   169    \n Median : 24628   Median :    547   Median :   651    \n Mean   : 91248   Mean   :   8441   Mean   :  7528    \n 3rd Qu.:108096   3rd Qu.:   2330   3rd Qu.:  2710    \n Max.   :806905   Max.   :1124262   Max.   :662610    \n NA's   :57583    NA's   :21525     NA's   :38296     \n 現金及び現金同等物の期末残高        中分類          年度          \n Min.   :    -292             サービス業:11753   Length:57823      \n 1st Qu.:    1913             商社      : 5926   Class :character  \n Median :    5328             電気機器  : 5016   Mode  :character  \n Mean   :   39185             機械      : 4338                     \n 3rd Qu.:   16954             化学工業  : 3915                     \n Max.   :68419223             小売業    : 3501                     \n NA's   :1591                 (Other)   :23374                     \n\n\nカテゴリー変数はカテゴリーの種類と個数が表示されています。\n\n10.1.4 2つのカテゴリー変数の関係を確かめる\n2つの変数から表を作成する方法について学びます。 典型的な表として，2変数のクロス集計表があります。 例えば，連結基準，つまり企業が採用している会計基準の種類と，上場コード，つまり企業が上場している市場の種類，の2変数について，それぞれのカテゴリーごとの企業数を計算することができます。\n\ntable(df$連結基準, df$上場コード)\n\n          \n             1部   2部 マザーズ\n  日本基準 31290 22432     2005\n  米国基準   580     0        1\n  IFRS      1301    97      117\n  単独         0     0        0\n\n\n圧倒的に，日本基準で上場している企業が多いことがわかります。 2020年度のデータだけを抽出して，同じようにクロス集計表を作成してみましょう。\n\ndf %&gt;%\n  filter(年度 == 2020) %&gt;%\n  with(table(連結基準, 上場コード))\n\n          上場コード\n連結基準  1部  2部 マザーズ\n  日本基準 1474 1177      259\n  米国基準   11    0        0\n  IFRS      194   15       22\n  単独        0    0        0\n\n\n東証1部に上場している企業に注目すると，日本基準採用企業が1474社，米国基準採用企業が11社，IFRS採用企業が194社となっていることがわかりました。\nこのように，table()関数の引数として2つのカテゴリー変数を指定すると，そこから2 \\times 2のグループに属する企業数を計算し，表を作成してくれます。\nここで急に登場したwith()関数ですが，with()関数は主として次の2つの引数をとります。\n\nデータ\n式\n\n例えば，先の表を作る場合を考えてみましょう。 普通に書くと\n\ntable(df$連結基準, df$上場コード)\n\nとかきましたが，何度もdf$を書くことが面倒なので，with()関数を使って\n\nwith(df, table(連結基準, 上場コード))\n\nと，第1引数にdfを指定すれば，第2引数の式の中でdf$を書く必要がなくなります。したがって，パイプ演算子を使って，\n\ndf %&gt;% with(table(連結基準, 上場コード))\n\nと処理をつなげることができます。 便利ですね。\n\n10.1.5 カテゴリー別に量的変数の値を調べる\n次は，量的変数をカテゴリーごとに分析したいときがあります。 たとえば，産業別や年度別に売上高の平均値を知りたい，ということが何度もあります。 任意のグループごとに処理を繰り返したいときは，dplyrパッケージのgroup_by()関数を使います。 group_by()関数は，第1引数にグループ化したい変数を指定します。\nそしてgroup_by()関数と同時に使うことで，グループごとの統計量を計算するために便利なのがdplyrパッケージのsummarize()関数です。 summarize()関数は，次のような引数をとり，各種統計量を計算してくれます。\n\n\nmean = : 平均\n\nmedian = : 中央値\n\nsd = : 標準偏差\n\nvar = : 分散\n\nn() : グループごとの観測値の個数\n\n例えば，上場場所ごとに売上高の平均値を計算するには，次のようにします。\n\ndf %&gt;%\n  group_by(上場コード) %&gt;% # 上場場ごとに\n  summarize(\n    企業数 = n(), #\n    平均売上高 = mean(売上高, na.rm = TRUE) # 平均\n    ) %&gt;%\n  ungroup() %&gt;% # グループ化解除\n  knitr::kable(booktabs = TRUE) # 表を作成\n\n\n\n上場コード\n企業数\n平均売上高\n\n\n\n1部\n33171\n393156.220\n\n\n2部\n22529\n29884.533\n\n\nマザーズ\n2123\n5459.012\n\n\n\n\n\n結果を見れば分かるとおり，group_by()で上場場所ごとにグループ化し，summarize()で企業数と平均売上高を計算しているので，上場場所，企業数，平均売上高の3変数が3つの観測値をもつ3 \\times 3の表が作成されています。 group_by()とsummarize()を組み合わせると，結果としてグループ数に応じた統計量を計算した結果となり，元のデータよりも小さなデータフレームとなって返ってきます。\nついでに，産業別の売上高合計，利益平均値，利益中央値，利益の標準偏差を計算してみましょう。\n\ndf %&gt;%\n  group_by(中分類) %&gt;% # 産業中分類ごとに\n  summarize(\n    企業数 = n(), # n()で要素数\n    売上合計 = sum(売上高, na.rm = TRUE), # 合計\n    利益平均値 = mean(親会社株主に帰属する当期純利益, na.rm = TRUE), # 平均\n    利益中央値 = median(親会社株主に帰属する当期純利益, na.rm = TRUE), # 中央値\n    利益標準偏差 = sd(親会社株主に帰属する当期純利益, na.rm = TRUE) # 標準偏差\n    ) %&gt;%\n  arrange(desc(売上合計)) %&gt;% # 売上合計で降順に並び替え\n  ungroup() %&gt;% # グループ化解除\n  knitr::kable(booktabs = TRUE) # 表を作成\n\n\n\n\n\n\n\n\n\n\n\n中分類\n企業数\n売上合計\n利益平均値\n利益中央値\n利益標準偏差\n\n\n\n電気機器\n5016\n1941560030\n10167.927\n1084.0\n62674.007\n\n\n商社\n5926\n1909721701\n6754.815\n738.0\n43249.527\n\n\n自動車・自動車部品\n1651\n1688864541\n39250.629\n1851.0\n210604.044\n\n\n小売業\n3501\n793035711\n4590.688\n880.0\n14968.112\n\n\n化学工業\n3915\n736860746\n7564.608\n1445.0\n23530.649\n\n\nサービス業\n11753\n694250494\n2578.502\n361.0\n17729.118\n\n\n通信\n625\n647052927\n67415.843\n3040.0\n284105.640\n\n\n機械\n4338\n616584704\n5310.454\n1007.0\n20211.162\n\n\n建設\n2715\n597371111\n4868.903\n1073.5\n22122.402\n\n\n食品\n2215\n553185961\n8370.878\n1211.0\n32427.752\n\n\n電力\n285\n435223159\n24108.284\n21988.0\n127809.199\n\n\n非金属及び金属製品\n2174\n333425028\n3537.316\n704.0\n15694.021\n\n\n鉄道・バス\n670\n309477897\n16710.421\n3660.0\n61053.123\n\n\n鉄鉱業\n906\n306858163\n8887.185\n903.0\n47067.285\n\n\n石油\n178\n247483911\n14830.657\n1510.5\n81496.356\n\n\n医薬品\n947\n199368660\n20915.376\n4157.0\n48451.048\n\n\nその他製造業\n1936\n189462230\n2630.949\n595.0\n8999.953\n\n\n不動産\n1674\n181588397\n5826.409\n1192.0\n20315.917\n\n\n窯業\n1066\n145506672\n4485.089\n909.5\n13623.277\n\n\nその他金融業\n832\n142861287\n9388.689\n1657.5\n47428.745\n\n\nゴム\n459\n133429682\n12362.357\n1381.0\n43652.986\n\n\n精密機器\n1035\n132220025\n6338.030\n1015.0\n17597.021\n\n\n陸運\n640\n118243116\n4662.080\n1285.5\n9675.867\n\n\n繊維\n934\n115700455\n2405.079\n542.0\n10837.288\n\n\n海運\n261\n104869365\n15152.031\n1012.0\n93497.186\n\n\nパルプ・紙\n432\n100989604\n3345.630\n693.5\n9869.195\n\n\nガス\n214\n89266508\n16210.327\n3620.0\n26366.794\n\n\n空輸\n96\n70396355\n13813.062\n1053.0\n105853.201\n\n\n造船\n96\n50404788\n4001.927\n968.5\n18613.163\n\n\n倉庫・運輸関連\n746\n48088368\n1876.247\n622.0\n3991.522\n\n\n水産\n203\n35003357\n2327.473\n1122.0\n4202.917\n\n\nその他輸送用機器\n253\n27993041\n4227.802\n1102.0\n12600.550\n\n\n鉱業\n131\n26740727\n15827.588\n2096.0\n46860.380\n\n\n\n\n\n次のグラフ作成のためのデータを作成するため，年度別ごとに，ROEの平均値を計算し，その結果をdf_yearという変数に代入します。 ROEは，ある年度の親会社に帰属する当期純利益を期首株主資本で割った値です。 株主資本は，資本金と資本剰余金，利益剰余金，自己株式の合計で計算しますが，欠損値になっている会社もあるので，replace_na()関数を使って欠損値にはゼロを代入します。\n\ndf &lt;- df %&gt;%\n  replace_na(list(資本剰余金 = 0, 利益剰余金 = 0, 自己株式 = 0)) %&gt;% # 欠損値をゼロに置き換え\n  group_by(企業名) %&gt;% # 会社ごとに\n  mutate( # 新変数作成\n    株主資本 = 資本金 + 資本剰余金 + 利益剰余金 + 自己株式, # 株主資本を計算\n    ) %&gt;%\n    filter(株主資本 &gt;0 ) %&gt;% # 株主資本がマイナスの企業を除外\n  mutate(\n    ROE = 親会社株主に帰属する当期純利益 / lag(株主資本) # ROEを計算\n    ) %&gt;%\n  ungroup() # グループ化解除\n\ndf_year &lt;- df %&gt;%\n  group_by(年度) %&gt;% # 年ごとに\n  summarize( # 統計量を計算\n    平均ROE = mean(ROE, na.rm = TRUE)\n    ) %&gt;%\n  ungroup() # グループ化解除\n\nこれで，年度ごと，上場場所ごとに，平均ROEを計算したデータフレームdf_yearができました。\nここで注意しなければならない点として，group_by(企業名)とした上で，lag()関数を使っている点です。 lag()関数は，引数として指定した変数の値の1つ前の値に変換します。 したがって，group_by()を使わないと次のような結果になります。\n\n\n\n\n\n\n\n\n\n\n\n企業名\n年度\n親会社株主に帰属する当期純利益\n株主資本\nROE\n\n\n\nニップン\n2020\n8941\n129587\n0.0723101\n\n\nニップン\n2021\n8636\n135597\n0.0666425\n\n\nニップン\n2022\n9327\n142166\n0.0687847\n\n\n日清製粉グループ本社\n1999\n7327\n156543\n0.0515383\n\n\n日清製粉グループ本社\n2000\n10822\n175112\n0.0691312\n\n\n日清製粉グループ本社\n2001\n11136\n177671\n0.0635936\n\n\n\n\n\nここで問題になっているのが，日清製粉グループ本社の1999年のROEが計算されている点である。 ROEは分子に親会社株主に帰属する当期純利益，分母に期首株主資本，つまりは前期末の株主資本を使います。 したがって，1999年のROEを計算するためには，1998年の株主資本を使う必要がありますが，データは1999年からしか存在しないので欠損値にならないといけないのに，計算されてしまっています。 つまり，一つ上のニップンの2022年の株主資本のデータを使っているのです。 そこで，group_by()により企業ごとにグループ化して，lag()関数を使って，一つ前の観測値を使うようにし，1999年のROEは欠損値になるようにします。\n\n\n\n\n企業名\n年度\n株主資本\nROE\n\n\n\nニップン\n2020\n129587\n0.0723101\n\n\nニップン\n2021\n135597\n0.0666425\n\n\nニップン\n2022\n142166\n0.0687847\n\n\n日清製粉グループ本社\n1999\n156543\nNA\n\n\n日清製粉グループ本社\n2000\n175112\n0.0691312\n\n\n日清製粉グループ本社\n2001\n177671\n0.0635936",
    "crumbs": [
      "第2部 データハンドリング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの可視化・視覚化</span>"
    ]
  },
  {
    "objectID": "chap10_stats.html#変数の可視化視覚化",
    "href": "chap10_stats.html#変数の可視化視覚化",
    "title": "\n10  データの可視化・視覚化\n",
    "section": "\n10.2 変数の可視化・視覚化",
    "text": "10.2 変数の可視化・視覚化\nカテゴリー変数のファクター化，with()関数とtable()関数を使ったクロス集計表の作成，group_by()関数とsummarize()関数を使ったグループごとの統計量の計算について学んだので，これらの結果を使ってグラフを作ることで，読者に伝わるデータの可視化を行いたいと思います。 キレイなグラフを比較的簡単に作ることができるggplot2パッケージを使います。\n\n10.2.1 ggplot()関数の基本的な使い方と変数の特徴把握\nggplot2パッケージのggplot()関数は，次のような引数をとります。\n\n\ndata = : データフレーム\n\nmapping = aes() : グラフの構成要素を指定する関数\n\ngeom_*** : グラフの種類を指定する関数\n各種オプション\n\n最初の注意点として，ggplot()関数は，第1引数data =でtibbleかdata.frameを指定する必要があります。 データの型に気をつけましょう。\nでは，年度ごとに平均ROEを示した折れ線グラフを作図していきます。 まず土台となるデータフレームを指定します。\n\nggplot(data = df_year)\n\n\n\n\n\n\n\n土台ができましたが，まだ何も表示されていません。 次に，グラフの構成要素を指定するために，mapping = aes()で，軸を指定します。 今回は，横軸に年度，縦軸に平均ROEを指定します。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE))\n\n\n\n\n\n\n\n縦軸と横軸が表示されました。 軸のラベルが文字化けしているので，最初に作成しておいたスタイルmystyleを適用します。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE)) + mystyle\n\n\n\n\n\n\n\n次に，グラフを作成するために，geom_line()関数を使います。 ggplot関数では，次のようなgeom_***()関数を使って，グラフの種類を指定します。\n\n\ngeom_point() : 散布図\n\ngeom_line() : 折れ線グラフ\n\ngeom_bar() : 棒グラフ\n\ngeom_boxplot() : 箱ひげ図\n\ngeom_histogram() : ヒストグラム\n\ngeom_density() : カーネル密度推定図\n\ngeom_violin() : バイオリンプロット\n\ngeom_smooth() : 平滑化曲線\n\nここでは横軸が年度という文字列，縦軸が平均ROEという量的変数となるグラフを作るので，geom_bar()を使います。\n\nggplot(data = df_year, mapping = aes(x = 年度, y = 平均ROE)) +\n  geom_bar(stat = \"identity\") + mystyle\n\nWarning: Removed 1 rows containing missing values (`position_stack()`).\n\n\n\n\n\n\n\n\n横軸が順序に意味のある変数であれば，geom_line()で折れ線グラフを作るほうが良いでしょう。 この場合，年度は文字列ですが，本来は順序に意味のあるカテゴリー変数ですので，factor()関数を使って，ファクター型に変換します。\n\ndf_year &lt;- df_year %&gt;%\n  mutate(年度f = factor(年度,\n  levels = c(1999:2022),\n  ordered = TRUE))\n\n横軸が順序付きのファクターの年度fとなったので，geom_line()を使って折れ線グラフを作成します。 ここで，オプションとして，group = 1を指定して，データ全体が1つのグループであることを明示します。 横軸がファクター型であるときは，group = 1をつける，というおまじないを覚えておきましょう。\n\nggplot(data = df_year, mapping = aes(x = 年度f, y = 平均ROE, group = 1)) +\n  geom_line() + geom_point() + xlab(\"年度\") + ylab(\"平均ROE\") + mystyle\n\nWarning: Removed 1 row containing missing values (`geom_line()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n上のコードは，必要な引数を省略せずに書きましたが，省略できるものを省略しつつ， すべての要素を+でつなぐよりも，レイヤーごとに代入していくほうが，コードが読みやすくなります。\n\ng &lt;- ggplot(df_year) + aes(年度f, 平均ROE, group = 1) # 基本要素\ng &lt;- g + geom_line() + geom_point() # 折れ線グラフと散布図\ng &lt;- g + xlab(\"年度\") + ylab(\"平均ROE\") + mystyle # 見た目の調整\nprint(g)\n\nWarning: Removed 1 row containing missing values (`geom_line()`).\n\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n10.2.2 ヒストグラム\n次に，前年度のROEのヒストグラムを作成してみましょう。\n\ng &lt;- ggplot(df) +\n  aes(ROE) + # 1変数 ROE を指定\n  geom_histogram(fill=\"skyblue\", color = \"black\") + # ヒストグラム\n  xlim(-1,1) + mystyle # x軸の範囲とスタイルを指定\nprint(g)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 3829 rows containing non-finite values (`stat_bin()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`).\n\n\n\n\n\n\n\n\n\n10.2.3 箱ひげ図とバイオリンプロット\n次に，上場場所別ROEの分布を箱ひげ図とバイオリンプロットで比較してみましょう。 箱ひげ図は，geom_boxplot()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE) + geom_boxplot() + mystyle\nprint(g)\n\nWarning: Removed 3350 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\nROEのばらつきが大きく，極端にROEが大きかったり小さかったりする異常値のせいで，箱ひげ図がうまく描写されていません。 そこで異常値を除外するため，ROEの範囲を[-0.5,0.5]に限定してみましょう。 先ほど箱ひげ図を作成するために作ったオブジェクトgにylim()を追加して，Y軸の範囲を指定します。\n\ng &lt;- g + ylim(-.5,.5) # y軸の範囲を指定\nprint(g)\n\nWarning: Removed 4996 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n箱ひげ図の箱の下辺は第1四分位(Q1)で，上辺は第3四分位(Q3)です。 真ん中の太い横棒は中央値です。 箱から出ているひげはデータの四分位範囲を超えた値の範囲ですが，黒丸は外れ値を表しています。\n次に，バイオリンプロットを作成します。 バイオリンプロットもほぼ箱ひげ図と同じですが，geom_violin()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE)\ng &lt;- g + geom_violin() + ylim(-.5,.5) + mystyle\nprint(g)\n\nWarning: Removed 4996 rows containing non-finite values (`stat_ydensity()`).\n\n\n\n\n\n\n\n\n箱ひげ図やバイオリンプロットから，東証1部と東証2部の上場企業のROEは中央値に差があるものの，分布の形は似ていますが，マザーズの企業は，ROEの分布が大きく異なることがわかります。\n\n10.2.4 図の保存\n最後に，作成した図を保存するには，ggsave()関数を使います。 ggsave()関数は，次のような引数をとります。\n\n\nfilename = : 保存するファイル名\n\nplot = : 保存する図\n\nwidth = : 図の幅\n\nheight = : 図の高さ\n\ndpi = : 解像度\n\n日本語を含まないグラフであったり，Windowsならこれでうまくいくのですが，Macで日本語を含むggplotのグラフを保存するには一手間必要です。\nMacの場合\nMacの場合，ggsave()関数を使っても，日本語が文字化けしてしまいます。 そこでquartz()関数を用いて，次のようにすれば，日本語を含むグラフを保存することができます。 quartz()は以下の引数を取ります。\n\n\nfilename = : 保存するファイル名\n\nwidth = : 図の幅\n\nheight = : 図の高さ\n\npointsize = : フォントサイズ\n\nfamily = : フォントファミリー\n\ntype = : ファイルタイプ\n\nantialias = : アンチエイリアス\n\n\nquartz(\"violin_plot.pdf\", width = 10, height = 6, pointsize = 10)\nprint(g)\ndev.off()\n\nこれで作業ディレクトリにviolin_plot.pdfが保存されました。",
    "crumbs": [
      "第2部 データハンドリング",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの可視化・視覚化</span>"
    ]
  },
  {
    "objectID": "part02.html",
    "href": "part02.html",
    "title": "第2部 前処理と記述統計量",
    "section": "",
    "text": "ここから具体的にデータを扱っていきます。 基本的に、立命館大学が契約している日経メディアマーケティングが提供している「日経NEEDS」というデータベースで入手できるデータを念頭に置いた内容になっています。\n第2部で練習のために使うデータは、以下のリンクからダウンロードしてください。\nhttps://so-ichi.com/presemi_part_two.csv\n\nこのデータには、以下の変数が含まれています。\n\n日経会社コード : 会社固有コード\n企業名称 : 企業の名称\n決算期 : 決算年月 YYYY/MM\n\n決算種別 : 10が本決算、20が中間決算\n連結基準 : 1が連結、2が非連結\n決算月数 : 決算期の月数\n上場場部：コード : 11が東証1部、12が東証2部、13がマザーズ\n日経業種：コード : 日経業種のコード6ケタ\n売上高\n親会社株主に帰属する当期純利益\n資産合計\n株主資本",
    "crumbs": [
      "第2部 前処理と記述統計量"
    ]
  },
  {
    "objectID": "chap09_handling.html#ここで用いる基本関数",
    "href": "chap09_handling.html#ここで用いる基本関数",
    "title": "\n11  データハンドリング\n",
    "section": "\n11.1 ここで用いる基本関数",
    "text": "11.1 ここで用いる基本関数\n\n\nhead(): データの先頭を表示する関数\n\nstr(): データの構造を表示する関数\n\nここで用いるtidyverse関数\n\n\nreadr::read_csv(): CSVファイルを読み込む関数\n\ndplyr::glimpse(): データの構造を表示する関数\n\ndplyr::mutate(): データに新しい変数を追加する関数\n\ndplyr::select(): データの変数を選択する関数\n\ndplyr::filter(): データの行を選択する関数\n\ndplyr::group_by(): データをグループ化する関数\n\ndplyr::summarise(): データを集約する関数\n\ndplyr::arrange(): データを並び替える関数\n\ndplyr::count(): データの行数を数える関数",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#データハンドリング",
    "href": "chap09_handling.html#データハンドリング",
    "title": "\n9  データハンドリング\n",
    "section": "\n9.2 データ・ハンドリング",
    "text": "9.2 データ・ハンドリング\nRによるデータ操作の基本について学びます。 このあたりを学習すれば，MS ExcelよりもRの方がデータを分析するのに向いていることがわかると思います。\n\n9.2.1 データの読み込み\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nデータを読み込むには，tidyverseのreadrパッケージのread_csv()関数を使います。 関数名のとおりread_csv関数は，csvファイルをRに読み込む関数です。 csvファイルとは，カンマで区切られたテキストファイルで、次のようなデータとなっています。\n会社コード,企業名,決算期,決算種別,連結基準,決算月数,上場コード,日経業種コード,売上高,親会社株主に帰属する当期純利益,資産合計,株主資本\n0000001,極洋,2006/03,10,1,12,11,235341,152899,2007,65049,14852\n0000001,極洋,2007/03,10,1,12,11,235341,157088,2000,66459,16339\n0000001,極洋,2008/03,10,1,12,11,235341,147767,1497,57373,16873\ncsvファイルは，MS Excelで作成することができますが、日経NEEDSからダウンロードしたcsvファイルをExcelで開いてしまうと、勝手にいろいろな処理が勝手に行われてしまうので、注意が必要です。\n\n\nread_csv\n\nread_csv()関数の引数は非常に多く、設定次第では効率的に前処理ができますが、ここではシンプルに読み込むだけの方法を使います。 読み込んだデータは、dfという名前のオブジェクトに代入します。\n\ndf &lt;- read_csv(\"https://so-ichi.com/presemi_part_two.csv\")\n\nRows: 44527 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): 会社コード, 企業名, 決算期\ndbl (9): 決算種別, 連結基準, 決算月数, 上場コード, 日経業種コード, 売上高, 親会社株主に帰属する当期純利益, 資産合計, 株主資本...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n結果の1行目にRows: 44527 Columns: 12とあるように、dfには44527行12列のデータが読み込まれています。 このdfのクラスを確認してみます。\n\nclass(df)\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\n\nすると、\"spec_tbl_df\"、\"tbl_df\"、\"tbl\"、\"data.frame\"という方が与えられていることがわかります。 ここでは、data.frameであるということだけ覚えておいてください。\n\n\n\nread_csv()関数の引数には、次のようなものがあります。\n\n\nfile: 読み込むファイルの名前、あるいはパス\n\ncol_names: 列名を指定するかどうか\n\ncol_types: 列の型を指定するかどうか\n\nlocale: ファイルのエンコーディングを指定するかどうか\n\nna: 欠損値の文字列を指定するかどうか\n\n読み込んだデータを簡単にチェックする方法として、head()関数があります。 これは、データの先頭の行を表示する関数です。 デフォルトでは、先頭の6行が表示されます。引数nで表示する行数を指定することができます。\n\nhead(df, n = 4)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n会社コード\n企業名\n決算期\n決算種別\n連結基準\n決算月数\n上場コード\n日経業種コード\n売上高\n親会社株主に帰属する当期純利益\n資産合計\n株主資本\n\n\n\n0000001\n極洋\n2006/03\n10\n1\n12\n11\n235341\n152899\n2007\n65049\n14852\n\n\n0000001\n極洋\n2007/03\n10\n1\n12\n11\n235341\n157088\n2000\n66459\n16339\n\n\n0000001\n極洋\n2008/03\n10\n1\n12\n11\n235341\n147767\n1497\n57373\n16873\n\n\n0000001\n極洋\n2009/03\n10\n1\n12\n11\n235341\n147554\n1587\n61184\n17839\n\n\n\n\n\n\nより詳細な構造を理解するためには、str()関数やdplyr::glimpse()関数を使います。 基本関数str()だと、\n\nstr(df)\n\nspc_tbl_ [44,527 × 12] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ 会社コード                    : chr [1:44527] \"0000001\" \"0000001\" \"0000001\" \"0000001\" ...\n $ 企業名                        : chr [1:44527] \"極洋\" \"極洋\" \"極洋\" \"極洋\" ...\n $ 決算期                        : chr [1:44527] \"2006/03\" \"2007/03\" \"2008/03\" \"2009/03\" ...\n $ 決算種別                      : num [1:44527] 10 10 10 10 10 10 10 10 10 10 ...\n $ 連結基準                      : num [1:44527] 1 1 1 1 1 1 1 1 1 1 ...\n $ 決算月数                      : num [1:44527] 12 12 12 12 12 12 12 12 12 12 ...\n $ 上場コード                    : num [1:44527] 11 11 11 11 11 11 11 11 11 11 ...\n $ 日経業種コード                : num [1:44527] 235341 235341 235341 235341 235341 ...\n $ 売上高                        : num [1:44527] 152899 157088 147767 147554 145778 ...\n $ 親会社株主に帰属する当期純利益: num [1:44527] 2007 2000 1497 1587 1086 ...\n $ 資産合計                      : num [1:44527] 65049 66459 57373 61184 64301 ...\n $ 株主資本                      : num [1:44527] 14852 16339 16873 17839 18390 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   会社コード = col_character(),\n  ..   企業名 = col_character(),\n  ..   決算期 = col_character(),\n  ..   決算種別 = col_double(),\n  ..   連結基準 = col_double(),\n  ..   決算月数 = col_double(),\n  ..   上場コード = col_double(),\n  ..   日経業種コード = col_double(),\n  ..   売上高 = col_double(),\n  ..   親会社株主に帰属する当期純利益 = col_double(),\n  ..   資産合計 = col_double(),\n  ..   株主資本 = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nのように、変数ごとにデータの型、データの個数、データがいくつか表示されます。 glimpse()関数も同様に、変数ごとにデータの型やデータのいくつかが表示されます。\n\nglimpse(df)\n\nRows: 44,527\nColumns: 12\n$ 会社コード                     &lt;chr&gt; \"0000001\", \"0000001\", \"0000001\", \"00000…\n$ 企業名                         &lt;chr&gt; \"極洋\", \"極洋\", \"極洋\", \"極洋\", \"極洋\",…\n$ 決算期                         &lt;chr&gt; \"2006/03\", \"2007/03\", \"2008/03\", \"2009/…\n$ 決算種別                       &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,…\n$ 連結基準                       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ 決算月数                       &lt;dbl&gt; 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,…\n$ 上場コード                     &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,…\n$ 日経業種コード                 &lt;dbl&gt; 235341, 235341, 235341, 235341, 235341,…\n$ 売上高                         &lt;dbl&gt; 152899, 157088, 147767, 147554, 145778,…\n$ 親会社株主に帰属する当期純利益 &lt;dbl&gt; 2007, 2000, 1497, 1587, 1086, 58, 423, …\n$ 資産合計                       &lt;dbl&gt; 65049, 66459, 57373, 61184, 64301, 7692…\n$ 株主資本                       &lt;dbl&gt; 14852, 16339, 16873, 17839, 18390, 1778…\n\n\nこれで、変数の名前やタイプ、どんなデータが入っているのかをサクッと確認しておきましょう。",
    "crumbs": [
      "第2部 データハンドリング",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#データの読み込み",
    "href": "chap09_handling.html#データの読み込み",
    "title": "\n9  データハンドリング\n",
    "section": "\n9.3 データの読み込み",
    "text": "9.3 データの読み込み\n最初にやることは、データを読み込むことです。 データを読み込むには，tidyverseのreadrパッケージのread_csv()関数を使います。 関数名のとおりread_csv関数は，csvファイルをRに読み込む関数です。 csvファイルとは，カンマで区切られたテキストファイルで、次のようなデータとなっています。\n\n会社コード,企業名,決算期,決算種別,連結基準,決算月数,上場コード,日経業種コード,売上高,親会社株主に帰属する当期純利益,資産合計,株主資本\n0000001,極洋,2006/03,10,1,12,11,235341,152899,2007,65049,14852\n0000001,極洋,2007/03,10,1,12,11,235341,157088,2000,66459,16339\n0000001,極洋,2008/03,10,1,12,11,235341,147767,1497,57373,16873\n\ncsvファイルは，MS Excelで作成することができますが、日経NEEDSからダウンロードしたcsvファイルをExcelで開いてしまうと、勝手にいろいろな処理が勝手に行われてしまうので、注意が必要です。\n\n\nread_csv\n\nread_csv()関数の引数は非常に多く、設定次第では効率的に前処理ができますが、ここではシンプルに読み込むだけの方法を使います。 読み込んだデータは、dfという名前のオブジェクトに代入します。\n\ndf &lt;- read_csv(\"https://so-ichi.com/presemi_part_two.csv\")\n\nRows: 44527 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): 会社コード, 企業名, 決算期\ndbl (9): 決算種別, 連結基準, 決算月数, 上場コード, 日経業種コード, 売上高, 親会社株主に帰属する当期純利益, 資産合計, 株主資本...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n結果の1行目にRows: 44527 Columns: 12とあるように、dfには44527行12列のデータが読み込まれています。",
    "crumbs": [
      "第2部 前処理と記述統計量と可視化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#データを確認する",
    "href": "chap09_handling.html#データを確認する",
    "title": "\n11  データハンドリング\n",
    "section": "\n11.4 データを確認する",
    "text": "11.4 データを確認する\nこのdfのクラスを確認してみます。\n\nclass(df)\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\n\nすると、\"spec_tbl_df\"、\"tbl_df\"、\"tbl\"、\"data.frame\"という方が与えられていることがわかります。 ここでは、data.frameであるということだけ覚えておいてください。\n\n\n\nread_csv()関数の引数には、次のようなものがあります。\n\n\nfile: 読み込むファイルの名前、あるいはパス\n\ncol_names: 列名を指定するかどうか\n\ncol_types: 列の型を指定するかどうか\n\nlocale: ファイルのエンコーディングを指定するかどうか\n\nna: 欠損値の文字列を指定するかどうか\n\n読み込んだデータを簡単にチェックする方法として、head()関数があります。 これは、データの先頭の行を表示する関数です。 デフォルトでは、先頭の6行が表示されます。引数nで表示する行数を指定することができます。\n\nhead(df, n = 4)\n\n\n\n\n会社コード\n\n\n企業名\n\n\n決算期\n\n\n決算種別\n\n\n連結基準\n\n\n決算月数\n\n\n上場コード\n\n\n日経業種コード\n\n\n売上高\n\n\n親会社株主に帰属する当期純利益\n\n\n資産合計\n\n\n株主資本\n\n\n\n\n\n0000001\n\n\n極洋\n\n\n2006/03\n\n\n10\n\n\n1\n\n\n12\n\n\n11\n\n\n235341\n\n\n152899\n\n\n2007\n\n\n65049\n\n\n14852\n\n\n\n\n0000001\n\n\n極洋\n\n\n2007/03\n\n\n10\n\n\n1\n\n\n12\n\n\n11\n\n\n235341\n\n\n157088\n\n\n2000\n\n\n66459\n\n\n16339\n\n\n\n\n0000001\n\n\n極洋\n\n\n2008/03\n\n\n10\n\n\n1\n\n\n12\n\n\n11\n\n\n235341\n\n\n147767\n\n\n1497\n\n\n57373\n\n\n16873\n\n\n\n\n0000001\n\n\n極洋\n\n\n2009/03\n\n\n10\n\n\n1\n\n\n12\n\n\n11\n\n\n235341\n\n\n147554\n\n\n1587\n\n\n61184\n\n\n17839\n\n\n\n\n\n\nより詳細な構造を理解するためには、str()関数やdplyr::glimpse()関数を使います。 基本関数str()だと、\n\nstr(df)\n\nspc_tbl_ [44,527 × 12] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ 会社コード                    : chr [1:44527] \"0000001\" \"0000001\" \"0000001\" \"0000001\" ...\n $ 企業名                        : chr [1:44527] \"極洋\" \"極洋\" \"極洋\" \"極洋\" ...\n $ 決算期                        : chr [1:44527] \"2006/03\" \"2007/03\" \"2008/03\" \"2009/03\" ...\n $ 決算種別                      : num [1:44527] 10 10 10 10 10 10 10 10 10 10 ...\n $ 連結基準                      : num [1:44527] 1 1 1 1 1 1 1 1 1 1 ...\n $ 決算月数                      : num [1:44527] 12 12 12 12 12 12 12 12 12 12 ...\n $ 上場コード                    : num [1:44527] 11 11 11 11 11 11 11 11 11 11 ...\n $ 日経業種コード                : num [1:44527] 235341 235341 235341 235341 235341 ...\n $ 売上高                        : num [1:44527] 152899 157088 147767 147554 145778 ...\n $ 親会社株主に帰属する当期純利益: num [1:44527] 2007 2000 1497 1587 1086 ...\n $ 資産合計                      : num [1:44527] 65049 66459 57373 61184 64301 ...\n $ 株主資本                      : num [1:44527] 14852 16339 16873 17839 18390 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   会社コード = col_character(),\n  ..   企業名 = col_character(),\n  ..   決算期 = col_character(),\n  ..   決算種別 = col_double(),\n  ..   連結基準 = col_double(),\n  ..   決算月数 = col_double(),\n  ..   上場コード = col_double(),\n  ..   日経業種コード = col_double(),\n  ..   売上高 = col_double(),\n  ..   親会社株主に帰属する当期純利益 = col_double(),\n  ..   資産合計 = col_double(),\n  ..   株主資本 = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nのように、変数ごとにデータの型、データの個数、データがいくつか表示されます。 glimpse()関数も同様に、変数ごとにデータの型やデータのいくつかが表示されます。\n\nglimpse(df)\n\nRows: 44,527\nColumns: 12\n$ 会社コード                     &lt;chr&gt; \"0000001\", \"0000001\", \"0000001\", \"00000…\n$ 企業名                         &lt;chr&gt; \"極洋\", \"極洋\", \"極洋\", \"極洋\", \"極洋\",…\n$ 決算期                         &lt;chr&gt; \"2006/03\", \"2007/03\", \"2008/03\", \"2009/…\n$ 決算種別                       &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,…\n$ 連結基準                       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ 決算月数                       &lt;dbl&gt; 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,…\n$ 上場コード                     &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,…\n$ 日経業種コード                 &lt;dbl&gt; 235341, 235341, 235341, 235341, 235341,…\n$ 売上高                         &lt;dbl&gt; 152899, 157088, 147767, 147554, 145778,…\n$ 親会社株主に帰属する当期純利益 &lt;dbl&gt; 2007, 2000, 1497, 1587, 1086, 58, 423, …\n$ 資産合計                       &lt;dbl&gt; 65049, 66459, 57373, 61184, 64301, 7692…\n$ 株主資本                       &lt;dbl&gt; 14852, 16339, 16873, 17839, 18390, 1778…\n\n\nこれで、変数の名前やタイプ、どんなデータが入っているのかをサクッと確認しておきましょう。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#データの整理加工",
    "href": "chap09_handling.html#データの整理加工",
    "title": "\n9  データハンドリング\n",
    "section": "\n9.5 データの整理・加工",
    "text": "9.5 データの整理・加工\nデータの整理・加工には、dplyrパッケージの関数を使います。 dplyrパッケージは、データの整理・加工に特化したパッケージで、tidyverseパッケージに含まれています。 ここからは，基本的にパイプ演算子を使います。 dplyrパッケージの関数は，パイプ演算子を使って処理をつなげることで，データの整理・加工の処理が分かりやすくなります。\n\n9.5.1 select()関数\nselect()関数は、データの変数を選択する関数です。\n\n\nselect関数\n\n引数には、選択したい変数名を直接していするか、以下の関数をつかって変数名の一部を指定することができます。\n\n\nstarts_with() : 指定した文字列で始まる変数\n\nends_with() : 指定した文字列で終わる変数\n\n複数の変数を具体的に指定する場合は，c()で変数名を指定します。\n先ほど読み込んだdfから，企業名，決算期，売上高の3つの変数を選択する場合は，次のように書きます。 読み込んだデータをdf_saleというオブジェクトに代入します。 基本的に，読み込んだオリジナルのデータは加工せず，加工したデータフレームは新しいオブジェクトに代入していきます。\n\ndf_sale &lt;- df |&gt;\n    select(企業名, 決算期, 売上高, 資産合計)\n\nこれで，4変数からなるdf_saleが作成されました。\n\n9.5.2 filter()関数\nfilter()関数は，データの行(つまり観測値)を抽出する関数です。\n\n\nfilter関数\n\nfilter()関数の引数は，行を抽出する条件式です。 データフレームの章で学習したものと同様に，以下のような条件を指定することで，必要とされる行のみを抽出できます。\n\n\n== や != : 等しいかそれ以外か\n\n&gt;や&gt;= や&lt;や&lt;= : 大小関係\n\n%in% : ベクトルの中に含まれるかどうか\n\nis.na() : 欠損値かどうか\n\nまた条件式を複数指定することもできます。\n\n\n&はAND つまり「かつ」\n\n|はOR つまり「あるいは」\n\nこれらの条件式を組み合わせることで、複雑な条件を指定することができます。 例えば，先ほど作成したdf_saleから，トヨタ自動車で，かつ売上高が30兆円以上のデータを抽出する場合，\n\ndf_sale_toyota &lt;- df_sale |&gt;\n    filter(企業名 == \"トヨタ自動車\" & 売上高 &gt;= 3e7)\ndf_sale_toyota\n\n\n\n\n企業名\n\n\n決算期\n\n\n売上高\n\n\n資産合計\n\n\n\n\n\nトヨタ自動車\n\n\n2019/03\n\n\n30225681\n\n\n51936949\n\n\n\n\nトヨタ自動車\n\n\n2022/03\n\n\n31379507\n\n\n67688771\n\n\n\n\n\n\nのように書きます。 財務データは単位が100万円なので，30兆円は30000000となりますが，ゼロが多すぎて一見何円か分からないので，指数表記の3e7としています。 これは3 \\times 10^7という意味で，3の後ろにゼロが7こあるという意味です。\nfilter()関数を使った結果，売上高が30兆円以上だった年度が2019年度と2022年度だったことがわかりました。\n\n9.5.3 mutate()関数\nmutate()関数は、データに新しい変数を追加する関数です。\n\n\nmutate関数\n\nすでにある変数を使って新しい変数を作成したり、変数の値を変換したり、新規の変数を追加したりすることができます。\nmutate()関数の引数は、\n\n新しい変数名 = 変数の値を計算する式\n\nとなります。 たとえば，先ほど作成したdf_sale_toyotaのデータを用いて，総資産回転率を計算する場合は，次のように書きます。\n\n\n総資産回転率は，売上高を資産合計で除したものです。\n\ndf_sale_toyota &lt;- df_sale_toyota |&gt;\n    mutate( # 変数の作成\n        総資産回転率 = round(売上高 / 資産合計, digits = 3) # 計算式\n        )\ndf_sale_toyota\n\n\n\n\n企業名\n\n\n決算期\n\n\n売上高\n\n\n資産合計\n\n\n総資産回転率\n\n\n\n\n\nトヨタ自動車\n\n\n2019/03\n\n\n30225681\n\n\n51936949\n\n\n0.58\n\n\n\n\nトヨタ自動車\n\n\n2022/03\n\n\n31379507\n\n\n67688771\n\n\n0.46\n\n\n\n\n\n\nmutate()関数には次のようなオプションも用意されています。\n\n\n.before と .after : 変数を追加する位置を指定\n\n\n.before = 売上高 : 売上高の前に追加\n\n.after = 売上高 : 売上高の後に追加\n\n\n\n.keep : 新しい変数を追加する際に、元の変数を残すかどうか\n\n\nkeep = \"all\" : 元の変数を残す\n\nkeep = \"used\": 使った変数だけ残す\n\nkeep = \"unused\": 変数の作成に使った変数を除外する\n\nkeep = \"none\": 新変数のみを残す\n\n\n\nこれは見た方が早いので、mutate()のヘルプにある例で確認してみましょう。 次のような1行2列のデータフーレムを用意します。\n\n\nコード\n\ndf &lt;- data.frame(x = 1, y = 2)\ndf\n\n\n\n\n結果\n\n\n\n\n\nx\n\n\ny\n\n\n\n\n1\n\n\n2\n\n\n\n\n\n\n\n\n9.5.3.1 mutate()のデフォルト動作\nまずはデフォルトの動作を確認します。\n\n\nコード\n\ndf |&gt; mutate(z = x + y)\n\n\n\n\n結果\n\n\n\n\nx\ny\nz\n\n\n1\n2\n3\n\n\n\n\n\n\n一番右の列にzが追加されました。これがデフォルトの動作となります。\n\n9.5.3.2 .beforeと.after\n\n次に、.before = 1を指定してみます。\n\n\nコード\n\ndf |&gt;\n    mutate(z = x + y, .before = 1) # 1の前に3が追加\n\n\n\n\n結果\n\n\n\n\nz\nx\ny\n\n\n3\n1\n2\n\n\n\n\n\n\n1の前に新変数zが追加されました。 次に、.after = xを指定してみます。\n\n\nコード\n\ndf |&gt;\n    mutate(z = x + y, .after = x) # xの後に3が追加\n\n\n\n\n結果\n\n\n\n\nx\nz\ny\n\n\n1\n3\n2\n\n\n\n\n\n\nxの後に新変数zが追加されました。 このように、.beforeと.afterを使うことで、新変数を追加する位置を指定することができます。\n\n9.5.3.3 .keep\n\n最後に、.keepを指定してみます。 確認ように，次のような1行4列のデータフーレムを用意します。\n\n\nコード\n\ndf &lt;- data.frame( # x,y,a,bの４変数\n    x = 1,\n    y = 2,\n    a = \"a\",\n    b = \"b\"\n    )\ndf\n\n\n\n\n結果\n\n\n\n\nx\ny\na\nb\n\n\n1\n2\na\nb\n\n\n\n\n\n\nこちらもデフォルトの動作から確認していきます。\n\n\nコード\n\ndf |&gt;\n    mutate(z = x + y, .keep = \"all\") # デフォルトの動作\n\n\n\n\n結果\n\n\n\n\nx\ny\na\nb\nz\n\n\n1\n2\na\nb\n3\n\n\n\n\n\n\n新変数zが一番右に追加され、もともとの変数もすべて残っています。 これがデフォルトの動作となります。\n次に、.keep = \"used\"を指定してみます。\n\n\nコード\n\ndf |&gt;\n    mutate(z = x + y, .keep = \"used\") # 計算に使わなかった変数が除外\n\n\n\n\n結果\n\n\n\n\nx\ny\nz\n\n\n1\n2\n3\n\n\n\n\n\n\n新変数zとそれを作成するために使った変数xとyが残り、 計算に使われなかった変数aとbが除外されています。 新変数作成に用いられない変数を一括で除外したいときは、.keep = \"used\"を指定します。\n次に、.keep = \"unused\"を指定してみます。\n\n\nコード\n\ndf |&gt;\n    mutate(z = x + y, .keep = \"unused\") # 計算に使わなかった変数が除外\n\n\n\n\n結果\n\n\n\n\na\nb\nz\n\n\na\nb\n3\n\n\n\n\n\n\n新変数zを作成するために使ったxとyが除外されています。 新しい変数を作成したあとに、計算の元になった変数を使わない場合は、.keep = \"unused\"を指定するとよいでしょう。\n最後に、.keep = \"none\"を指定してみます。\n\n\nコード\n\ndf |&gt;\n    mutate(z = x + y, .keep = \"none\") # 計算に使わなかった変数が除外\n\n\n\n\n結果\n\n\n\n\nz\n\n\n3\n\n\n\n\n\n\n.keep = \"none\"を指定すると、mutate()で新たに作成した変数のみが残り、元の変数はすべて除外されます。 新変数以外は必要ない、という場合は.keep = \"none\"を指定するとよいでしょう。\n\n9.5.4 group_by()とsummarise()\n\n\n\ngroup_byとsummarise",
    "crumbs": [
      "第2部 前処理と記述統計量と可視化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#pcを立ち上げる",
    "href": "chap09_handling.html#pcを立ち上げる",
    "title": "\n11  データハンドリング\n",
    "section": "\n11.2 PCを立ち上げる",
    "text": "11.2 PCを立ち上げる\nまずは，VS CodeやRStudioを起動します。\n\nVS Codeの場合\n\nフォルダを開く\n編集したいファイルを開く\n\nlibrary()で必要なパッケージを読み込む\ncsvファイルを読み込む\n作業開始\n\n\nRstudioの場合\n\nプロジェクトを開く\n編集したいファイルを開く\n\nlibrary()で必要なパッケージを読み込む\ncsvファイルを読み込む\n作業開始\n\n\n\nとなります。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#データの読み込む",
    "href": "chap09_handling.html#データの読み込む",
    "title": "\n11  データハンドリング\n",
    "section": "\n11.3 データの読み込む",
    "text": "11.3 データの読み込む\n最初にやることは、データを読み込むことです。 データを読み込むには，tidyverseのreadrパッケージのread_csv()関数を使います。 関数名のとおりread_csv関数は，csvファイルをRに読み込む関数です。 csvファイルとは，カンマで区切られたテキストファイルで、次のようなデータとなっています。\n会社コード,企業名,決算期,決算種別,連結基準,決算月数,上場コード,日経業種コード,売上高,親会社株主に帰属する当期純利益,資産合計,株主資本\n0000001,極洋,2006/03,10,1,12,11,235341,152899,2007,65049,14852\n0000001,極洋,2007/03,10,1,12,11,235341,157088,2000,66459,16339\n0000001,極洋,2008/03,10,1,12,11,235341,147767,1497,57373,16873\ncsvファイルは，MS Excelで作成することができますが、日経NEEDSからダウンロードしたcsvファイルをExcelで開いてしまうと、勝手にいろいろな処理が勝手に行われてしまうので、注意が必要です。\n\n\nread_csv\n\nread_csv()関数の引数は非常に多く、設定次第では効率的に前処理ができますが、ここではシンプルに読み込むだけの方法を使います。 読み込んだデータは、dfという名前のオブジェクトに代入します。\n\ndf &lt;- read_csv(\"https://so-ichi.com/presemi_part_two.csv\")\n\nRows: 44527 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): 会社コード, 企業名, 決算期\ndbl (9): 決算種別, 連結基準, 決算月数, 上場コード, 日経業種コード, 売上高, 親会社株主に帰属する当期純利益, 資産合計, 株主資本...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n結果の1行目にRows: 44527 Columns: 12とあるように、dfには44527行12列のデータが読み込まれています。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_handling.html#データの整理加工する",
    "href": "chap09_handling.html#データの整理加工する",
    "title": "\n11  データハンドリング\n",
    "section": "\n11.5 データの整理・加工する",
    "text": "11.5 データの整理・加工する\nデータの整理・加工には、dplyrパッケージの関数を使います。 dplyrパッケージは、データの整理・加工に特化したパッケージで、tidyverseパッケージに含まれています。 ここからは，基本的にパイプ演算子を使います。 dplyrパッケージの関数は，パイプ演算子を使って処理をつなげることで，データの整理・加工の処理が分かりやすくなります。\n\n11.5.1 select()関数\nselect()関数は、データの変数を選択する関数です。\n\n\nselect関数\n\n引数には、選択したい変数名を直接していするか、以下の関数をつかって変数名の一部を指定することができます。\n\n\nstarts_with() : 指定した文字列で始まる変数\n\nends_with() : 指定した文字列で終わる変数\n\n複数の変数を具体的に指定する場合は，c()で変数名を指定します。\n先ほど読み込んだdfから，企業名，決算期，売上高の3つの変数を選択する場合は，次のように書きます。 読み込んだデータをdf_saleというオブジェクトに代入します。 基本的に，読み込んだオリジナルのデータは加工せず，加工したデータフレームは新しいオブジェクトに代入していきます。\n\ndf_sale &lt;- df |&gt;\n    select(企業名, 決算期, 売上高, 資産合計)\n\nこれで，4変数からなるdf_saleが作成されました。\n\n11.5.2 filter()関数\nfilter()関数は，データの行(つまり観測値)を抽出する関数です。\n\n\nfilter関数\n\nfilter()関数の引数は，行を抽出する条件式です。 データフレームの章で学習したものと同様に，以下のような条件を指定することで，必要とされる行のみを抽出できます。\n\n\n== や != : 等しいかそれ以外か\n\n&gt;や&gt;= や&lt;や&lt;= : 大小関係\n\n%in% : ベクトルの中に含まれるかどうか\n\nis.na() : 欠損値かどうか\n\nまた条件式を複数指定することもできます。\n\n\n&はAND つまり「かつ」\n\n|はOR つまり「あるいは」\n\nこれらの条件式を組み合わせることで、複雑な条件を指定することができます。 例えば，先ほど作成したdf_saleから，トヨタ自動車で，かつ売上高が30兆円以上のデータを抽出する場合，\n\ndf_sale_toyota &lt;- df_sale |&gt;\n    filter(企業名 == \"トヨタ自動車\" & 売上高 &gt;= 3e7)\ndf_sale_toyota\n\n\n\n\n企業名\n\n\n決算期\n\n\n売上高\n\n\n資産合計\n\n\n\n\n\nトヨタ自動車\n\n\n2019/03\n\n\n30225681\n\n\n51936949\n\n\n\n\nトヨタ自動車\n\n\n2022/03\n\n\n31379507\n\n\n67688771\n\n\n\n\n\n\nのように書きます。 財務データは単位が100万円なので，30兆円は30000000となりますが，ゼロが多すぎて一見何円か分からないので，指数表記の3e7としています。 これは3 \\times 10^7という意味で，3の後ろにゼロが7こあるという意味です。\nfilter()関数を使った結果，売上高が30兆円以上だった年度が2019年度と2022年度だったことがわかりました。\n\n11.5.3 mutate()関数\nmutate()関数は、データに新しい変数を追加する関数です。\n\n\nmutate関数\n\nすでにある変数を使って新しい変数を作成したり、変数の値を変換したり、新規の変数を追加したりすることができます。\nmutate()関数の引数は、\n\n新しい変数名 = 変数の値を計算する式\n\nとなります。 たとえば，先ほど作成したdf_sale_toyotaのデータを用いて，総資産回転率を計算する場合は，次のように書きます。\n\n\n総資産回転率は，売上高を資産合計で除したものです。\n\ndf_sale_toyota &lt;- df_sale_toyota |&gt;\n    mutate( # 変数の作成\n        総資産回転率 = round(売上高 / 資産合計, digits = 3) # 計算式\n        )\ndf_sale_toyota\n\n\n\n\n企業名\n\n\n決算期\n\n\n売上高\n\n\n資産合計\n\n\n総資産回転率\n\n\n\n\n\nトヨタ自動車\n\n\n2019/03\n\n\n30225681\n\n\n51936949\n\n\n0.58\n\n\n\n\nトヨタ自動車\n\n\n2022/03\n\n\n31379507\n\n\n67688771\n\n\n0.46\n\n\n\n\n\n\nmutate()関数には次のようなオプションも用意されています。\n\n\n.before と .after : 変数を追加する位置を指定\n\n\n.before = 売上高 : 売上高の前に追加\n\n.after = 売上高 : 売上高の後に追加\n\n\n\n.keep : 新しい変数を追加する際に、元の変数を残すかどうか\n\n\nkeep = \"all\" : 元の変数を残す\n\nkeep = \"used\": 使った変数だけ残す\n\nkeep = \"unused\": 変数の作成に使った変数を除外する\n\nkeep = \"none\": 新変数のみを残す\n\n\n\nこれは見た方が早いので、mutate()のヘルプにある例で確認してみましょう。 次のような1行2列のデータフーレムを用意します。\n\n\nコード\n\ndf_ex &lt;- data.frame(x = 1, y = 2)\ndf_ex\n\n\n\n\n結果\n\n\n\n\n\nx\n\n\ny\n\n\n\n\n1\n\n\n2\n\n\n\n\n\n\n\n\n11.5.3.1 mutate()のデフォルト動作\nまずはデフォルトの動作を確認します。\n\n\nコード\n\ndf_ex |&gt; mutate(z = x + y)\n\n\n\n\n結果\n\n\n\n\nx\ny\nz\n\n\n1\n2\n3\n\n\n\n\n\n\n一番右の列にzが追加されました。これがデフォルトの動作となります。\n\n11.5.3.2 .beforeと.after\n\n次に、.before = 1を指定してみます。\n\n\nコード\n\ndf_ex |&gt;\n    mutate(z = x + y, .before = 1) # 1の前に3が追加\n\n\n\n\n結果\n\n\n\n\nz\nx\ny\n\n\n3\n1\n2\n\n\n\n\n\n\n1の前に新変数zが追加されました。 次に、.after = xを指定してみます。\n\n\nコード\n\ndf_ex |&gt;\n    mutate(z = x + y, .after = x) # xの後に3が追加\n\n\n\n\n結果\n\n\n\n\nx\nz\ny\n\n\n1\n3\n2\n\n\n\n\n\n\nxの後に新変数zが追加されました。 このように、.beforeと.afterを使うことで、新変数を追加する位置を指定することができます。\n\n11.5.3.3 .keep\n\n最後に、.keepを指定してみます。 確認ように，次のような1行4列のデータフーレムを用意します。\n\n\nコード\n\ndf_ex &lt;- data.frame( # x,y,a,bの４変数\n    x = 1,\n    y = 2,\n    a = \"a\",\n    b = \"b\"\n    )\ndf_ex\n\n\n\n\n結果\n\n\n\n\nx\ny\na\nb\n\n\n1\n2\na\nb\n\n\n\n\n\n\nこちらもデフォルトの動作から確認していきます。\n\n\nコード\n\ndf_ex |&gt;\n    mutate(z = x + y, .keep = \"all\") # デフォルトの動作\n\n\n\n\n結果\n\n\n\n\nx\ny\na\nb\nz\n\n\n1\n2\na\nb\n3\n\n\n\n\n\n\n新変数zが一番右に追加され、もともとの変数もすべて残っています。 これがデフォルトの動作となります。\n次に、.keep = \"used\"を指定してみます。\n\n\nコード\n\ndf_ex |&gt;\n    mutate(z = x + y, .keep = \"used\") # 計算に使わなかった変数が除外\n\n\n\n\n結果\n\n\n\n\nx\ny\nz\n\n\n1\n2\n3\n\n\n\n\n\n\n新変数zとそれを作成するために使った変数xとyが残り、 計算に使われなかった変数aとbが除外されています。 新変数作成に用いられない変数を一括で除外したいときは、.keep = \"used\"を指定します。\n次に、.keep = \"unused\"を指定してみます。\n\n\nコード\n\ndf_ex |&gt;\n    mutate(z = x + y, .keep = \"unused\") # 計算に使わなかった変数が除外\n\n\n\n\n結果\n\n\n\n\na\nb\nz\n\n\na\nb\n3\n\n\n\n\n\n\n新変数zを作成するために使ったxとyが除外されています。 新しい変数を作成したあとに、計算の元になった変数を使わない場合は、.keep = \"unused\"を指定するとよいでしょう。\n最後に、.keep = \"none\"を指定してみます。\n\n\nコード\n\ndf_ex |&gt;\n    mutate(z = x + y, .keep = \"none\") # 計算に使わなかった変数が除外\n\n\n\n\n結果\n\n\n\n\nz\n\n\n3\n\n\n\n\n\n\n.keep = \"none\"を指定すると、mutate()で新たに作成した変数のみが残り、元の変数はすべて除外されます。 新変数以外は必要ない、という場合は.keep = \"none\"を指定するとよいでしょう。\n\n11.5.4 group_by()とsummarise()\n\n\n11.5.4.1 group_by()関数\ngroup_by()関数は、データをグループ化する関数です。 ある変数がカテゴリー変数となっている場合に，そのカテゴリーごとにデータ処理を行うために使います。 基本的には，group_by()関数でグループ化した後に，summarise()関数で集約することになります。\n\n\ngroup_byとsummarise\n\ngroup_by()関数の引数は，グループ化する変数名です。\n\ngroup_by(グループ化する変数名)\n\nオプションとして，.addと.dropを指定することができます。 デフォルトでは，.add = FALSEと.drop = TRUEとなっています。 .addは，既存のグループに新しいグループを追加するかどうかを指定します。 .dropは，既存のグループを削除するかどうかを指定します。\n\n11.5.4.2 summarise()関数\nsummarise()関数の引数は，集約する変数名です。 mutate()関数と同じように新しい変数を作成するのですが，mutate()関数と違って，集約された値が作成されます。 そのため，summarise()関数は，mutate()関数と違って，データの行数が減ることに注意してください。\nsummarise()関数の引数は，\n\n新しい変数名 = 集約関数(集約する変数名)\n\nとなります。 集約関数には，mean()やmedian()，sd()などの統計量を計算する関数を指定します。 もちろん，trimやna.rmなどのオプションも指定することができます。\nまた，summarise()関数のオプションとして，.groupsを指定することができます。 .groupsは，集約後のデータの行数を指定します。\n\n\n.groups = \"drop\" : 集約後のデータの行数を指定しない\n\n.groups = \"keep\" : 集約後のデータの行数を指定する\n\n.groups = \"rows\" : 集約後のデータの行数を指定する\n\n.groups = \"drop_last\" : 集約後のデータの行数を指定する\n\n.groups = \"keep_last\" : 集約後のデータの行数を指定する\n\n.groups = \"rows_last\" : 集約後のデータの行数を指定する\n\n.groups = \"drop_first\" : 集約後のデータの行数を指定する\n\nこれも具体例を見ながら確認してみましょう。\n\n11.5.4.3 group_by()とsummarise()の具体例\n上で作成したdfを用いて，産業別の売上高平均を表す表を作成してみましょう。 手順としては，\n\n産業中分類を表す変数を作成し，\n産業中分類ごとにグループ化し，\nグループごとに平均売上高を計算し，\n平均売上高を大きい順(降順)に並び替える，\n\n\n\nデータフレームを特定の変数の値に基づいて並び替えるには，arrange()関数を使います。 arrange()関数はデフォルトで昇順に並び替えるので，降順に並び替える場合は，desc()関数を使います。 したがって，ここでは，arrange(desc(平均売上高))となります。\nとなります。\n\n\n日経業種コードは，6ケタの数値で出来ており，最初の1ケタは大分類，次の2ケタは中分類，最後の3ケタが小分類を表しています。 中分類を表すカテゴリー変数を作りたいので，substr()関数を使って，日経業種コードの2ケタ目と3ケタ目を抽出します。 substr(文字列，開始位置，終了位置)という関数で，文字列の指定した位置の文字を抽出することができます。\n\ndf |&gt;\n    mutate( # substr()で産業中分類を作成\n        産業中分類 = substr(日経業種コード, 2, 3)\n        ) |&gt;\n    group_by(産業中分類) |&gt; # 産業中分類ごとにグループ化\n    summarise( # 平均売上高を計算\n        平均売上高 = mean(売上高, na.rm = TRUE) # 平均売上高を計算\n        ) |&gt;\n    arrange(desc(平均売上高)) |&gt; # 平均売上高で降順に並び替え\n    head(5) |&gt; # 上位5社を表示\n    kable(format.args = list(big.mark = \",\")) |&gt; # 3桁ごとにカンマを表示\n    kable_styling(full_width = FALSE)  # 表の幅を自動調整\n\n\n\n産業中分類\n平均売上高\n\n\n\n11\n1,635,554.6\n\n\n67\n1,544,265.2\n\n\n27\n1,117,692.0\n\n\n65\n1,048,226.6\n\n\n61\n733,240.6\n\n\n\n\n\n日経産業中分類の11は石油，67は電力，27は自動車・自動車部品，65は通信，61は空輸を表しています。\n各種オプションの効果を確認するために，group_by()とsummarise()のヘルプにある例を確認してみましょう。\n\n11.5.4.4 group_by()のオプション\n練習用データmtcarsを用いて，group_by()のオプションを確認してみましょう。\n\n\nmtcarsは32行11列のデータフレームであり，変数として，\"mpg\",\"cyl\",\"disp\",\"hp\",\"drat\",\"wt\",\"qsec\",\"vs\",\"am\",\"gear\",\"carb\"をもっています。 mpgは燃費，cylはシリンダー数，dispは排気量，hpは馬力，dratは変速機のギア比，wtは重量，qsecは1/4マイル走のタイム，vsはV型エンジンか直列エンジンか，amは変速機が自動か手動か，gearは変速機のギア数，carbはキャブレターの数を表しています。\nシリンダー数でグループ化したものをby_cylというオブジェクトに代入します。\n\nby_cyl &lt;- mtcars |&gt; group_by(cyl)\nglimpse(by_cyl)\n\nRows: 32\nColumns: 11\nGroups: cyl [3]\n$ mpg  &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…\n$ cyl  &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…\n$ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…\n$ hp   &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…\n$ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…\n$ wt   &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…\n$ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…\n$ vs   &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…\n$ am   &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…\n$ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…\n$ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…\n\n\n出力の3行目にGroups: cyl [3]とあるように，cylでグループ化されていることがわかります。 このグループごとに，排気量dispと馬力hpの平均を計算してみましょう。\n\nby_cyl |&gt; summarise(\n  disp = mean(disp),\n  hp = mean(hp)\n)\n\n\n\n\ncyl\n\n\ndisp\n\n\nhp\n\n\n\n\n\n4\n\n\n105.14\n\n\n82.64\n\n\n\n\n6\n\n\n183.31\n\n\n122.29\n\n\n\n\n8\n\n\n353.10\n\n\n209.21\n\n\n\n\n\n\n3グループごとに2変数の平均を計算したので，3行3列のデータフレームが作成されました。 次に，max()関数を使ってグループ内で最大の排気量を持つデータを抽出してみましょう。\n\nby_cyl |&gt;\n  filter(\n    disp == max(disp) # 最大の排気量を持つデータを抽出\n    ) |&gt; kable()\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\n10.4\n8\n472.0\n205\n2.93\n5.250\n17.98\n0\n0\n3\n4\n\n\n\n\n\n3つのグループ内で最大のdispをもつ行がfilter()により抽出され，データフレームが3行になっていことが分かります。\n\nグルーピング化を解除する効果について確認してみましょう。 次のように，vsとamでグループ化したby_vs_amを作成し，n()を使ってグループごとのデータ数を計算します。\n\nby_vs_am &lt;- mtcars |&gt;\n    group_by(vs, am) # vsとamでグループ化\nby_vs &lt;- by_vs_am |&gt;\n    summarise(n = n()) # グループ内のデータ数を計算\n\n`summarise()` has grouped output by 'vs'. You can override using the `.groups`\nargument.\n\n\n英語のメッセージが出力されました。 メッセージの内容は，「summarise()関数は，vsでグループ化されたデータを出力しているので，グループ化を上書きしたいなら，.groups引数を使え」ということです。\n作成したby_vsの中を確認してみましょう。\n\ngroup_vars(by_vs) # グループ数\n\n[1] \"vs\"\n\nby_vs |&gt; kable()\n\n\n\nvs\nam\nn\n\n\n\n0\n0\n12\n\n\n0\n1\n6\n\n\n1\n0\n7\n\n\n1\n1\n7\n\n\n\n\n\nグループがvsとなっており，amでのグループ化が行われていないことがわかります。 そのため，\n\nby_vs |&gt; summarise(n = sum(n))\n\n\n\n\nvs\n\n\nn\n\n\n\n\n\n0\n\n\n18\n\n\n\n\n1\n\n\n14\n\n\n\n\n\n\nとすると，vsごとの合計データ数が集計されています。 グループ化を解除するには，ungroup()関数を使います。\n\nby_vs |&gt;\n  ungroup() |&gt; #グループ化を解除\n  summarise(n = sum(n)) |&gt;\n  kable(table.attr = \"style='width:40%;'\") |&gt; kable_styling(full_width = FALSE)\n\n\n\nn\n\n\n32\n\n\n\n\nグループが解除されたので，データの個数はデータフレーム全体のデータ数を表します。\n\nmtcars |&gt; nrow()\n\n[1] 32\n\n\nデフォルトでは，group_by()は既存のグループ化を上書きします。\n\nby_cyl |&gt; # cylでグループ化済み\n  group_by(vs, am) |&gt; # vsとamでグループ化\n  group_vars() # グループ化されている変数を確認\n\n[1] \"vs\" \"am\"\n\n\ncylでグループ化されていたby_cylが，vsとamでグループで上書きされています。 add = TRUEを指定すると，既存のグループ化に新しいグループ化を追加します。\n\nby_cyl |&gt;\n  group_by(vs, am, .add = TRUE) |&gt;\n  group_vars()\n\n[1] \"cyl\" \"vs\"  \"am\" \n\n\nグループがcyl，vs，amの3つになっていることがわかります。\ngroup_by()関数には，式を指定することもできます。 次の例では，vsとamの値を足した値でグループ化しています。\n\nmtcars |&gt;\n  group_by(vsam = vs + am) |&gt;\n  head() |&gt;\n  kable() |&gt; kable_styling(font_size = 20) |&gt;\n  column_spec(12, bold = TRUE, background = 'mistyrose')\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\nvsam\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n1\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n1\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n2\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n1\n\n\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n0\n\n\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n1\n\n\n\n\n\n\nmutate()はグループ化されていないデータに対して常に実行されるので，行数は変わりません。\n次の例では，group_by()にhp_cut = cut(hp,3)という式を指定することで，hpを3等分したカテゴリーを表す変数hp_cutを作成しています。\n\nby_hp3 &lt;- mtcars |&gt;\n  group_by(vs) |&gt;\n  group_by(hp_cut = cut(hp, 3))\nby_hp3 |&gt;\n  head() |&gt; # 先頭６行のみ表示\n  kable() |&gt; # 表形式\n  kable_styling(font_size = 20) |&gt; # フォントサイズ\n  column_spec(12, bold = TRUE, background = 'mistyrose')\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\nhp_cut\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n(51.7,146]\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n(51.7,146]\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n(51.7,146]\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n(51.7,146]\n\n\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n(146,241]\n\n\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n(51.7,146]\n\n\n\n\n\nby_hp3の一番右の列にhp_cutが追加され、(51.7,146]や(146,241]といったカテゴリーが作成されているのがわかります。 このhp_cutの中に含まれるデータ数をtable()関数で確認してみましょう。\n\ntable(by_hp3$hp_cut)\n\n\n(51.7,146]  (146,241]  (241,335] \n        17         11          4 \n\n\nby_hp3のhp_cutが3つのグループに分けられていることがわかります。\nグループごとにmutate()を実行したい場合は，明示的にmutate()を使う必要があります。 たとえば，vsの値(0か1)ごとにhpを3等分したカテゴリーを表す変数hp_cutを作成するには，次のように書きます。\n\nby_hp6 &lt;- mtcars |&gt;\n  group_by(vs) |&gt; # vsでグループ化\n  mutate(hp_cut = cut(hp, 3)) |&gt; # hpを3等分したカテゴリーを表す変数hp_cutを作成\n  group_by(hp_cut)\n\nby_hp6 |&gt;\n  head() |&gt;\n  kable() |&gt;\n  kable_styling(font_size = 20) # hp_cutでグループ化\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\nhp_cut\n\n\n\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n(90.8,172]\n\n\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n(90.8,172]\n\n\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n(75.7,99.3]\n\n\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n(99.3,123]\n\n\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n(172,254]\n\n\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n(99.3,123]\n\n\n\n\n\nby_hp6の一番右の列にhp_cutが追加され、(51.7,146]や(146,241]といったカテゴリーが作成されているのがわかります。 先と同様に、hp_cutの中に含まれるデータ数をtable()関数で確認してみましょう。\n\ntable(by_hp6$hp_cut)\n\n\n (90.8,172]   (172,254]   (254,335] (51.9,75.7] (75.7,99.3]  (99.3,123] \n          5          11           2           5           3           6 \n\n\nつぎはvsとhp_cutでグループ化したため、6グループに分けられていることがわかります。\n\ngroup_by()関数のオプション.dropは，グループ化されたデータの行数が0になった場合に，グループを削除するかどうかを指定します。 各グループがどの行を含んでいるのかをgroup_rows()で確認します。\n\ntbl &lt;- tibble(\n  x = 1:10, # 1から10の数列\n  y = factor(\n    rep(c(\"a\", \"c\"), each  = 5), # \"a\"と\"c\"を5回繰り返す\n    levels = c(\"a\", \"b\", \"c\") # レベルには\"a\"と\"b\"と\"c\"を指定\n    ) # レベルを指定\n)\ntbl |&gt; kable() |&gt; kable_styling(font_size = 20)\n\n\n\nx\ny\n\n\n\n1\na\n\n\n2\na\n\n\n3\na\n\n\n4\na\n\n\n5\na\n\n\n6\nc\n\n\n7\nc\n\n\n8\nc\n\n\n9\nc\n\n\n10\nc\n\n\n\n\n\ntblのカテゴリー数が3となっていますが，カテゴリー変数yにはaとcしか存在しない，というデータを作りました。 そのカテゴリー変数yのグループごとの行数を確認してみましょう。\n\n\nヘルプにあるとおりにgroup_rows()を使うとエラーがでますが、これはgroup_rows()がdplyrパッケージにあるものではなく基本関数group_rows()を使っているためです。 したがって，dplyr::group_rows()とすることでエラーを回避できます。\n\ntbl |&gt;\n  group_by(y, .drop = FALSE) |&gt;\n  dplyr::group_rows()\n\n&lt;list_of&lt;integer&gt;[3]&gt;\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\ninteger(0)\n\n[[3]]\n[1]  6  7  8  9 10\n\n\n出力がリスト型になっており，[[2]]の結果がinteger(0)となっています。\n\n11.5.5 group_by()とmutate()\n\ngroup_by()を用いてグループ化することで，mutate()関数を使ってグループごとに新しい変数を作成することができます。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データハンドリング</span>"
    ]
  },
  {
    "objectID": "chap09_merge.html#データフレームの結合",
    "href": "chap09_merge.html#データフレームの結合",
    "title": "\n10  データの結合\n",
    "section": "\n10.1 データフレームの結合",
    "text": "10.1 データフレームの結合\n次に、よく使うのだけれど、結構ややこしいデータフレームの結合(merge)について説明します。 データフレームの結合には、基本関数のcbind()やrbind()を使うこともできますが、tidyverseのdplyrパッケージのJOIN関数を使うと、より簡単に結合できます。\n日本の自動車メーカーの会計情報を使います。 まずはdata.frame()関数を使って、name，year，saleという3つの変数をもつデータフレームを作成します。\n\n\n本によっては、data.frame()関数の代わりにtibble()関数を使ってデータフレームを作成するようにしているものもあります。 tibble()関数は、data.frame()関数の代わりに使うことができ、作成されるデータフレームにはtibbleというクラスが付与されます。 tibbleクラスのデータフレームは、data.frameクラスのデータフレームと比べて、便利な特徴が与えられていますが、ここでは基本関数data.frame()を使ってデータフレームを作成します。\n\ndf_car &lt;- data.frame( # データフレームを作成\n    name = c(rep(\"トヨタ\",2),rep(\"日産\",2),rep(\"ホンダ\",2)), # 企業名\n    year = rep(c(\"2022\", \"2023\"),3), # 年度\n    sale = c(31379507,37154298,8424585,10596695,14552696,16907725)  # 売上高\n)\ndf_car |&gt; kable() |&gt; kable_styling(font_size = 24)\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの結合</span>"
    ]
  },
  {
    "objectID": "chap09_merge.html#データを縦に結合する",
    "href": "chap09_merge.html#データを縦に結合する",
    "title": "\n10  データの結合\n",
    "section": "\n10.2 データを縦に結合する",
    "text": "10.2 データを縦に結合する\nデータを縦に結合する，ということは，データフレームの行を追加することです。具体的には観測値を追加することになり，変数の数は変わりません。\n\n\n2つのデータフレームを結合して行だけが増える結合を縦結合、 列が増える結合を横結合と呼びます。\nここでは，作成したdf_carに、各社2024年の売上高のデータが入ったデータフレームdf_car_2024を追加したいとします。 2024年度の業績予想データが入ったデータフレームを作成します。\n\ndf_car_2024 &lt;- data.frame(\n    name = c(\"トヨタ\", \"日産\", \"ホンダ\"),\n    year = c(rep(2024,3)),\n    sale = c(38000000, 12400000, 18200000)\n)\ndf_car_2024 |&gt; kable() |&gt; kable_styling(font_size = 24)\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2024\n38000000\n\n\n日産\n2024\n12400000\n\n\nホンダ\n2024\n18200000\n\n\n\n\n\n\n\nデータフレームの縦結合\n\n\n2つのデータフレームを縦に結合するには、基本関数のrbind()を使うか、dplyrパッケージのbind_rows()関数を使います。\n\n10.2.1 rbind()関数の場合\nrbind()関数を使う場合は、以下のようにします。\n\ndf_car_add &lt;- rbind(df_car, df_car_2024)\ndf_car_add |&gt; kable() |&gt;\n    row_spec(7:9, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725\n\n\nトヨタ\n2024\n38000000\n\n\n日産\n2024\n12400000\n\n\nホンダ\n2024\n18200000\n\n\n\n\n\nデータフレームに下から新たなデータが加わっていることが分かります。 たとえ，変数の順番が異なっていたとしても，変数名が一致していれば，簡単にデータを縦に結合することができます。 saleとyearの変数の順番を入れ替えてみます。\n\ndf_car_2 &lt;- data.frame(\n    name = c(\"トヨタ\", \"日産\", \"ホンダ\"),\n    sale = c(38000000, 12400000, 18200000),\n    year = c(rep(2024,3))\n    )\ndf_car_add2 &lt;- rbind(df_car, df_car_2)\ndf_car_add2 |&gt; kable() |&gt;\n    row_spec(7:9, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725\n\n\nトヨタ\n2024\n38000000\n\n\n日産\n2024\n12400000\n\n\nホンダ\n2024\n18200000\n\n\n\n\n\n上手くいきました。 しかし変数の数や名前が一致しないと， match.names(clabs, names(xi)) でエラー:  名前が以前の名前と一致しませんというエラーがでて結合できません。 したがってrbind()関数は変数名と変数の数が一致するデータフレーム同士の縦結合であれば、適切な処理が行われるため、names()関数やdplyr::rename()関数を使って，変数名が一致するように変更しておきましょう。\n\n10.2.2 bind_rows()関数の場合\ndplyrパッケージのbind_rows()関数は、2つのデータフレームの変数名を参照して縦結合をしてくれます。 bind_rows()を使う場合は、以下のようにします。\n\ndf_car |&gt; bind_rows(df_car_2024)",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの結合</span>"
    ]
  },
  {
    "objectID": "chap09_merge.html#データを横に結合する",
    "href": "chap09_merge.html#データを横に結合する",
    "title": "\n10  データの結合\n",
    "section": "\n10.3 データを横に結合する",
    "text": "10.3 データを横に結合する\nデータを横に結合する，とは，データフレームの列を追加することです。具体的には変数を追加することになり，観測値の数は変わりません。 ただ縦の結合とは異なり，横の結合は少し複雑になります。\nデータを横に結合する方法の1つは，基本関数のcbind()を使うことです。 データフレームdf_carに，各社の(親会社株主に帰属する)当期純利益niもデータフレームに追加したいとします。 niを変数とするデータフレームを作成します。\n\ndf_car_ni &lt;- data.frame(\n    name = c(rep(\"トヨタ\",3),rep(\"日産\",3),rep(\"ホンダ\",3)),\n    year = rep(c(\"2022\", \"2023\", \"2024\"),3), # 時点\n    ni = c(2850110, 2451318, 2580000,\n           215533, 221900, 315000,\n           707067, 651416, 800000)\n)\ndf_car_ni |&gt; kable() |&gt; kable_styling(font_size = 24)\n\n\n\nname\nyear\nni\n\n\n\nトヨタ\n2022\n2850110\n\n\nトヨタ\n2023\n2451318\n\n\nトヨタ\n2024\n2580000\n\n\n日産\n2022\n215533\n\n\n日産\n2023\n221900\n\n\n日産\n2024\n315000\n\n\nホンダ\n2022\n707067\n\n\nホンダ\n2023\n651416\n\n\nホンダ\n2024\n800000\n\n\n\n\n\nこれをdf_car_addに右から結合します。\n\n\ncbindによる横結合\n\n\ndf_cbind &lt;- cbind(df_car_add, df_car_ni)\ndf_cbind\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\nname\n\n\nyear\n\n\nni\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\nトヨタ\n\n\n2022\n\n\n2850110\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\nトヨタ\n\n\n2023\n\n\n2451318\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\nトヨタ\n\n\n2024\n\n\n2580000\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n日産\n\n\n2022\n\n\n215533\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n日産\n\n\n2023\n\n\n221900\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n日産\n\n\n2024\n\n\n315000\n\n\n\n\nトヨタ\n\n\n2024\n\n\n38000000\n\n\nホンダ\n\n\n2022\n\n\n707067\n\n\n\n\n日産\n\n\n2024\n\n\n12400000\n\n\nホンダ\n\n\n2023\n\n\n651416\n\n\n\n\nホンダ\n\n\n2024\n\n\n18200000\n\n\nホンダ\n\n\n2024\n\n\n800000\n\n\n\n\n\n\ndf_carの右側にdf_car_niが結合されていることが分かります。 しかし、この結合に問題があることは一目瞭然です。 重複した変数があるうえに、nameやyearの順番がバラバラです。 つまり行が観測値を表しておらず、整然データではなくなりました。\nこの問題を解決するためには、nameとyearの2つの変数をキーとして、データを結合する必要があります。 このような結合をマージと呼びます。以下では、マージの方法を説明します。\n\n10.3.1 JOIN関数を使う\nデータフレームの結合は基本関数でもできますが、tidyverseのdplyrパッケージのJOIN関数が便利です。\n\n10.3.2 JOIN関数\ndplyrパッケージのJOIN関数には、以下の4つがあります。\n\n\ninner_join() : 内部結合\n\nleft_join() : 左外部結合\n\nright_join() : 右外部結合\n\nfull_join() : 完全外部結合\n\nそれぞれの結合の結果をベン図で表すと以下のようになります。\n\n\n結合\n\n結合のイメージ図は以下の通りです(この図は、Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemundによる”R for Data Science”の図を引用しています)。\n\n\n結合結果\n\n内部結合は、2つのデータフレームの共通の変数の値が一致する行のみを抽出するため、結合後のデータフレームが非常に小さくなりがちであるため、ほとんど使用しません。 最も利用する可能性が高いのは、結合元のデータフレームのすべての行を残す左外部結合です。 これはdplyr::left_join()で実行できます。\n\n10.3.2.1 左外部結合\n\n\n左外部結合\n\nleft_join()の引数は、以下の通りです。\n\n\nx : 結合元のデータフレーム\n\ny : 結合するデータフレーム\n\nby : 結合する変数\n\ndf_carとdf_car_niをnameとyearの2つの変数をキーとして左外部結合します。 ここで重要なことは，キーとなる変数で観測値がユニークになっている，ということです。 ここの例だと，nameがトヨタ，yearが2023，という観測値(つまり行)は1つだけになっている，ということです。\n\n\n\n\n\n\n重要\n\n\n\nJOIN関数で2つのデータフレームを結合するときは，1つ以上のキーとなる変数が，結合元のデータフレームと結合するデータフレームの両方に存在し，またキーの値により行が一意に決まる，つまり観測値がユニークになっていることが重要です。\n\n\n\n\n左外部結合\n\ndplyrパッケージのleft_join()関数次のようにします。\n\n\n左外部結合の書き方\n\n\n# nameとyearで左外部結合\ndf_car_left &lt;- df_car_add |&gt; # 結合先\n    left_join(df_car_ni, by = c(\"name\", \"year\")) # 結合元\n# 表にする\ndf_car_left |&gt; kable() |&gt;\n    column_spec(4, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\nni\n\n\n\nトヨタ\n2022\n31379507\n2850110\n\n\nトヨタ\n2023\n37154298\n2451318\n\n\n日産\n2022\n8424585\n215533\n\n\n日産\n2023\n10596695\n221900\n\n\nホンダ\n2022\n14552696\n707067\n\n\nホンダ\n2023\n16907725\n651416\n\n\nトヨタ\n2024\n38000000\n2580000\n\n\n日産\n2024\n12400000\n315000\n\n\nホンダ\n2024\n18200000\n800000\n\n\n\n\n\nこの結果をみると、うえで行ったcbind()関数とは異なり、結合のキーに指定したnameとyearの順番が揃っていることが分かります。\n\n\n左外部結合の結果\n\nここまでで，変数の数と名前が一致するデータフレーム同士の縦結合と，キーとなる変数で観測値がユニークになっているデータフレーム同士の横結合を説明しました。\n次は，観測値が異なるデータフレームの結合や，キーにより観測値がユニークにならないデータフレームの結合について説明します。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの結合</span>"
    ]
  },
  {
    "objectID": "chap09_merge.html#異なるサイズのデータフレームの結合",
    "href": "chap09_merge.html#異なるサイズのデータフレームの結合",
    "title": "\n10  データの結合\n",
    "section": "\n10.4 異なるサイズのデータフレームの結合",
    "text": "10.4 異なるサイズのデータフレームの結合\ndf_car_addとdf_car_niは、同じサイズのデータフレームでしたが、異なるサイズのデータフレームを結合することもできます。 たとえば、元のdf_carに、マツダの2022年と2023年の売上高を追加してみます。\n\ndf_car_mazda &lt;- data.frame(\n    name = c(\"マツダ\", \"マツダ\"),\n    year = c(2022, 2023),\n    sale = c(3120349, 3826752)\n)\ndf_car_mazda &lt;- rbind(df_car,df_car_mazda)\ndf_car_mazda\n\n\n\n\nname\n\n\nyear\n\n\nsale\n\n\n\n\n\nトヨタ\n\n\n2022\n\n\n31379507\n\n\n\n\nトヨタ\n\n\n2023\n\n\n37154298\n\n\n\n\n日産\n\n\n2022\n\n\n8424585\n\n\n\n\n日産\n\n\n2023\n\n\n10596695\n\n\n\n\nホンダ\n\n\n2022\n\n\n14552696\n\n\n\n\nホンダ\n\n\n2023\n\n\n16907725\n\n\n\n\nマツダ\n\n\n2022\n\n\n3120349\n\n\n\n\nマツダ\n\n\n2023\n\n\n3826752\n\n\n\n\n\n\nこれにdf_car_niを左外部結合するとどうなるか確認してみましょう\n\n\nマツダのデータ\n\n\ndf_car_mazda_left &lt;- df_car_mazda |&gt;\n    left_join(df_car_ni, by = c(\"name\", \"year\"))\ndf_car_mazda_left |&gt; kable() |&gt;\n    row_spec(7:8, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\nni\n\n\n\nトヨタ\n2022\n31379507\n2850110\n\n\nトヨタ\n2023\n37154298\n2451318\n\n\n日産\n2022\n8424585\n215533\n\n\n日産\n2023\n10596695\n221900\n\n\nホンダ\n2022\n14552696\n707067\n\n\nホンダ\n2023\n16907725\n651416\n\n\nマツダ\n2022\n3120349\nNA\n\n\nマツダ\n2023\n3826752\nNA\n\n\n\n\n\n左外部結合は，結合元のデータフレームのすべての行を残すため，結合後のデータフレームの行数は結合元のデータフレームの行数と同じになります。 したがって，df_car_mazdaの行数は8行のままで，niという変数が追加されていますが，マツダの2022年と2023年のデータにはNAが入っています。 結合するデーレフレームdf_car_niに入っていた2024年のデータは、結合先のdf_car_mazdaには存在しないためです。 基本的に主となるデータフレームのデータを維持したいことがおおいため，左外部結合を使うことが多いです。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの結合</span>"
    ]
  },
  {
    "objectID": "chap09_merge.html#観測値がユニークでない場合",
    "href": "chap09_merge.html#観測値がユニークでない場合",
    "title": "\n10  データの結合\n",
    "section": "\n10.5 観測値がユニークでない場合",
    "text": "10.5 観測値がユニークでない場合\nキー変数で行がユニークにならないとき，1対多や多対1，多対多の関係があり，結合後のデータフレームの行数が増えることになります。 どのような挙動になるのかを理解して，データフレームの結合を行いましょう。 理想的には，1対1対応となるように，データを整理してから結合するのが望ましいです。\n\n1対多の結合 : 結合するデータフレームがユニークでない\n多対1の場合 : 結合先のデータフレームがユニークでない\n多対多の場合 : どちらのデーレフレームもユニークでない\n\nそれぞれのケースに対して，left_join()関数を適用した結果がどうなるのかを理解しておきましょう。\n\n10.5.1 多対1の結合\n以下の例だと，結合元のデータフレームdf_carには，ホンダの2023年のデータが2つあります。\n\ndf_car_duplicate &lt;- data.frame( # データフレームを作成\n    name = c(rep(\"トヨタ\",2),rep(\"日産\",2),rep(\"ホンダ\",3)),\n    year = c(rep(c(\"2022\", \"2023\"),3), 2023), # 時点\n    sale = c(31379507,37154298,8424585,10596695,14552696,16907725,18706224) # 気温\n)\ndf_car_duplicate |&gt; kable() |&gt;\n    row_spec(7, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\n\n\n\nトヨタ\n2022\n31379507\n\n\nトヨタ\n2023\n37154298\n\n\n日産\n2022\n8424585\n\n\n日産\n2023\n10596695\n\n\nホンダ\n2022\n14552696\n\n\nホンダ\n2023\n16907725\n\n\nホンダ\n2023\n18706224\n\n\n\n\n\nこのデータフレームには，ホンダの2023年のデータが2つあります。 たとえば，IFRS採用直後だと日本基準とIFRSのデータが記載されていることがあり，このように企業名と年度だけでは観測値がユニークにならないことがあります。\nこのデータフレームにdf_car_niを左外部結合するとどうなるか確認してみましょう\n\ndf_car_duplicate_left &lt;- df_car_duplicate |&gt;\n    left_join(df_car_ni, by = c(\"name\", \"year\"))\ndf_car_duplicate_left |&gt; kable() |&gt;\n    row_spec(6:7, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nsale\nni\n\n\n\nトヨタ\n2022\n31379507\n2850110\n\n\nトヨタ\n2023\n37154298\n2451318\n\n\n日産\n2022\n8424585\n215533\n\n\n日産\n2023\n10596695\n221900\n\n\nホンダ\n2022\n14552696\n707067\n\n\nホンダ\n2023\n16907725\n651416\n\n\nホンダ\n2023\n18706224\n651416\n\n\n\n\n\n結合先のデータフレームがキーにでユニークになっていないので，エラーになるかと思いきや，エラーにならずに結合され，ホンダの2023年の2つの観測値に同じ当期純利益の数値が入っています。\n多対1の場合は，結合先のデータフレームのキーが重複している行に，結合元のデータを割り当て，重複分だけ結合後のデータフレームの行数が増えてしまいます。\n\n10.5.2 1対多の結合\n逆のケースもやってみましょう。 結合元のデータフレームはユニークだが，結合するデータフレームがユニークではない場合です。 先ほどの例とは逆に，df_car_niにdf_car_duplicateを左外部結合するとどうなるか確認してみましょう\n\n# 左外部結合\ndf_car_ni_duplicate_left &lt;- df_car_ni |&gt;\n    left_join(df_car_duplicate, by = c(\"name\", \"year\"))\n# 結合後のデータフレーム\ndf_car_ni_duplicate_left |&gt;\n    kable() |&gt;\n    row_spec(c(3,6,10), bold = TRUE, background = 'lightcyan') |&gt;\n    row_spec(8:9, bold = TRUE, background = 'mistyrose')\n\n\n\nname\nyear\nni\nsale\n\n\n\nトヨタ\n2022\n2850110\n31379507\n\n\nトヨタ\n2023\n2451318\n37154298\n\n\nトヨタ\n2024\n2580000\nNA\n\n\n日産\n2022\n215533\n8424585\n\n\n日産\n2023\n221900\n10596695\n\n\n日産\n2024\n315000\nNA\n\n\nホンダ\n2022\n707067\n14552696\n\n\nホンダ\n2023\n651416\n16907725\n\n\nホンダ\n2023\n651416\n18706224\n\n\nホンダ\n2024\n800000\nNA\n\n\n\n\n\n結合元のdf_car_niは2024年のデータがありますが，結合するdf_car_duplicateには2024年のデータがないため，左外部結合したデータフレームの2024年のsaleは欠損値NAになっています(青色の行)。\nまた注目すべきは，結合元のホンダの2023年のniは1つだけだったのにたいして，結合後には2つになっており，そこにsaleが左から結合されています(オレンジの行)。\nつまり、結合先のデータフレームがユニークでない場合、結合元のデータが重複してniの値に入っています。\n\n10.5.3 多対多の結合\n結合先も結合元もユニークでない場合、データフレームを結合しようとすると、Warningがでます。 JOIN関数の引数にrelationship = \"many-to-many\"を設定することで、警告をけすことができます。\n以下では、シンプルなデータフレームを用いて、多対多の結合の例を示します。\n\ndf1 &lt;- tibble(x = 1:3) # ユニーク\ndf2 &lt;- tibble(x = c(1, 1, 2), y = c(\"first\", \"second\", \"third\")) # ユニークでない　\ndf3 &lt;- tibble(x = c(1, 1, 1, 3)) # ユニークでない\n\n\n\n練習用データフレーム\n\ndf1にdf2を左外部結合すると\n\ndf1 |&gt;\n    left_join(df2, join_by(x)) |&gt; # x列がキー\n    kable(align = \"cl\",) |&gt; # センタリング\n    kable_styling(full_width = FALSE)\n\n\n\nx\ny\n\n\n\n1\nfirst\n\n\n1\nsecond\n\n\n2\nthird\n\n\n3\nNA\n\n\n\n\n\n結合キーとなるxに対して、結合先のdf1の1は1つですが、df2の1は2つあるため、1対多の結合となり、結合後はxの1が2行に増え、df2のfirstとsecondの値が入っていることが分かります。\n図で書くとこうなってます。\n\n\n1対多\n\n次に，df3にdf2を左外部結合すると\n\ndf3 |&gt; left_join(df2)\n\nJoining with `by = join_by(x)`\n\n\nWarning in left_join(df3, df2): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\nx\n\n\ny\n\n\n\n\n\n1\n\n\nfirst\n\n\n\n\n1\n\n\nsecond\n\n\n\n\n1\n\n\nfirst\n\n\n\n\n1\n\n\nsecond\n\n\n\n\n1\n\n\nfirst\n\n\n\n\n1\n\n\nsecond\n\n\n\n\n3\n\n\nNA\n\n\n\n\n\n\nwarningsがでます。 このようにレアケースとして多対多関係が予想される場合，relationship = \"many-to-many\"を設定して警告をけしましょう。\n\ndf3 %&gt;% left_join(df2, by = join_by(x), relationship = \"many-to-many\")\n\n\n\n\nx\n\n\ny\n\n\n\n\n\n1\n\n\nfirst\n\n\n\n\n1\n\n\nsecond\n\n\n\n\n1\n\n\nfirst\n\n\n\n\n1\n\n\nsecond\n\n\n\n\n1\n\n\nfirst\n\n\n\n\n1\n\n\nsecond\n\n\n\n\n3\n\n\nNA\n\n\n\n\n\n\n\n\n多対多\n\nこのように，結合するデータフレームのキーとなる変数で観測値がユニークでない場合は，dplyr::left_join()関数は，自動的にデータを補完して結合してしまうため，それを理解して使う必要があります。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの結合</span>"
    ]
  },
  {
    "objectID": "chap09_merge.html#join関数のオプション",
    "href": "chap09_merge.html#join関数のオプション",
    "title": "\n10  データの結合\n",
    "section": "\n10.6 JOIN関数のオプション",
    "text": "10.6 JOIN関数のオプション\nleft_join()の引数には，以下のものが用意されています。\n\nby : 結合する変数を指定する。\njoin_by() : 複数のキーを指定する。変数名を指定する場合は，join_by(a == b, c == d)のようにする。\ncopy : 特殊なときにしか使わないのでここでは無視\nsuffix : 同じ変数名があるときに，結合後の変数名に付ける接尾辞を指定する。デフォルトだとxがつく。\nkeep : 結合キーの保持を決める。デフォルトはnullで，結合先のキー変数のみが残る。trueだと両データフレームのキー変数が保持される。\nna_matches : NAとNaNなどの扱い。デフォルトは同じように処理する。\nmultiple : 結合先の行が結合元に複数マッチする場合の処理を指定する。 結合先の各行に対して，デフォルトのallは、結合元で検出された全てのマッチを返します。これはSQLと同じ動作です。\nunmatched : 結合先の行が結合元にマッチしない場合の処理を指定する。デフォルトはallで，結合元の行を残す。\n\nrelationship : 結合先と結合元のキーの対応関係を指定\n\n\nNULL : デフォルトで，\n\none-to-one : 結合先と結合元のキーの対応関係が1対1のときに使う。\n\none-to-many : 結合元の各行が結合先の最大1行と対応\n\nmany-to-one : 結合先の各行が結合元の最大1行と対応\n\nmany-to-many : 多対多関係が想定されているときに使うらしい。",
    "crumbs": [
      "第2部 前処理と記述統計量",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>データの結合</span>"
    ]
  },
  {
    "objectID": "chap03_code.html#コードの書き方",
    "href": "chap03_code.html#コードの書き方",
    "title": "\n2  コード作成の作法\n",
    "section": "\n2.1 コードの書き方",
    "text": "2.1 コードの書き方\nRに限らず、プログラミング言語では、コードを書くときにいくつかの作法があります。 コードを書き始める前に、これらの作法を知っておくことは、コードを書くときに役立ちます。 作法を守って可読性が高いコードを書くことで、エラーを防ぎつつ、また他人が読んだときにも理解しやすいコードを書くことができます。\n\n2.1.1 半角英数と大文字小文字\nコードを書くときには、半角英数を使うようにします。 直接入力とも呼ばれます。\nまたプログラミング言語では、大文字と小文字を区別します。 つまり、aとAは別の変数として扱われます。 一見、大文字と小文字の見分けが困難な文字もあるため、注意が必要です。\n\nX &lt;- c(1, 2, 3) # 変数Xを作成\nx &lt;- c(1, 2, 3, 4, 5, 6)\nX # どっちか紛らわしい\n\n[1] 1 2 3\n\n\n\n2.1.2 インデントと半角スペース\nコードを書くときには、インデントを揃えるようにします。 インデントとは、行頭の空白のことです。 インデントを揃えることで、どの行がどのブロックに属しているかが一目でわかります。 インデントはTABキーを押すことで入力できます。\nまた、演算子の前後には半角スペースを入れるようにします。半角スペースは無視されるので、コードの実行には影響を与えません。\n\n#インデントを揃えていないし、\n#半角スペースも入れていない例\nif(x&gt;0){\ny&lt;-x*2\nz&lt;-x*3\n}\n\n# インデントを揃えて、半角スペースを入れた例\nif (x &gt; 0) {\n  y &lt;- x * 2\n  z &lt;- x * 3\n}\n# 読みやすいですよね。\n\nコンマの後ろにも半角スペースを入れるようにします。\n\ndice&lt;-c(1,2,3,4,5,6) # 見づらい\ndice &lt;- c(1, 2, 3, 4, 5, 6) # 見やすい\n\n半角スペースと全角スペースを混在させないようにします。 全角スペースは文字として扱われるため、エラーの原因になります。たとえば、次のようなコードはエラーになりますが、発見することが難しいので、注意が必要です。\n\n# 全角スペースや全角のコンマを使っているのでエラーになる\ndice &lt;- c(1、2、　3、 4、 5、 6)\n\n\n2.1.3 コメント\nコードを書くときには、コメントを書くようにします。 コメントとは、コードの中にプログラマーがメモを残すためのものです。 コメントは、コードの実行には影響を与えません。 Rのコメントは、#で始まる行です。\n\n# これはコメントです。\n# この行は実行されません。\ndice &lt;- 1:6 # サイコロを作成\n\nコードを1ヶ月後に見直したとき、自分が何を思ってこのコードを書いたのかを思い出すことは難しいので、コメントは積極的に残すようにしましょう。\nまた，今まで皆さんは間違ったコードを書いてしまったときは，コードを削除していたかもしれませんが，どこが間違っているのか，後で確認できるように，コードは消さずにコメントアウトしておくようにしましょう。\n\ncoin &lt;- c(\"H\", \"T\") # コインを作成\n# mean(coin) # 文字列の平均はとれないのでエラーになる\n\n\n2.1.4 変数名\n変数名は自由に決めることができますが、いくつかのルールがあります。\n\n変数名は、英数字とアンダースコアのみを使うようにします。少々長くなってもよいので、わかりやすい名前をつけましょう。\n変数名は、数字で始めてはいけません。\n変数名は、大文字と小文字を区別します。\n変数名は、R上であらかじめ定義されている予約語を使ってはいけません。例えば、ifやforなどは予約語です。\n\nRstudioやVS Codeにはコマンドや変数名を途中まで入力したら、補完してくれる機能があります。 したがって少々長い変数名でも、途中まで入力すれば補完してくれるので、入力もそこまで面倒ではないですし、変数名を覚える必要はありません。\n\nyear_2000_2023 &lt;- 2000:2023\n\n\n\n数値:数値で、連続した整数値を作成することができます。 1:10は、1から10までの整数の数列を作成します。\n最近のバージョンのRでは日本語の変数名も使えます。\n\n売上高 &lt;- c(100,240,420)\nmean(売上高) # 平均が計算される\n\n[1] 253.3333\n\n\n分かりやすいといえば，分かりやすいですが，日本語フォントは文字コードに表示が左右されるため，場合によっては文字化けの原因になります。\n\n2.1.5 まとめ\n\nR + RstudioかR+VS Codeを準備\nコードはインデントと半角スペースで見やすく\nコードにはコメントをたくさん書く\n変数名は原則，英数字とアンダースコア_を使う。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>コード作成の作法</span>"
    ]
  },
  {
    "objectID": "chap04_R.html#rの基礎",
    "href": "chap04_R.html#rの基礎",
    "title": "\n3  Rの基礎\n",
    "section": "\n3.1 Rの基礎",
    "text": "3.1 Rの基礎\nRの基本的な使い方を学びます。 Rがあつかうデータや分析結果などを格納するため，名前をつけて扱うことができるものを一般にオブジェクト(object)とよびます。 Rでは，オブジェクトの型として，次のようなものがあります。\n\n\nnumeric : 実数 (浮動小数点数)\n\ncharacter : 文字列\n\nlogical : 論理値 TRUE または FALSE\n\nfactor : ファクター型・因子型\n\nmatrix : 行列\n\ndata.frame : データフレーム\n\nlist : リスト\n\nNULL : 空のオブジェクト\n\nここでは，それぞれの型の特徴を簡単に説明します。\n\n3.1.1 変数の代入\nオブジェクトに値を代入するには、&lt;-を使います。 xに数値の2を代入してみます。\n\nx &lt;- 2\nx\n\n[1] 2\n\n\n\n3.1.2 数値型\nこのxの型を調べるには、class()を使います。\n\nclass(x)\n\n[1] \"numeric\"\n\n\nnumericと表示され，このオブジェクトxは数値型であることが分かりました。 数値に対しては，四則演算やべき乗などの演算子が使えます。\n\n3.1.3 文字列\n文字列を代入する場合は\"\"で囲みます。\n\ny &lt;- \"Hello, World!\" # 文字列を代入\ny # 変数yの値を表示\n\n[1] \"Hello, World!\"\n\n\nでは、次の場合はどうなるか考えてみてください。\n\n\nコード\n結果\n\n\n\n\nz &lt;- \"3\"\nz\n\n\n\n\n\n[1] \"3\"\n\n\n一見、数値の3が代入されているようにみえますが、\"3\"のように\"で囲まれているので、文字列として扱われます。\n\n\n\n\nclass(y)\n\n[1] \"character\"\n\nclass(z)\n\n[1] \"character\"\n\n\nyもzもcharacterと表示され、文字列型であることが分かりました。 文字列に対して，+や-などの演算子は使えませんが，文字列操作のための関数を利用して処理を行います。\n\n3.1.4 論理型\n論理型はTRUEとFALSEの2つの値をとります。 論理型に対しては，論理演算子が使えます。\n\na &lt;- c(1,2,3,4,5) # 数ベクトル\nb &lt;- a &lt; 3 # 条件式\nb\n\n[1]  TRUE  TRUE FALSE FALSE FALSE\n\n\nこのbのクラスを調べてみましょう。\n\nclass(b)\n\n[1] \"logical\"\n\n\nbはlogicalであり，論理型であることが分かりました。 論理型は，条件式の評価結果として得られることが多いです。 例えば，条件を満たすデータの個数を調べる場合は，\n\nsum(b) # bは論理型\n\n[1] 2\n\n\n2と表示され，数ベクトルaのうち，条件式a &lt; 3を満たすデータは2つであることが分かります。\n\n3.1.5 因子型\n因子型(factor class)は，カテゴリー型のデータを扱うための型です。 因子型であるかどうかは，分析者が明示的に指定する必要があります。 例えば，アンケート結果のデータには，大学の学年を表す変数があるとします。\n\ngrade &lt;- c(\"1回生\", \"2回生\", \"2回生\", \"3回生\", \"4回生\", \"4回生\")\n\nこのgradeのクラスを調べてみましょう。\n\nclass(grade)\n\n[1] \"character\"\n\n\ngradeはcharacterであり，文字列型であることが分かりました。 ここで，このgradeはただの文字列ではなく，カテゴリーを表しているので， たとえば，1回生は1，2回生は2，という風に数値だったとしても，同じカテゴリーを表します。\n\ngrade_num &lt;- c(1, 2, 2, 3, 4, 4)\nclass(grade_num)\n\n[1] \"numeric\"\n\n\nこのgrade_numはnumericであり，数値型ですが，1は1回生，2は2回生，3は3回生，4は4回生を表すカテゴリー変数です。\nこのようなカテゴリーを表す文字列や数値を，因子型としてRに認識させることで，分析が便利になります。 カテゴリーを表す変数を因子型に変換するには，\n\n\nas.factor()関数 : 単に因子型に変換するだけ\n\nfactor()関数 : 因子型にしつつ追加の特徴もつけられる\n\nforecats:::fct_relevel()関数 : 便利だけれど，ここでは使わない\n\nのいずれかを使います。\n\nas.factor(grade)\n\n[1] 1回生 2回生 2回生 3回生 4回生 4回生\nLevels: 1回生 2回生 3回生 4回生\n\nfactor(grade)\n\n[1] 1回生 2回生 2回生 3回生 4回生 4回生\nLevels: 1回生 2回生 3回生 4回生\n\n\nいずれも因子型に変換され，Levelsとしてカテゴリーが表示されます。\n\nas.factor(grade_num)\n\n[1] 1 2 2 3 4 4\nLevels: 1 2 3 4\n\nfactor(grade_num)\n\n[1] 1 2 2 3 4 4\nLevels: 1 2 3 4\n\n\nas.factor()関数とfactor()関数は数ベクトルも因子型に変換できますが，forcats:::fct_relevel()関数は文字列型のみしか変換できません。 ここでは，factor()関数を使うことにします。 factor()関数の引数は，\n\n\nx : 変換する変数\n\nlevels : 含まれるカテゴリー，すべてのカテゴリーを明記する必要がある。\n\nlabels : カテゴリーに割り当てるカテゴリー名\n\nordered : 順番を明示するかどうか\n\nの4つです。 次に，数ベクトルgrade_numを因子型に変換しつつ，数値が表すカテゴリー名を指定して，順番があることを明示したものをf_grade_numに代入します。\n\nf_grade_num &lt;- factor(grade_num, # 変換する変数\n    levels = c(1, 2, 3, 4), # 含まれるカテゴリー\n    labels = c(\"1回生\", \"2回生\", \"3回生\", \"4回生\"), # カテゴリー名\n    ordered = TRUE # 順番を明示\n    )\nf_grade_num\n\n[1] 1回生 2回生 2回生 3回生 4回生 4回生\nLevels: 1回生 &lt; 2回生 &lt; 3回生 &lt; 4回生\n\n\nf_grade_numが因子型となり，LevelsとしてカテゴリーがLevels: 1回生 &lt; 2回生 &lt; 3回生 &lt; 4回生のように順番があることをRが認識していることがわかります。 このf_grade_numのクラスを調べてみましょう。\n\nclass(f_grade_num)\n\n[1] \"ordered\" \"factor\" \n\n\n\"ordered\"と\"factor\"と表示され，順序のある因子型であることが分かりました。\n\n3.1.6 行列型\n行列型(matrix class)は，行と列にデータが格納された2次元のデータ構造です。 行列型は，matrix()関数を使って作成します。 matrix()関数の引数は主に，\n\n\ndata : 行列に格納するデータ\n\nnrow : 行数\n\nncol : 列数\n\nです。 例えば，次の行列を作成してみましょう。\n\n\\begin{aligned}\n\\boldsymbol{A} =\n\\begin{pmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{pmatrix}\n\\end{aligned}\n\n\nA = matrix(c(1, 3, 7, 2, 5, 8, 5, 9, 4), # 行列に格納するデータ\n    nrow = 3, # 行数\n    ncol = 3 # 列数\n    )\nA\n\n     [,1] [,2] [,3]\n[1,]    1    2    5\n[2,]    3    5    9\n[3,]    7    8    4\n\n\n数値を格納した行列型Aが作成されました。 ついでみ，行列に含まれるデータの文字列が含まれていたらどうなるか調べてみましょう。2行1列のデータに\"2\"を入れてみます。\n\nB = matrix(c(1, 3, 7, \"2\", 5, 8, 5, 9, 4), # 行列に格納するデータ\n    nrow = 3, # 行数\n    ncol = 3 # 列数\n    )\nB\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"2\"  \"5\" \n[2,] \"3\"  \"5\"  \"9\" \n[3,] \"7\"  \"8\"  \"4\" \n\n\nすべてのデータが文字列型になってしまいました。 このように行列式は1種類の型しか格納できない，という特徴があります。\n数値でできた行列Aのクラスを調べてみましょう。\n\nclass(A)\n\n[1] \"matrix\" \"array\" \n\n\nAは\"matrix\"と\"array\"であり，行列型(そして配列型array)であることが分かりました。 因子分析や主成分分析を厳密に使う，あるいは統計分析の手法を自分で実装しようとしない限り，行列型を使うことはないのですが，Rは逆行列の計算や固有値・固有ベクトルの計算など，行列計算が早く，便利な関数が多く用意されています。\n例えば，行列Aの逆行列を計算するには，solve()関数を使います。\n\ninverseA &lt;- solve(A)\ninverseA\n\n      [,1] [,2] [,3]\n[1,]  10.4 -6.4  1.4\n[2,] -10.2  6.2 -1.2\n[3,]   2.2 -1.2  0.2\n\n\n逆行列が計算できているかどうかを確認してみる。\n\n\\begin{aligned}\n\\boldsymbol{A} \\times \\boldsymbol{A}^{-1} = \\boldsymbol{I} =\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\end{aligned}\n\n行列のかけ算は%*%で行います。\n\nI &lt;- A %*% inverseA\nround(I, digits = 2)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nRの数値計算では，浮動小数点数演算における丸め誤差のため，round()関数で小数点以下第2位で四捨五入した結果を表示してみました。単位行列\\boldsymbol{I}になっていることが分かりました。\n\n3.1.7 データフレーム型\nデータフレーム型(data.frame class)は，行と列にデータが格納された2次元のデータ構造です。 行列型と似ていますが，データフレーム型は，行ごとに異なる型のデータを格納することができます。\nデータフレームdata.frame型は非常に重要な型で，Rでデータ分析を行う際には，ほとんどの場合，データフレーム型を扱うことになります。 次のセクションで，データフレーム型について詳しく説明します。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Rの基礎</span>"
    ]
  },
  {
    "objectID": "chap02_prepare.html#rの準備",
    "href": "chap02_prepare.html#rの準備",
    "title": "1  準備",
    "section": "1.1 Rの準備",
    "text": "1.1 Rの準備\n\n1.1.1 Rのインストール\nRは、The Comprehensive R Archive Network (CRAN)からダウンロードできます。 Rをインストールする際のベストプラクティスについては様々なウェブサイトで紹介されているので、そちらを参照してください。 オススメとして、高知工科大学の矢内勇生先生のウェブサイトこちらの「RとRstudioのインストール方法の解説」でPDFにまとめられている資料があります。\n松浦のプレゼミで使うのは、以下のアプリケーションです。\n\nR\nRstudio\nQuarto\nVS Code\n\nインストールが上手くいかない、インストールが面倒・困難である、何もインストールしたくない、という方は、\n\nPosit Cloud\nGoogle Colaboratory\n\nのどちらかを使ってください。 アカウントを作成すると、ブラウザ上でRを実行することができます。Google ColaboratoryはPythonの実行環境ですが、一手間かければRも実行できます。以下のサイトを参考にしてください。\nRによる統計入門\n\n\n1.1.2 テキストエディタ\nR言語でプログラムを書くには、R専用のIDE(Integrated Development Environment)であるRstudioを使うのが一般的ですが、より汎用的なテキストエディタを使うという選択肢もあります。 テキストエディタとは文字通り、文字を編集するためのソフトウェアです。 有名なものとしては、\n\nVisual Studio Code (Microsoft)\nSublime Text (Sublime HQ)\nVim (Bram Moolenaar) 上級者向け\nEmacs (GNU) 上級者向け\n\nなどがあり、松浦はVisual Studio Code(以下、VS Code)を使ってます。\n\n\n\nVS Code\n\n\nとはいうものの、やはり最初はRstudioを使う方が設定などが簡単なので、以下ではRstudioの設定を紹介します。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備</span>"
    ]
  },
  {
    "objectID": "chap02_prepare.html#rstudioの準備",
    "href": "chap02_prepare.html#rstudioの準備",
    "title": "1  準備",
    "section": "1.2 Rstudioの準備",
    "text": "1.2 Rstudioの準備\nRtsudioを起動すると、以下のような画像が表示されます。\n\n\n\nRtsudio\n\n\n次の画像で赤丸で囲まれているマークをクリックすると、コード画面が表示されます。\n\n\n\nRstudio\n\n\nRstudioは4つの画面で構成されています。\n\nスクリプトエディタ\nコンソール\n環境\nプロットなど\n\n\n\n\nRstudio\n\n\n上のメニューバーから「Tools」→「Global Options」を選択すると、以下のような画面が表示されます。\n\n\n\nRstudio\n\n\n「General」の「Save workspace to .RData on exit」を「Never」に変更しておいてください。\nまた、Rstudioの画面を見やすくするため、先のOptionsの画面の左側メニューの「Pane Layout」を選び、以下のように設定しておくとよいでしょう。\n\n\n\nRstudio\n\n\n設定の「Appearance」で画面の見た目やフォントなどを変更することで、自分の好みの設定にすることができます。 松浦は、テーマにmonokai、フォントにFira Fontを使用してます。 Fira Fontはリガチャに対応したモノスペースフォントなので、Rstudioのコードエディタで&lt;-などが綺麗に表示されます。\n\n\n\nRstudio\n\n\n\n1.2.1 Rstudioのプロジェクト機能\nRstudioにはプロジェクトと呼ばれる機能があり、プロジェクトを作成しておくと、ファイル管理や作業履歴の管理がしやすくなります。\nプロジェクトを作成するには、Rstudioの画面上部の「File」→「New Project」を選択するか、以下の図にあるとおり、右上の「Project」をクリックします。\n\n\n\nRstudio TOP\n\n\nすると、以下のようなウインド出てきます。\n\n\n\nRstudio Project\n\n\n「New Project…」を選択すると、次のウインドが表示されます。\n\n\n\nRstudio Project\n\n\n「New Directory」を選択して、プロジェクトを保存するディレクトリを選択します。\n\n\n\nRstudio Project\n\n\nここでは、新しいプロジェクトを作るので、「New Project」を選択すると、次の「Create New Project」のウインドが表示されます。\n\n\n後で解説するQuartoを使って論文やウェブサイトを作成するときは、「Quarto Website」や「Quarto Book」を選択します。\n\n\n\nRstudio Project\n\n\nDirectory name:のところに、Rで生成されるファイルなどを保存するフォルダー名を入力します。 半角英数の名前にするほうが、エラー回避になります。\nCreate project as subdirectory of:: のところに、プロジェクトを保存する場所(これをディレクトリといいます)を選択します。好きな場所を指定することができますが、やはり日本語名のフォルダなどは避けた方がよいでしょう。\n\n\n\nRstudio Project\n\n\n最後に「Create Project」をクリックすると、プロジェクトが作成されます。\n\n\n\nRstudio Project\n\n\nプロジェクトが作成されると、プロジェクト名のフォルダーが作成され、その中に.Rprojという拡張子のファイルが作成されます。 これで、プロジェクトの作成は完了です。 今後、作成した.Rprojファイルをダブルクリックするか、Rstudioの画面上部の「File」→「Open Project」を選択して、.Rprojファイルを選択するだけで、プロジェクトが開き、作業ディレクトリの場所が設定されます。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備</span>"
    ]
  },
  {
    "objectID": "chap02_prepare.html#vs-codeの準備",
    "href": "chap02_prepare.html#vs-codeの準備",
    "title": "1  準備",
    "section": "1.3 VS Codeの準備",
    "text": "1.3 VS Codeの準備\n\n1.3.1 VS Codeのインストール\nVisual Studio Code(以下、VS Code)をインストールするには、Microsoftの公式サイトからダウンロードできます。\n\n\n\nVS Code\n\n\nウェブサイトの「Visual Studio Code をダウンロードする」をクリックすると、アクセスしているコンピューターのOSに合わせたインストーラーをダウンロードできるサイトに移動します。\n\n\n\nVS Code Download\n\n\nMacOSの場合、Intel Mac用とApple Silicon用(M1とかM2)とどちらでも動作するユニバーサル版の3つを選択できます。\nWindowsPCの場合は、32bit版と64bit版、そしてSurface Proなどに搭載されているArmチップ用の3つを選択できます。\n\n\n1.3.2 VS Codeの設定\nVS Codeを起動すると、以下のような画面が表示されます。\n\n\n\nVS Code top\n\n\n左側のメニューから「拡張機能」を選択すると、以下のような画面が表示されます。\n\n\n\nVS Code Extension\n\n\nこの画面上部の検索窓に文字を入力して、Enterキーを押すと、拡張パッケージが検索されます。\n\n\n\nVS Code Extention Search\n\n\nオススメ拡張パッケージは以下の通りです。\n\nJapanese Language Pack for Visual Studio Code : 日本語化\nR: R言語の実行環境\nQuarto : VS CodeでQuartoファイルを作成・実行する\nindent-rainbow : インデントを虹色にする\nvscode-icons : ファイルのアイコンを変更する\nRainbow CSV : CSVファイルを読みやすくする\nColor Highlight : カラーコードを色で表示する",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備</span>"
    ]
  },
  {
    "objectID": "chap02_prepare.html#フォント",
    "href": "chap02_prepare.html#フォント",
    "title": "1  準備",
    "section": "1.4 フォント",
    "text": "1.4 フォント\nプログラミングをするときには、ソースコードを書くエディタで使うフォント選びも重要です。 適切なフォントを選んでおくことで，コードの読みやすさが改善，あるいはエラーの発見がしやすくなります。\nフォントには大きく2種類あって，等幅フォント(mono font)と可変幅フォント(proportional font)があります。 等幅フォントは，全ての文字が同じ幅で表示されるフォントで，プログラミングには適しています。 通常，みなさんがMS Wordなどで文章を書くときに使っているMSゴシックとかヒラギノフォントは可変幅フォントです。\n\n1.4.1 等幅フォント\n等幅フォントの中でも，リガチャ(ligature)に対応したフォントを使うと，コードの見た目が改善されます。 リガチャに対応したフォントは，複数の文字を1つの文字のように表示することができます。 リガチャに対応した無料フォントでオススメなものが，\n\nFira Font\n\nリガチャは勝手に複数の文字を１つの文字にしてしまうので，一見何の文字か分からないことがあります。 そこでリガチャを使うかどうかは好みの問題です。\nリガチャ非対応の等幅フォントでオススメなものが，\n\nMyrica\n\nです。この資料のソースコードにはMyricaM Mというフォントを使っています。 松浦が自分の研究でデータ分析のソースコードを書くときは，Fira Fontを使っています。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>準備</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#可視化のパッケージ",
    "href": "chap11_visualization.html#可視化のパッケージ",
    "title": "\n11  ggplot2で可視化\n",
    "section": "\n11.1 可視化のパッケージ",
    "text": "11.1 可視化のパッケージ\nいままで利用してきたtidyverseにはグラフ作成のためのパッケージとしてggplot2が含まれています。 本章では，このggplot2パッケージの使い方を学習し，読者にもデータの特徴を伝えやすく，シンプルで，美しいグラフの作成を目指します。 またggplot2の機能を拡張するためのggthemesとpatchworkも一緒に読み込んでおきます。 まだインストールできていなければ，始めにインストールしておいてください。\n\n# install.packages(\"ggthemes\") # fist time only\n# install.packages(\"patchwork\") # first time only\nlibrary(tidyverse) # とりあえずこれ\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(ggthemes) # ggplotのテーマ拡張\nlibrary(patchwork) # ggplotの図を並べる\n\nまた、Macだとggplot2で作図したグラフで日本語が表示されないことがあります。 以下の設定をすることで文字化けを回避することができます。\n\n# グラフ内の日本語文字化け対策のおまじない\nknitr::opts_chunk$set(dev = \"ragg_png\")\n\nあるいは，ggplotのグラフ作成時に，base_family = \"フォント名\"として，作図で用いるフォントを指定することでも文字化けを回避できます。 たとえば次のように，list()関数を使ってグラフの設定を前もってmystyleというオブジェクトに入れておけば，作図時に+ mystyleを付けるだけで， フォントやグラフの見た目を指定できます。\n\nmystyle &lt;- list ( # mystyleとして設定を保存\n  theme_few(), # ggthemesのテーマ\n  theme(\n    text = element_text(\n      size=16,  #  フォントサイズ\n     family = \"HiraKakuProN-W3\" # ヒラギノフォント\n    )\n  )\n)\n\n以下の作図で使うデータを読み込んでおきましょう。\n\ndf &lt;- read_csv(\"data/presemi_part_two.csv\")\n\nRows: 44527 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): 会社コード, 企業名, 決算期\ndbl (9): 決算種別, 連結基準, 決算月数, 上場コード, 日経業種コード, 売上高, 親会社株主に帰属する当期純利益, 資産合計, 株主資本...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# df &lt;- read_csv(\"https://so-ichi.com/presemi_part_two.csv\")\nnames(df)\n\n [1] \"会社コード\"                     \"企業名\"                        \n [3] \"決算期\"                         \"決算種別\"                      \n [5] \"連結基準\"                       \"決算月数\"                      \n [7] \"上場コード\"                     \"日経業種コード\"                \n [9] \"売上高\"                         \"親会社株主に帰属する当期純利益\"\n[11] \"資産合計\"                       \"株主資本\"                      \n\n\n練習用の財務データを読み込み，オブジェクトdfに代入しました。 dfのクラスはspec_tbl_df, tbl_df, tbl, data.frameです。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>ggplot2で可視化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#ggplotパッケージの基礎",
    "href": "chap11_visualization.html#ggplotパッケージの基礎",
    "title": "\n11  ggplot2で可視化\n",
    "section": "\n11.2 ggplotパッケージの基礎",
    "text": "11.2 ggplotパッケージの基礎\n前節で、カテゴリー変数のファクター化，with()関数とtable()関数を使ったクロス集計表の作成，group_by()関数とsummarize()関数を使ったグループごとの統計量の計算について学んだので，これらの結果を使ってグラフを作ることで，読者に伝わるデータの可視化を行いたいと思います。 キレイなグラフを比較的簡単に作ることができるggplot2パッケージを使います。\n\n11.2.1 ggplot()関数の基本的な使い方と変数の特徴把握\nggplot2パッケージのggplot()関数は，次のような引数をとります。\n\n\ndata = : データフレーム\n\nmapping = aes() : グラフの構成要素を指定する関数\n\ngeom_*** : グラフの種類を指定する関数\n各種オプション\n\n\n\nggplot2の作図イメージ\n\n最初の注意点として，ggplot()関数は，第1引数data =でtibbleかdata.frameを指定する必要があります。 データの型に気をつけましょう。\nでは，年度ごとに平均ROEを示した折れ線グラフを作図していきます。 ROEの定義は， \nROE_{t} = \\frac{\\text{親会社株主に帰属する当期純利益}_t}{株主資本_{t-1}}\n となります。 計算してみましょう。 決算期の最初の4ケタを取り出し年度という変数も同時に作成しておきます。\n\ndf &lt;- df |&gt;\n  group_by(企業名) |&gt; # lag()関数を使うために企業ごとにグループ化\n  mutate( # ROEの計算\n    年度 = substr(決算期, 1,4),\n    ROE = 親会社株主に帰属する当期純利益 / lag(株主資本)\n  ) |&gt;\n  ungroup()\n\nROEの記述統計量を確認してみましょう。\n\nsummary(df$ROE)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   -Inf   0.026   0.068     NaN   0.119     Inf    3321 \n\n\nMin.やMax.がInfとなっており， 欠損値NA'sが3321個もあることが分かります。 Infとは無限大を表す特殊な値で，ROEの計算プロセスで分母がゼロとなっている値があることが分かります。 分数を計算するときは，分母がゼロとなっている値がないかどうか，チェックするようにしましょう。 ついでに、総資産回転率も計算しておきます。\n\ndf &lt;- df |&gt;\n  filter(株主資本 &gt; 0, 資産合計 &gt; 0) |&gt; # ゼロのデータを除外\n  group_by(企業名) |&gt; # 企業名でグループ化\n  mutate(\n    ROE = 親会社株主に帰属する当期純利益 / lag(株主資本),\n    TURN = 売上高 / lag(資産合計) # 総資産回転率\n  ) |&gt;\n  ungroup() |&gt;\n  drop_na() # 欠損値NAを除外\nsummary(df$ROE)\n\n     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. \n-32.16667   0.02692   0.06837   0.06600   0.11938 136.14286 \n\n\nこれで最小値と最大値が計算されるようになりました。 次に，年度ごとの平均ROEを計算して、df_yearというオブジェクトに代入しておきます。\n\ndf_year &lt;- df |&gt;\n  group_by(年度) |&gt; # 年度ごとに\n  summarise( # ROE平均を計算\n    平均ROE = mean(ROE, na.rm = TRUE)\n  ) |&gt;\n  ungroup() # グループ化解除\n\nこれで準備が整ったので、ggplot()関数を使ってグラフを作成していきます。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>ggplot2で可視化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#変数の可視化",
    "href": "chap11_visualization.html#変数の可視化",
    "title": "\n11  ggplot2で可視化\n",
    "section": "\n11.3 1変数の可視化",
    "text": "11.3 1変数の可視化\nまずは，1変数の可視化から始めていきましょう。 1変数の可視化とは，1つの変数の分布を可視化することです。 1変数のグラフの代表的なものとして、ヒストグラム(histogram)があります。 ggplot2パッケージでは、\n\ngeom_boxplot()\n\nで作図します。\nまず土台となるデータフレームを指定します。 ここでは、年度別に集計する前のdfを使います。\n\nggplot(data = df)\n\n\n\n\n\n\n\n土台ができましたが，まだ何も表示されていません。 次に，グラフの構成要素を指定するために，mapping = aes()で，軸を指定します。 1変数のグラフの場合、aes(x = 変数名)とすることで、変数を指定します。\n\nggplot(data = df, mapping = aes(x = ROE))\n\n\n\n\n\n\n\n作図する変数としてROEが指定されました。\n\n11.3.1 ヒストグラム\nヒストグラムは、横軸に連続変数の区間をとり、その区間ごとの度数を縦軸にとったグラフで、連続変数の分布を可視化するのに適しています。 分布の偏りや外れ値の有無を確認するのに有用で、重要な変数に対して必ず作図するものと言えます。\nヒストグラムを作成するには、geom_histogram()を使います。 ggplot()関数の引数を全て書くのは面倒なので、data =とかmapping =は省略します。\n\nggplot(df) + aes(ROE) + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n「stat_bin() using bins = 30. Pick better value with binwidth.」というメッセージが出ました。 ヒストグラムを作成する際に区間幅やビンの数(棒の数)を指定しないと、ggplot2が自動的に30本の棒になるように区間幅を指定していますよ，というメッセージです。 好みの区間幅や棒の数を指定したい場合は，binwidth = 0.1のように指定してみてください。\n\nggplot(df) + aes(ROE) + geom_histogram(binwidth = 0.1)\n\n\n\n\n\n\n\nヒストグラムが、ただの棒になっています。 これは大部分のデータがゼロ付近の値を取っているけれど、異常値があるせいで、横軸の範囲が広くなってしまっているためです。 先ほど計算したROEの記述統計量でも、最小値は-32.167、最大値は136.143となっています。 当期純利益が株主資本の136倍というのは、異常な値ですね。 そこで、x軸の範囲を[-1,1]に限定してみましょう。 ggplot()関数にxlim()を追加して、x軸の範囲を指定します。\n\nggplot(df) + aes(ROE) + geom_histogram(binwidth = 0.05) + xlim(-1,1)\n\nWarning: Removed 319 rows containing non-finite values (`stat_bin()`).\n\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`).\n\n\n\n\n\n\n\n\n\n\nなにやらWarningが出ていますが、区間を区切ったことでグラフに入らなかったデータがあることを教えてくれているだけなので，無視します。\n左右対称のヒストグラムが描けました。 ヒストグラムは分布の形や異常値を確認するためにも，分析する変数すべてに対して作成するように心がけましょう。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>ggplot2で可視化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#変数の可視化-1",
    "href": "chap11_visualization.html#変数の可視化-1",
    "title": "\n11  ggplot2で可視化\n",
    "section": "\n11.4 2変数の可視化",
    "text": "11.4 2変数の可視化\n次に，2変数の可視化を行っていきましょう。 2変数の可視化では、横軸と縦軸にそれぞれ1つの変数をとるグラフを作成します。 また、横軸に割り当てられる変数が連続変数かカテゴリー変数かによって、作成するグラフが異なります。\n\n11.4.1 横軸が連続・縦軸も連続の場合\n横軸と縦軸の両方が連続変数の場合、2つの変数の関係性を表すグラフとして散布図(scatter plot)を作成します。 散布図は、横軸の値と対応する縦軸の値の組み合わせを点で表したグラフです。 散布図は、geom_point()を使って作成します。\n先ほど作成したdfのROEとTURNの関係を散布図で表してみましょう。 先と同様に、x軸とy軸の範囲をしておきます。\n\nggplot(df) + aes(ROE, TURN) + geom_point() + xlim(-1,1) + ylim(0,10)\n\nWarning: Removed 322 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\nなんとなく、総資産回転率TURNが大きいほど、ROEが大きいように見えます。 このように、散布図を作成すると、2つの変数の関係を直観的に把握することができます。\n\n11.4.2 横軸がカテゴリー変数・縦軸が連続変数の場合\n横軸が順序のないカテゴリー変数で、縦軸が連続変数となるグラフとして\n\n\ngeom_bar() : 棒グラフ\n\ngeom_boxplot() : 箱ひげ図\n\ngeom_violin() : バイオリンプロット\n\nなどがあり、横軸が順序のあるカテゴリー変数であれば、\n\n\ngeom_line() : 折れ線グラフ\n\nが代表的です。 また，横軸にカテゴリー変数を指定する際に，そのカテゴリー変数の型が数値型でも文字列でも因子型でも，Rが適切に解釈してくれ，作図してくれますが，可能な限りカテゴリー変数は因子型にしておくほうが望ましいです。\n\nそれぞれ作成してみましょう。\n\n11.4.2.1 棒グラフ\n棒グラフはヒストグラムに似ていますが、棒グラフは離散変数やカテゴリー変数の分布を表し、ヒストグラムは連続変数の分布を表している、という点で違いがあります。\n棒グラフを作成するには、geom_bar()を使います。 geom_bar()は次の引数をとります。\n\n\nstat = : 棒の高さの計算方法 identityを指定すると、データの値をそのまま棒の高さにします。\n\nposition = : 棒の位置の計算方法 dodgeを指定すると、カテゴリーごとに棒を並べます。\n\nまた、2変数のグラフとなるため、aes(x = 変数1, y = 変数2)と2つの変数を指定します。 ここでは年度ごとに集計したdf_yearを使って、年度ごとの平均ROEを棒グラフで表してみましょう。\n\nggplot(df_year) + aes(x = 年度, y = 平均ROE) + geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n11.4.2.2 箱ひげ図\n箱ひげ図(box plot)は、カテゴリーごとの連続変数の分布を表すグラフです。 棒と箱の図からなるグラフで、箱の部分から中央値(Q2)，第1四分位点(Q1)，第3四分位点(Q3)統計量，そしてヒゲの部分から正常値と設定される範囲が読み取れるグラフです。 \n\n\n箱ひげ図\n\n年度ごとのROEの分布を箱ひげ図で表してみましょう。 横軸のカテゴリー変数ごとに作図するため，aes()の中でx軸とy軸を設定するのと同時に，group =でカテゴリーを指示します。\nでは集計前のdfを用いて，上場コードごとのROEの分布を表す箱ひげ図を作成します。 異常値のせいで箱ひげ図が潰れてしまうことが予想できるので，表示する幅をylim()で設定しておきます。\n\ndf |&gt;\n  ggplot() + aes(x = 上場コード, y = ROE, group = 上場コード) + geom_boxplot() + ylim(-0.5, 0.5)\n\nWarning: Removed 1168 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\nこの上場場ごとのROEの箱ひげ図から，東証プライム(東証1部)に属する企業は，ROEの中央値が他よりも高いが，東証スタンダードとグロースは中央値に差が無さそうに見える。しかし東証グロースはROEのばらつきが最も大きく，業績の格差が大きいことが分かる。\n\n11.4.2.3 ヴァイオリンプロット\n次に，バイオリンプロットを作成します。 バイオリン・プロットも箱ひげ図を同じようなグラフですが，分布の形を中央値などの代表値で表すのではなく，分布の形をそのまま表現することができます。 バイオリンプロットの作成にはgeom_violin()を使います。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE)\ng &lt;- g + geom_violin() + ylim(-.5,.5)\ng &lt;- g + xlab(\"上場場\") + ylab(\"ROE\")\nprint(g)\n\nWarning: Removed 1168 rows containing non-finite values (`stat_ydensity()`).\n\n\n\n\n\n\n\n\nバイオリンプロットから，プライム・東証1部とスタンダード・東証2部の上場企業のROEは中央値に差があるものの，分布の形は似ていますが，グロース・マザーズの企業は，ROEの分布が大きく異なることがわかります。\n\n11.4.2.4 カスタマイズした箱ひげ図とバイオリンプロット\ngeom_violin()をもっとカスタマイズして，より豊かな情報をもつグラフにしてみようと思います。 まずは，グラフを色分けしてみましょう。 aes()の中でfill =で色を指定します。 ついでに，geom_dotplot()を使って，データの分布を点で表現してみます。\n\ng &lt;- ggplot(df) + aes(x = factor(上場コード), y = ROE, fill = factor(上場コード))\ng &lt;- g + geom_violin()\ng &lt;- g + geom_boxplot(width = 0.1, fill = \"white\", color = \"black\")\ng &lt;- g + ylim(-0.5, 0.5)\nprint(g)\n\nWarning: Removed 1168 rows containing non-finite values (`stat_ydensity()`).\n\n\nWarning: Removed 1168 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n\n11.4.2.5 折れ線グラフ\n横軸が時間を表すカテゴリー変数である場合，データの時系列的特性を表すために折れ線グラフを作成します。\n折れ線グラフを作成するためにはgeom_line()関数を使います。 年度平均を集計したdf_yearを用いて，横軸が年度，縦軸が平均ROEとなる折れ線グラフを作成し，上場企業全体のROE平均が時間とともにどのように変化したのかを確認してみましょう。 ここで年度が文字列となっていますが，本来は順序に意味のあるカテゴリー変数ですので，factor()関数を使って，ファクター型に変換します。\n\ndf_year &lt;- df_year |&gt;\n  mutate(\n    年度 = factor( # 因子型に変換\n      年度, # 因子型にする変数\n      levels = c(1999:2022), # カテゴリーの種類\n      ordered = TRUE # 順序があることを明示\n      )\n      )\n\n\nggplot(df_year) + aes(x = 年度, y = 平均ROE) + geom_line()\n\n`geom_line()`: Each group consists of only one observation.\nℹ Do you need to adjust the group aesthetic?\n\n\n\n\n\n\n\n\n「geom_line(): Each group consists of only one observation. Do you need to adjust the group aesthetic?」というメッセージが出ました。\nこれは，年度が因子型であり，ggplot2が自動的に年度ごとにグループ分けをしてくれないために出るメッセージです。 aes()の中でgroup = 1として，データ全体が1つのグループであることを明示する必要があります。 横軸がファクター型であるときは，group = 1をつける，というおまじないを覚えておきましょう。\n\nggplot(df_year) + aes(x = 年度, y = 平均ROE, group = 1) +\n  geom_line() + geom_point() + # グラフ\n  xlab(\"年度\") + ylab(\"平均ROE\") # 軸ラベル\n\n\n\n\n\n\n\n上のようにすべての要素を+でつなぐよりも，レイヤーごとにオブジェクトに代入していくほうが，コードが読みやすくなります。 以下の例では，グラフの基本要素をgというオブジェクトに代入しておき，g &lt;- g +でどんどんレイヤーを追加していきます。\n\ng &lt;- ggplot(df_year) + aes(年度, 平均ROE, group = 1) # 基本要素\ng &lt;- g + geom_line() + geom_point() # 折れ線グラフと散布図\ng &lt;- g + xlab(\"年度\") + ylab(\"平均ROE\") # 見た目の調整\nprint(g)\n\n折れ線グラフだけより，散布図も同時に表示するほうがグラフが読みやすくなり，オススメです。\n\n\n11.4.3 図の保存\n最後に，作成した図を保存するには，ggsave()関数を使います。 ggsave()関数は，次のような引数をとります。\n\n\nfilename = : 保存するファイル名\n\nplot = : 保存する図\n\nwidth = : 図の幅\n\nheight = : 図の高さ\n\ndpi = : 解像度\n\n日本語を含まないグラフであったり，Windowsならこれでうまくいくのですが，Macで日本語を含むggplotのグラフを保存するには一手間必要です。\nMacの場合\nMacの場合，ggsave()関数を使って図を保存しても，日本語が文字化けして保存されてしまいます。 そこでquartz()関数を用いて保存すれば日本語を含むグラフを文字化けさせずに保存することができます。\nquartz()は以下の引数を取ります。\n\n\nfilename = : 保存するファイル名\n\nwidth = : 図の幅\n\nheight = : 図の高さ\n\npointsize = : フォントサイズ\n\ndpi = : 解像度\n\nfamily = : フォントファミリー\n\ntype = : ファイルタイプ\n\nantialias = : アンチエイリアス\n\n最低限の設定だと,\nquartz(\"ファイル名.pdf\", type = \"pdf\")とか，quartz(\"ファイル名.png\", type = \"png\")と，保存するファイル名とファイルタイプを指定しておきましょう。 その上で，\n\n\nquartz()関数でグラフを保存するファイルを指定する\n\nprint()関数でグラフを表示・保存\n\ndev.off()関数で保存を終了する\n\nという手順を踏むと，作業ディレクトリにグラフが保存されます。\n\nquartz(\"violin_plot.pdf\", width = 10, height = 6)\nprint(g) # グラフが代入されたオブジェクトを表示\ndev.off()\n\nこれで作業ディレクトリにviolin_plot.pdfが保存されました。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>ggplot2で可視化</span>"
    ]
  },
  {
    "objectID": "chap03_code.html#練習",
    "href": "chap03_code.html#練習",
    "title": "\n2  コード作成の作法\n",
    "section": "\n2.2 練習",
    "text": "2.2 練習\n以下のコードを見やすいように半角スペースを入れて書き換えてください。\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>コード作成の作法</span>"
    ]
  },
  {
    "objectID": "part03.html",
    "href": "part03.html",
    "title": "第3部 データの可視化",
    "section": "",
    "text": "Rが得意とするデータの可視化について学習します。 主に、ggplot2パッケージを使ったデータの可視化の方法を学び，次にどんなデータをどのように可視化するのかについて考えます。\nhttps://so-ichi.com/presemi_part_two.csv\n&lt;!–\nこのデータには、以下の変数が含まれています。\n\n日経会社コード : 会社固有コード\n企業名称 : 企業の名称\n決算期 : 決算年月 YYYY/MM\n決算種別 : 10が本決算、20が中間決算\n連結基準 : 1が連結、2が非連結\n決算月数 : 決算期の月数\n上場場部：コード : 11が東証1部、12が東証2部、13がマザーズ\n日経業種：コード : 日経業種のコード6ケタ\n売上高\n親会社株主に帰属する当期純利益\n資産合計\n株主資本",
    "crumbs": [
      "第3部 データの可視化"
    ]
  },
  {
    "objectID": "chap11_visualization.html",
    "href": "chap11_visualization.html",
    "title": "\n11  データの可視化\n",
    "section": "",
    "text": "12 ggpubrパッケージ\nggpubrパッケージは，ggplot2パッケージのグラフをさらにカスタマイズするためのパッケージで，論文や書籍に掲載するためのグラフを作成するのに便利です。\nlibrary(ggpubr)で読み込みます。インストールしていない場合は，install.packages(\"ggpubr\")を実行してから，再度読み込んでください。\n# install.packages(\"ggpubr\") # first time only\nlibrary(ggpubr)",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データの可視化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#ggpubrのヘルプ",
    "href": "chap11_visualization.html#ggpubrのヘルプ",
    "title": "\n11  データの可視化\n",
    "section": "\n12.1 ggpubrのヘルプ",
    "text": "12.1 ggpubrのヘルプ\nggplot2パッケージは便利だけれど，出版物にグラフを掲載するためにはいろいろ調整する必要があるけど，それは初心者には難しいので，ggpubrを使いましょう，という説明がある。\n\n12.1.1 ggpubrのドキュメント\nggpubrのドキュメントは，公式サイトにあります。 そこにある例を参考にしながら，ggpubrの機能を学んでいきましょう。\n\nset.seed(1234)\nwdata = data.frame(\n   性別 = factor(rep(c(\"F\", \"M\"), each=200)), # 男女各200名\n   体重 = c(rnorm(200, 55), rnorm(200, 58))\n   ) # 正規分布の乱数\n# ggpubr::ggdensity で密度プロットを作成\nggdensity(wdata, # データフレーム\n    x = \"体重\", # 体重の分布\n    add = \"mean\", # 平均値を表示\n    rug = TRUE, #\n    color = \"性別\", fill = \"性別\",\n    palette = c(\"#00AFBB\", \"#E7B800\")\n    )",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データの可視化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#ggpubrパッケージ",
    "href": "chap11_visualization.html#ggpubrパッケージ",
    "title": "\n11  ggplot2で可視化\n",
    "section": "\n11.5 ggpubrパッケージ",
    "text": "11.5 ggpubrパッケージ\nggpubrパッケージは，ggplot2パッケージのグラフをさらにカスタマイズするためのパッケージで，論文や書籍に掲載するためのグラフを作成するのに便利です。\nlibrary(ggpubr)で読み込みます。インストールしていない場合は，install.packages(\"ggpubr\")を実行してから，再度読み込んでください。\n\n# install.packages(\"ggpubr\") # first time only\nlibrary(ggpubr)\n\n\n11.5.1 ggpubrのヘルプ\nggplot2パッケージは便利だけれど，出版物にグラフを掲載するためにはいろいろ調整する必要があるけど，それは初心者には難しいので，ggpubrを使いましょう，とのこと。\n\n11.5.2 ggpubrのドキュメント\nggpubrのドキュメントは，公式サイトにあります。 そこにある例を参考にしながら，ggpubrの機能を学んでいきましょう。\n密度プロットを作成するには，ggdensity()関数を使います。 ggplot2パッケージとは違い，aes()は使いません。\n\nset.seed(1234)\nwdata = data.frame(\n   性別 = factor(rep(c(\"F\", \"M\"), each=200)), # 男女各200名\n   体重 = c(rnorm(200, 55), rnorm(200, 58))\n   ) # 正規分布の乱数\n# ggpubr::ggdensity で密度プロットを作成\nggdensity(wdata, # データフレーム\n    x = \"体重\", # 体重の分布\n    add = \"mean\", # 平均値を表示\n    rug = TRUE, # 密度関数の下にデータ分布を表示\n    color = \"性別\", fill = \"性別\",\n    palette = c(\"#00AFBB\", \"#E7B800\")\n    )\n\n\n\n\n\n\n\nヒストグラムは，ggpubr::gghistogram()関数を使います。\n\ngghistogram(wdata,\n    x = \"体重\", # 体重\n    add = \"mean\",  # 平均値を表示\n    rug = TRUE, # x軸にデータの分布\n    color = \"性別\",  # 枠の色を性別ごと\n    fill = \"性別\", # グラフの中の色を性別ごと\n    palette = c(\"#00AFBB\", \"#E7B800\")\n    )\n\nWarning: Using `bins = 30` by default. Pick better value with the argument\n`bins`.\n\n\n\n\n\n\n\n\n次は，横軸にカテゴリー変数，縦軸に連続変数となるグラフをggpubrで作ってみます。 箱ひげ図を作るには，ggpubr::ggboxplot()関数を使います。\n\ndata(\"ToothGrowth\") # 歯の成長データ\ndf &lt;- ToothGrowth\nhead(df, 4)\n\n\n\n\nlen\nsupp\ndose\n\n\n\n4.2\nVC\n0.5\n\n\n11.5\nVC\n0.5\n\n\n7.3\nVC\n0.5\n\n\n5.8\nVC\n0.5\n\n\n\n\n\n# 箱ひげ図\np &lt;- ggboxplot(df, # データフレーム\n    x = \"dose\", y = \"len\", # 2変数を指定\n    color = \"dose\", # 色分けはdoseごと\n    palette =c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # 色指定\n    add = \"jitter\", # データを重ならないように\n    shape = \"dose\" # 点の形ををdoseごとに\n    )\nprint(p)\n\n\n\n\n\n\n\n心理学系論文でよく利用されるグループ間の差の検定結果を載せる。\n\nmy_comparisons &lt;- list(c(\"0.5\", \"1\"), c(\"1\", \"2\"), c(\"0.5\", \"2\"))\n # Add pairwise comparisons p-value\np + stat_compare_means(comparisons = my_comparisons) +\n    stat_compare_means(label.y = 50)\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, :\nタイがあるため、正確な p 値を計算することができません\n\n\n\n\n\n\n\n\n箱ひげ図とバイオリン・プロットを組み合わせグラフは，ggviolin()関数で作成できる。\n\nggviolin(\n  df,\n  x = \"dose\",\n  y = \"len\",\n  fill = \"dose\",\n  palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  add = \"boxplot\",\n  add.params = list(fill = \"white\")) +\n  stat_compare_means(comparisons = my_comparisons, label = \"p.signif\") + # 有意水準を追加\n  stat_compare_means(label.y = 50)  # p値を追加\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, :\nタイがあるため、正確な p 値を計算することができません",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データの可視化</span>"
    ]
  },
  {
    "objectID": "chap11_visualization.html#棒グラフ-1",
    "href": "chap11_visualization.html#棒グラフ-1",
    "title": "\n11  ggplot2で可視化\n",
    "section": "\n11.6 棒グラフ",
    "text": "11.6 棒グラフ\n\nグループ化した変数での色分けを変更してみよう， 並び替えはグループごとではなく，グローバルに行われます。\n\ndata(\"mtcars\") # 車のデータ\ndfm &lt;- mtcars\n# `cyl`を因子型に変換\ndfm$cyl &lt;- as.factor(dfm$cyl)\n# 変数名を追加\ndfm$name &lt;- rownames(dfm)\n# データの確認\nhead(dfm[, c(\"name\", \"wt\", \"mpg\", \"cyl\")])\n\n\n\n\n\nname\nwt\nmpg\ncyl\n\n\n\nMazda RX4\nMazda RX4\n2.620\n21.0\n6\n\n\nMazda RX4 Wag\nMazda RX4 Wag\n2.875\n21.0\n6\n\n\nDatsun 710\nDatsun 710\n2.320\n22.8\n4\n\n\nHornet 4 Drive\nHornet 4 Drive\n3.215\n21.4\n6\n\n\nHornet Sportabout\nHornet Sportabout\n3.440\n18.7\n8\n\n\nValiant\nValiant\n3.460\n18.1\n6\n\n\n\n\n\n# 作図\nggbarplot(dfm,\n  x = \"name\", y = \"mpg\", # 2変数を指定\n  fill = \"cyl\", # cylごとに色替え\n  color = \"white\",  # 枠の色は白\n  palette = \"jco\", # 論文用色見本\n  sort.val = \"desc\", # 降順で並び替え\n  sort.by.groups = FALSE,  # グループ内で並び替えしない\n  x.text.angle = 90  # x軸のラベルを90度回転\n)\n\n\n\n\n\n\n\nsort.by.groups = TRUEを入れると，グループ内で並び替えが行われます。\n\n\n11.6.1 偏差グラフ\n\n偏差グラフは，定量的な値の偏差を参照値に対して表します。 つまり，基準となる値からの差をグラフにしたものです。  以下のRコードでは，mtcarsデータセットからmpgのzスコアをプロットします。\n\ndfm &lt;- dfm |&gt;\n  mutate(\n    mpg_z = ( mpg - mean(mpg))  / sd(mpg), # 標準化\n    mpg_grp = factor( # 因子化\n      ifelse(mpg_z &lt; 0, \"low\", \"high\"),\n      levels = c(\"low\", \"high\")\n      )\n  )\n# データの確認\nhead(dfm[, c(\"wt\", \"mpg\", \"mpg_z\", \"mpg_grp\", \"cyl\")])\n\n\n\n\n\nwt\nmpg\nmpg_z\nmpg_grp\ncyl\n\n\n\nMazda RX4\n2.620\n21.0\n0.1508848\nhigh\n6\n\n\nMazda RX4 Wag\n2.875\n21.0\n0.1508848\nhigh\n6\n\n\nDatsun 710\n2.320\n22.8\n0.4495434\nhigh\n4\n\n\nHornet 4 Drive\n3.215\n21.4\n0.2172534\nhigh\n6\n\n\nHornet Sportabout\n3.440\n18.7\n-0.2307345\nlow\n8\n\n\nValiant\n3.460\n18.1\n-0.3302874\nlow\n6\n\n\n\n\n\n\n順序のある棒グラフを作成してみます。 燃費を表すmpgの水準で色を変えます。 rotate = TRUEとすることで，グラフを90度回転させます。\n\nggbarplot(dfm, x = \"name\", y = \"mpg_z\", # 軸の設定\n  fill = \"mpg_grp\", # `mpg_grp`で色分け\n  color = \"white\",  # 枠は白\n  palette = \"jco\",  # jcoパレット\n  sort.val = \"desc\", # 降順で並び替え\n  sort.by.groups = FALSE, # グループ内並び替えしない\n  x.text.angle = 90,  # x軸ラベルを90度回転\n  ylab = \"MPG z-score\", # Y軸ラベル\n  xlab = FALSE, # x軸は非表示\n  legend.title = \"MPG Group\", # グラフタイトル\n  rotate = TRUE,\n  ggtheme = theme_few()\n  )\n\n\n\n\n\n\n\n\n11.6.2 ロリポップチャート\nロリポップチャートは，名前のとおりキャンディーのような形をした棒グラフの一種です。  可視化したいデータセットに大きな値のある場合に，棒グラフの代わりに用いることができます。  ロリポップチャートは，ggdotchart()関数を使って作成します。\n\nggdotchart(dfm, x = \"name\", y = \"mpg\", # 軸の設定\n           color = \"cyl\",  # cylで色分け\n           palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # 色を指定\n           sorting = \"ascending\", # 降順で並び替え\n           add = \"segments\",  # y切片からドットまでセグメント追加\n           ggtheme = theme_pubr() # ggplot2テーマ\n           )\n\n\n\n\n\n\n\n同様に，見た目を変えたグラフとして，クリーブランド・ドットプロット(Cleveland’s dot plot)があります。\n\nggdotchart(dfm, x = \"name\", y = \"mpg\", # 軸の設定\n           color = \"cyl\", # cylで色分け\n           palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # 色を指定\n           sorting = \"descending\", # 降順で並び替え\n           rotate = TRUE, # 90度回転\n           dot.size = 2, # ドットのサイズ\n           y.text.col = TRUE,  # Color y text by groups\n           ggtheme = theme_pubr() # ggplot2 テーマ\n           ) +\n  theme_cleveland() # クリーブランド\n\nWarning: Vectorized input to `element_text()` is not officially supported.\nℹ Results may be unexpected or may change in future versions of ggplot2.",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>データの可視化</span>"
    ]
  },
  {
    "objectID": "chap12_ggpubr.html#ggpubrパッケージ",
    "href": "chap12_ggpubr.html#ggpubrパッケージ",
    "title": "\n12  ggpubrで可視化\n",
    "section": "\n12.1 ggpubrパッケージ",
    "text": "12.1 ggpubrパッケージ\nggpubrパッケージは，ggplot2パッケージのグラフをさらにカスタマイズするためのパッケージで，論文や書籍に掲載するためのグラフを作成するのに便利です。 ggpubrを使うためにはlibrary(ggpubr)でパッケージを読み込みます。 インストールしていない場合は，install.packages(\"ggpubr\")を実行してから，再度読み込んでください。\n\n# install.packages(\"ggpubr\") # first time only\nlibrary(ggpubr)\n\n 要求されたパッケージ ggplot2 をロード中です \n\nlibrary(ggthemes)\n\n\n12.1.1 ggpubrのヘルプ\nggplot2パッケージは便利だけれど，出版物にグラフを掲載するためにはいろいろ調整する必要がでてきます。ただそれは初心者には難しいので，ggpubrを使いましょう，とのことです。 ggpubrのヘルプは，?ggpubrで見ることができます。\n\n12.1.2 ggpubrのドキュメント\nggpubrのドキュメントは，公式サイトにあります。 そこにある例を参考にしながら，ggpubrの機能を学んでいきましょう。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggpubrで可視化</span>"
    ]
  },
  {
    "objectID": "chap12_ggpubr.html#ggpubrでグラフ作成",
    "href": "chap12_ggpubr.html#ggpubrでグラフ作成",
    "title": "\n12  ggpubrで可視化\n",
    "section": "\n12.2 ggpubrでグラフ作成",
    "text": "12.2 ggpubrでグラフ作成\n密度プロットを作成するには，ggdensity()関数を使います。 ggplot2パッケージとは違い，aes()は使いません。 引数が多いように思えますが，ほとんどコピペで使い回せるので，基本形だけ覚えておけば大丈夫です。\n密度プロットを作図するためのデータを作成します。 ここでは性別と体重のデータを400名分作成します。\n\nset.seed(1234)\nwdata = data.frame(\n   性別 = factor(rep(c(\"F\", \"M\"), each=200)), # 男女各200名\n   体重 = c(rnorm(200, 55), rnorm(200, 58))\n   ) # 正規分布の乱数\n\nggpubr::ggdensity()で密度プロットを作成します。\n\nggdensity(wdata, # データフレーム\n    x = \"体重\", # 体重の分布\n    add = \"mean\", # 平均値を表示\n    rug = TRUE, # 密度関数の下にデータ分布を表示\n    color = \"性別\", fill = \"性別\",\n    palette = c(\"#00AFBB\", \"#E7B800\")\n    )\n\n\n\n\n\n\n\n次に同じ1変数のグラフであるヒストグラムを作成します。 ヒストグラムは，ggpubr::gghistogram()関数を使います。\n\ngghistogram(wdata,\n    x = \"体重\", # 体重\n    add = \"mean\",  # 平均値を表示\n    rug = TRUE, # x軸にデータの分布\n    color = \"性別\",  # 枠の色を性別ごと\n    fill = \"性別\", # グラフの中の色を性別ごと\n    palette = c(\"#00AFBB\", \"#E7B800\")\n    )\n\nWarning: Using `bins = 30` by default. Pick better value with the argument\n`bins`.\n\n\n\n\n\n\n\n\n次は，横軸にカテゴリー変数，縦軸に連続変数となる2変数のためのグラフをggpubrで作ってみます。 ここでは，ToothGrowthデータという歯の成長に関するデータを使います。 箱ひげ図を作るには，ggpubr::ggboxplot()関数を使います。\n\ndata(\"ToothGrowth\") # 歯の成長データ\ndf &lt;- ToothGrowth\nhead(df, 4) |&gt; knitr::kable(align='ccc') |&gt; kableExtra::kable_styling(font_size = 12)\n\n\n\nlen\nsupp\ndose\n\n\n\n4.2\nVC\n0.5\n\n\n11.5\nVC\n0.5\n\n\n7.3\nVC\n0.5\n\n\n5.8\nVC\n0.5\n\n\n\n\n\n箱ひげ図を作成します。 先ほどとは違い2変数のグラフなので，データフレームを指定した後に，xとyを指定します。\n\np &lt;- ggboxplot(df, # データフレーム\n    x = \"dose\", y = \"len\", # 2変数を指定\n    color = \"dose\", # 色分けはdoseごと\n    palette =c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # 色指定\n    add = \"jitter\", # データを重ならないように\n    shape = \"dose\" # 点の形ををdoseごとに\n    )\nprint(p)\n\n\n\n\n\n\n\n心理学系論文でよく利用されるグループ間の差の検定結果を載せる。\n\nmy_comparisons &lt;- list(c(\"0.5\", \"1\"), c(\"1\", \"2\"), c(\"0.5\", \"2\"))\n # Add pairwise comparisons p-value\np + stat_compare_means(comparisons = my_comparisons) +\n    stat_compare_means(label.y = 50)\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, :\nタイがあるため、正確な p 値を計算することができません\n\n\n\n\n\n\n\n\n箱ひげ図とバイオリン・プロットを組み合わせグラフは，ggviolin()関数で作成できる。\n\nggviolin(\n  df,\n  x = \"dose\",\n  y = \"len\",\n  fill = \"dose\",\n  palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  add = \"boxplot\",\n  add.params = list(fill = \"white\")) +\n  stat_compare_means(comparisons = my_comparisons, label = \"p.signif\") + # 有意水準を追加\n  stat_compare_means(label.y = 50)  # p値を追加\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(4.2, 11.5, 7.3, 5.8, 6.4, 10, 11.2, 11.2, :\nタイがあるため、正確な p 値を計算することができません\n\n\nWarning in wilcox.test.default(c(16.5, 16.5, 15.2, 17.3, 22.5, 17.3, 13.6, :\nタイがあるため、正確な p 値を計算することができません",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggpubrで可視化</span>"
    ]
  },
  {
    "objectID": "chap12_ggpubr.html#棒グラフ",
    "href": "chap12_ggpubr.html#棒グラフ",
    "title": "\n12  ggpubrで可視化\n",
    "section": "\n12.3 棒グラフ",
    "text": "12.3 棒グラフ\n\nグループ化した変数での色分けを変更してみよう， 並び替えはグループごとではなく，グローバルに行われます。 ここでは，mtcarsデータという車のデータを使います。\n\ndata(\"mtcars\") # 車のデータ\ndfm &lt;- mtcars\n# `cyl`を因子型に変換\ndfm$cyl &lt;- as.factor(dfm$cyl)\n# 変数名を追加\ndfm$name &lt;- rownames(dfm)\n# データの確認\nhead(dfm[, c(\"name\", \"wt\", \"mpg\", \"cyl\")]) |&gt;\n  knitr::kable(align='clccc') |&gt;\n  kableExtra::kable_styling(font_size = 10)\n\n\n\n\nname\nwt\nmpg\ncyl\n\n\n\nMazda RX4\nMazda RX4\n2.620\n21.0\n6\n\n\nMazda RX4 Wag\nMazda RX4 Wag\n2.875\n21.0\n6\n\n\nDatsun 710\nDatsun 710\n2.320\n22.8\n4\n\n\nHornet 4 Drive\nHornet 4 Drive\n3.215\n21.4\n6\n\n\nHornet Sportabout\nHornet Sportabout\n3.440\n18.7\n8\n\n\nValiant\nValiant\n3.460\n18.1\n6\n\n\n\n\n\n\n# 作図\nggbarplot(dfm,\n  x = \"name\", y = \"mpg\", # 2変数を指定\n  fill = \"cyl\", # cylごとに色替え\n  color = \"white\",  # 枠の色は白\n  palette = \"jco\", # 論文用色見本\n  sort.val = \"desc\", # 降順で並び替え\n  sort.by.groups = FALSE,  # グループ内で並び替えしない\n  x.text.angle = 90  # x軸のラベルを90度回転\n)\n\n\n\n\n\n\n\nsort.by.groups = TRUEを入れると，グループ内で並び替えが行われます。\n\n\n12.3.1 偏差グラフ\n\n偏差グラフは，定量的な値の偏差を参照値に対して表します。 つまり，基準となる値からの差をグラフにしたものです。  以下のRコードでは，mtcarsデータセットからmpgのzスコアをプロットします。\n\ndfm &lt;- dfm |&gt;\n  mutate(\n    mpg_z = ( mpg - mean(mpg))  / sd(mpg), # 標準化\n    mpg_grp = factor( # 因子化\n      ifelse(mpg_z &lt; 0, \"low\", \"high\"),\n      levels = c(\"low\", \"high\")\n      )\n  )\n# データの確認\nhead(dfm[, c(\"wt\", \"mpg\", \"mpg_z\", \"mpg_grp\", \"cyl\")]) |&gt;\n  knitr::kable(align='ccccc') |&gt;\n  kableExtra::kable_styling(font_size = 10)\n\n\n\n\nwt\nmpg\nmpg_z\nmpg_grp\ncyl\n\n\n\nMazda RX4\n2.620\n21.0\n0.1508848\nhigh\n6\n\n\nMazda RX4 Wag\n2.875\n21.0\n0.1508848\nhigh\n6\n\n\nDatsun 710\n2.320\n22.8\n0.4495434\nhigh\n4\n\n\nHornet 4 Drive\n3.215\n21.4\n0.2172534\nhigh\n6\n\n\nHornet Sportabout\n3.440\n18.7\n-0.2307345\nlow\n8\n\n\nValiant\n3.460\n18.1\n-0.3302874\nlow\n6\n\n\n\n\n\n順序のある棒グラフを作成してみます。 燃費を表すmpgの水準で色を変えます。 rotate = TRUEとすることで，グラフを90度回転させます。\n\nggbarplot(dfm, x = \"name\", y = \"mpg_z\", # 軸の設定\n  fill = \"mpg_grp\", # `mpg_grp`で色分け\n  color = \"white\",  # 枠は白\n  palette = \"jco\",  # jcoパレット\n  sort.val = \"desc\", # 降順で並び替え\n  sort.by.groups = FALSE, # グループ内並び替えしない\n  x.text.angle = 90,  # x軸ラベルを90度回転\n  ylab = \"MPG z-score\", # Y軸ラベル\n  xlab = FALSE, # x軸は非表示\n  legend.title = \"MPG Group\", # グラフタイトル\n  rotate = TRUE,\n  ggtheme = theme_few()\n  )\n\n\n\n\n\n\n\n\n12.3.2 ロリポップチャート\nロリポップチャートは，名前のとおりキャンディーのような形をした棒グラフの一種です。  可視化したいデータセットに大きな値のある場合に，棒グラフの代わりに用いることができます。  ロリポップチャートは，ggdotchart()関数を使って作成します。\n\nggdotchart(dfm, x = \"name\", y = \"mpg\", # 軸の設定\n           color = \"cyl\",  # cylで色分け\n           palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # 色を指定\n           sorting = \"ascending\", # 降順で並び替え\n           add = \"segments\",  # y切片からドットまでセグメント追加\n           ggtheme = theme_pubr() # ggplot2テーマ\n           )\n\n\n\n\n\n\n\n同様に，見た目を変えたグラフとして，クリーブランド・ドットプロット(Cleveland’s dot plot)があります。\n\nggdotchart(dfm, x = \"name\", y = \"mpg\", # 軸の設定\n           color = \"cyl\", # cylで色分け\n           palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), # 色を指定\n           sorting = \"descending\", # 降順で並び替え\n           rotate = TRUE, # 90度回転\n           dot.size = 2, # ドットのサイズ\n           y.text.col = TRUE,  # Color y text by groups\n           ggtheme = theme_pubr() # ggplot2 テーマ\n           ) +\n  theme_cleveland() # クリーブランド\n\nWarning: Vectorized input to `element_text()` is not officially supported.\nℹ Results may be unexpected or may change in future versions of ggplot2.\n\n\n\n\n\n\n\n\n学術的には全く推奨されていないけれど，よく使われるグラフに円グラフがあります。 円グラフは，ggpie()関数で作成できます。\n\ndf &lt;- data.frame(\n  name = c(\"A\", \"B\", \"C\"),\n  value = c(10, 20, 30)\n)\nggpie(df,\n  x = \"value\",\n  label = \"value\",\n  lab.pos = \"in\", # ラベルの位置\n  palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  lab.font = c(12, \"bold\", \"white\"), # ラベルのフォント\n  fill = \"name\",\n  size = 1,\n  main = \"Pie chart of value\"\n)\n\n\n\n\n\n\n\nただ円グラフは結局数字を見ないと正確な情報が分からないため，あまり使わないほうがよいです。大まかにシェアや割合を見たい場合は，積み上げ棒グラフを使うとよいでしょう。\n\ndf &lt;- data.frame(\n  name = c(\"A\", \"B\", \"C\"),\n  value = c(10, 20, 30),\n  group = c(1,1,1)\n)\nggbarplot(df,\n  x = \"group\",\n  y = \"value\",\n  fill = \"name\",\n  palette = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  ggtheme = theme_pubr(),\n  show.legend = FALSE\n  ) + coord_flip()",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>ggpubrで可視化</span>"
    ]
  },
  {
    "objectID": "chap13_gg_function.html#複数のグラフを自動作成",
    "href": "chap13_gg_function.html#複数のグラフを自動作成",
    "title": "\n13  ggplotを関数に埋め込む\n",
    "section": "\n13.1 複数のグラフを自動作成",
    "text": "13.1 複数のグラフを自動作成\n複数の変数に基づいて同じグラフを作成したい、ということがあります。 例えば、財務分析なので、横軸を年度、縦軸を各種財務比率、とした折れ線グラフを作成する、というような場合です。\nこのとき、複数の変数を入れ替えながら、同じグラフを作成するために、何度も同じようなコードを繰り返し書くことは面倒ですし、グラフの設定を少し変えた場合に、すべてのコードを修正しなければならないので、メンテナンス性も悪いです。\nそこで、関数を使って、同じグラフを作成するコードを簡潔に書く方法を紹介します。 必要なパッケージを読み込んでから、作図用のデータを作成しておきます。\n\n# パッケージを読み込む\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(ggthemes)\nlibrary(ggpubr)\nlibrary(patchwork)\nlibrary(rlang)\n\n\n 次のパッケージを付け加えます: 'rlang' \n\n 以下のオブジェクトは 'package:purrr' からマスクされています:\n\n    %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl,\n    flatten_raw, invoke, splice\n\nknitr::opts_chunk$set(dev = \"ragg_png\")\n# データ作成\ndf &lt;- data.frame(\n  year = rep(2011:2020),\n  current_ratio = seq(1,1.1,0.1) + rnorm(10, 0, .1),\n  debt_ratio = seq(0.5,0.6,0.1) + rnorm(10, 0, .1),\n  turn_over = rnorm(10, 1, .5)\n)",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>ggplotを関数に埋め込む</span>"
    ]
  },
  {
    "objectID": "chap13_gg_function.html#関数を作る",
    "href": "chap13_gg_function.html#関数を作る",
    "title": "\n13  ggplotを関数に埋め込む\n",
    "section": "\n13.2 関数を作る。",
    "text": "13.2 関数を作る。\n前に説明したように、自作の関数を作るには、function()を使います。ggplot()関数を使って、グラフを作成する関数を作るので、自作関数の引数は、\n\ndf : データフレーム\nx : x軸の変数\ny : y軸の変数\n\nとします。 読み込むデータフレームはデフォルトでdfとしておきます。 では自作関数mygraph()を作成します。\n\nmygraph &lt;- function(\n  # 引数\n  df, \n  x, \n  y, \n  xname, \n  yname # y軸の名前\n  ) { # 関数\n  ggplot(df) + aes(x = factor({{x}}), y = {{y}}, group = 1) +\n    geom_line() +\n    geom_point() +\n    xlab(xname) +\n    ylab(yname) +\n    theme_economist_white()\n}\n\n完成しました。 この関数の意味は、\n\n関数名と引数を指定\nx軸とy軸を指定\n折れ線グラフ\n散布図\nテーマをtheme_economist()に設定\n\nということです。 ここで、変数xとyを{{}}で囲んでいますが、これは、ggplot2パッケージの新しい機能で、{{}}で囲むことで、変数名を文字列として扱うことができます。 こうしないと、自作関数の引数をggplot()関数のaes()の中に入れることができません。\nでは使ってみましょう。 データフレーム名はdfとデフォルトで指定しているので、xとyのみを指定します。 x軸は年度なのでyear、y軸は流動比率current_ratioを指定してみます。\n\ng1 &lt;- mygraph(df = df, x = year, \ny = current_ratio,xname = \"年度\", yname = \"流動比率\")\nprint(g1)\n\n\n\n\n\n\n\n負債比率だと、\n\ng2 &lt;- mygraph(df = df, x = year, y = debt_ratio,\n  xname = \"年度\", yname = \"負債比率\")\nprint(g2)\n\n\n\n\n\n\n\n売上高回転率だと、\n\ng3 &lt;- mygraph(df = df, x = year, y = turn_over,\n  xname = \"年度\", yname = \"総資産回転率\")\nprint(g3)\n\n\n\n\n\n\n\n図を並べて表示するときは、patchworkパッケージを使います。\n\nlibrary(patchwork)\n\npatchworkを使うと、ggplot2で作成したグラフを格納したオブジェクトを使って、簡単にグラフを縦や横に並べることができる。\n横に並べるときは、\n\ng1 + g2 + g3\n\n\n\n\n\n\n\nと+でつなげ、縦に並べるときは、\n\ng1 / g2 / g3\n\n\n\n\n\n\n\nと/でつなげます。\n組み合わせることも可能です。\n\ng1 / (g2 + g3) # g1が上で、g2とg3が横\n\n\n\n\n\n\n\n関数を使うと、同じようなグラフを簡単に作成することができ、patchworkパッケージを使うと、複数のグラフを並べて表示することができます。 同じようなグラフを作成するときは、関数を使ってみてください。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>ggplotを関数に埋め込む</span>"
    ]
  },
  {
    "objectID": "chap14_ggplot_other.html#宮崎駿カラー",
    "href": "chap14_ggplot_other.html#宮崎駿カラー",
    "title": "\n14  ggplot2のTips\n",
    "section": "\n14.1 宮崎駿カラー",
    "text": "14.1 宮崎駿カラー\nggplot2で作成するグラフの色を宮崎駿監督の映画に出てくるような色にするために開発されたghibliパッケージを使ってみます。\nカラーパレットの名前もジブリらしく、\n\n\nPonyoLight : 『崖の上のポニョ』\n\nTotoroLight : 『となりのトトロ』\n\nKikiLight : 『魔女の宅急便』\n\nLaputaLight : 『天空の城ラピュタ』\n\nなどがあります。 色の濃度として、\n\n\nLight : 明るい\n\nMedium : 中間\n\nDark : 濃い\n\nがそれぞれのカラーパレットにあります。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggplot2のTips</span>"
    ]
  },
  {
    "objectID": "chap14_ggplot_other.html#使用方法",
    "href": "chap14_ggplot_other.html#使用方法",
    "title": "\n14  ggplot2のTips\n",
    "section": "\n14.2 使用方法",
    "text": "14.2 使用方法\nパッケージを読み込みます。\n\n# install.packages('ghibli') # first time only\nlibrary(ghibli)\nlibrary(dplyr)\n\n\n 次のパッケージを付け加えます: 'dplyr' \n\n\n 以下のオブジェクトは 'package:stats' からマスクされています:\n\n    filter, lag\n\n\n 以下のオブジェクトは 'package:base' からマスクされています:\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\nlibrary(patchwork)\n\nカラーパレットを確認します。 3行9列のグラフを作成しています。\n\npar(mfrow=c(9,3))\nfor(i in names(ghibli_palettes)) print(ghibli_palette(i))\n\n\n\n\n\n\n\nグラフを作成してみます。 ラピュタならLaputaLightを使います。\n\ndata(\"mtcars\") # 車のデータ\ndfm &lt;- mtcars\n\nggplot(dfm) + \n  aes(x = wt, y = mpg, color = factor(vs)) + \n  geom_jitter(size = 2) + \n  theme_minimal() +\n  # ghibli stuff\n  scale_colour_ghibli_d(\"LaputaMedium\", direction = -1)\n\n\n\n\n\n\n\nトトロならTotoroLightを使います。\n\ndfm |&gt;\n  group_by(carb) |&gt;\n  summarise(mmpg = mean(mpg)) |&gt;\n  ggplot() + \n  aes(x = factor(carb), y = mmpg, fill = factor(carb)) + \n  geom_col() + theme_minimal() + \n  # ghibli stuff\n  scale_fill_ghibli_d(\"TotoroLight\", direction = -1)\n\n\n\n\n\n\n\n魔女の宅急便なら、KikiLightを使います。\n\ndfm |&gt;\n  group_by(carb, vs) |&gt;\n  summarise(mmpg = mean(mpg)) |&gt;\n  ggplot() + \n  aes(x = factor(carb), y = mmpg, fill = factor(carb)) + \n  geom_col() + \n  theme_minimal() + \n  scale_fill_ghibli_d(\"KikiLight\", direction = -1)\n\n`summarise()` has grouped output by 'carb'. You can override using the\n`.groups` argument.",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ggplot2のTips</span>"
    ]
  },
  {
    "objectID": "chap14_ggplot_ghibli.html#宮崎駿カラー",
    "href": "chap14_ggplot_ghibli.html#宮崎駿カラー",
    "title": "\n15  ggplotとジブリ\n",
    "section": "\n15.1 宮崎駿カラー",
    "text": "15.1 宮崎駿カラー\nこの章では、ggplot2で作成するグラフの色を宮崎駿監督の映画に出てくるような色にするために開発されたghibliパッケージを使って、よさげなグラフを作成してみます。\nghibliパッケージで提供されるカラーパレットの名前もジブリらしく、\n\n\nPonyo : 『崖の上のポニョ』\n\nTotoro : 『となりのトトロ』\n\nKiki : 『魔女の宅急便』\n\nLaputa : 『天空の城ラピュタ』\n\nなどがあり、色の濃度として、\n\n\nLight : 明るい\n\nMedium : 中間\n\nDark : 濃い\n\nが容易されています。 たとえばPonyoLightという名前でカラーパレットを使います。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>ggplotとジブリ</span>"
    ]
  },
  {
    "objectID": "chap14_ggplot_ghibli.html#使用方法",
    "href": "chap14_ggplot_ghibli.html#使用方法",
    "title": "\n15  ggplotとジブリ\n",
    "section": "\n15.2 使用方法",
    "text": "15.2 使用方法\n必要なパッケージを読み込みます。\n\nlibrary(dplyr) # データハンドリング\n\n\n 次のパッケージを付け加えます: 'dplyr' \n\n\n 以下のオブジェクトは 'package:stats' からマスクされています:\n\n    filter, lag\n\n\n 以下のオブジェクトは 'package:base' からマスクされています:\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2) # ggplotグラフ\nlibrary(patchwork) # グラフを並べる\n# install.packages('ghibli') # first time only\nlibrary(ghibli) # ジブリカラー\n# 文字化け対策\nknitr::opts_chunk$set(dev = \"ragg_png\")\n\nカラーパレットを確認するため、以下のコードで3行9列のグラフを作成しています。\n\npar(mfrow=c(9,3)) # 9行3列のグラフ\nfor(i in names(ghibli_palettes)) print(ghibli_palette(i))\n\n\n\n\n\n\n\nではグラフを作成してみましょう。 明るいラピュタならLaputaLightを使います。\n\ndata(\"mtcars\") # 車のデータ\ndfm &lt;- mtcars\n\nggplot(dfm) + \n  aes(x = wt, y = mpg, color = factor(vs)) + \n  geom_jitter(size = 2) + \n  theme_minimal() +\n  # ghibli stuff\n  scale_colour_ghibli_d(\"LaputaMedium\", direction = -1)\n\n\n\n\n\n\n\nトトロならTotoroLightを使います。\n\ndfm |&gt;\n  group_by(carb) |&gt;\n  summarise(mmpg = mean(mpg)) |&gt;\n  ggplot() + \n  aes(x = factor(carb), y = mmpg, fill = factor(carb)) + \n  geom_col() + theme_minimal() + \n  # ghibli stuff\n  scale_fill_ghibli_d(\"TotoroLight\", direction = -1)\n\n\n\n\n\n\n\n魔女の宅急便なら、KikiLightを使います。\n\ng &lt;- dfm |&gt;\n  group_by(carb, vs) |&gt;\n  summarise(mmpg = mean(mpg)) |&gt;\n  ungroup() |&gt;\n  ggplot() + \n  aes(x = factor(carb), y = mmpg, fill = factor(carb)) + \n  geom_col() + \n  theme_minimal() + \n  xlab(\"産業\") + ylab(\"回数\") + \n  scale_fill_ghibli_d(\"KikiLight\", direction = -1)\n\n`summarise()` has grouped output by 'carb'. You can override using the\n`.groups` argument.\n\nprint(g)",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>ggplotとジブリ</span>"
    ]
  },
  {
    "objectID": "chap14_ggplot_ghibli.html#ggroughパッケージ",
    "href": "chap14_ggplot_ghibli.html#ggroughパッケージ",
    "title": "\n15  ggplotとジブリ\n",
    "section": "\n15.3 ggroughパッケージ",
    "text": "15.3 ggroughパッケージ\nggroughパッケージを使うと、手書き風のグラフを作成することができます。 ggplot2のグラフを手書き風に変換することができます。 ただし、ggroughパッケージは、画像ファイルSVGを出力することになります。\n\n# fist-time only\n# devtools::install_github(\"xvrdm/ggrough\")\nlibrary(ggrough) # 手書き風のグラフ\nlibrary(ragg) # SVG to PNG\noptions &lt;- list( # 設定\n  Background = list(roughness = 8),\n  GeomCol = list(\n    fill_style = \"zigzag\", \n    angle_noise = 0.5, \n    fill_weight = 2\n    )\n  )\nget_rough_chart(g, options)\n\n\n\n\n\nこのように、ジブリカラーで手書き風というエモいグラフが作成できます。 当然ですが、使いどころを間違えないようにしましょう。",
    "crumbs": [
      "第3部 データの可視化",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>ggplotとジブリ</span>"
    ]
  },
  {
    "objectID": "chap08_needs.html#はじめに",
    "href": "chap08_needs.html#はじめに",
    "title": "9  日経NEEDSデータの処理",
    "section": "9.1 はじめに",
    "text": "9.1 はじめに\nここまで第1部で学習した知識を使って，実際の分析に利用する日経MMが提供しているデータベース日経NEEDSデータを処理してみましょう。 立命館大学が契約している日経NEEDSデータベースからは、\n\n会計データ\n株価データ\n為替データ\n物価指数等のマクロデータ\nPOSデータ (2024年4月から利用可能)\n\nを入手することができます。 これらのデータベースから、大規模なデータを入手し、経済や経営に関するデータ分析を行うことができます。 ここでは、日経NEEDSを使って、会計データを入手する方法を説明します。\n\n\n立命館大学が契約している日経NEEDSはアクセス数に制限のない『社会科学情報検索システム」というものであり，Financial Questとは別物です。FQとは違い，社会科学情報検索システムはMacからでも利用できる半面，自動化ができないので，ちょっと面倒です。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>日経NEEDSデータの処理</span>"
    ]
  },
  {
    "objectID": "chap08_needs.html#日経needsへのアクセス方法",
    "href": "chap08_needs.html#日経needsへのアクセス方法",
    "title": "9  日経NEEDSデータの処理",
    "section": "9.2 日経NEEDSへのアクセス方法",
    "text": "9.2 日経NEEDSへのアクセス方法\n立命館大学図書館のウェブサイトに行きます。\n立命館大学図書館ウェブサイト\nトップページに行くと、サイトの上部に「データベース」という項目があります。\n\nここをクリックすると、データベースの検索窓が出るので、ここにNEEDSと入力して、検索をクリックします。\n\nすると、検索結果に「日経NEEDS」が出てくるので、それをクリックします。ここで注意しなければならないのは、日経NEEDSを利用することができるのは、\n\n大学ネットワークに接続しているか、\nVPN接続しているか、\n\nのどちらかの状態だけです。\n\n\nVPN(Virtual Private Network)とは、インターネットを利用して、遠隔地にあるネットワークと安全に通信するための仕組みです。立命館大学では、学外から学内のネットワークに接続する際にVPNを利用することで、安全に通信することができます。 くわしくは、VPNの利用についてを参照してください。\n大学のネットワークに接続していない場合は、VPN接続をしてください。 大学ネットワークかVPNに接続した状態で、日経NEEDSをクリックすると、日経NEEDSのトップページが表示されます。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>日経NEEDSデータの処理</span>"
    ]
  },
  {
    "objectID": "chap08_needs.html#日経needsの使い方",
    "href": "chap08_needs.html#日経needsの使い方",
    "title": "9  日経NEEDSデータの処理",
    "section": "9.3 日経NEEDSの使い方",
    "text": "9.3 日経NEEDSの使い方\nこれが日経NEEDS社会科学情報検索システムのトップページです。 右上にオンラインマニュアルや項目定義書もあるので、分からないことがあれば参照してください。\n今回は、会計データを入手するため「一般企業財務」をクリックします。\n\n\n\n日経NEEDSのトップページ\n\n\n\n\nもし株価データが欲しいなら、「株式」、為替データなどマクロデータが欲しいなら「マクロ経済」をクリックします。\n日経NEEDS社会科学情報検索システムの「一般企業財務」のトップページは以下のように、上下2つのパートで構成されています。\n \n上のパートは、企業や財務項目を選択する場所です。 左上のタグに「企業」と「項目」があり、「企業」タグでサンプルとしたい企業を選択し、「項目」タグで入手したい財務項目を選択します。\n\n9.3.1 企業タグ\n企業タグでは、分析対象となる企業を選択します。 左側の項目で、\n\n業種\n上場\n本社所在地\n規模（資本金）\n規模（従業員数）\n規模（売上高）\n\nを指定すると、対象となる企業リストが右側に表示されます。 たとえば、\n\n業種は、製造業\n上場は、東証プライム、東証スタンダード、東証グロース\n\nを指定すると、2024年1月28日現在では、1438件の企業がヒットします。 そして右側に出てきた企業名を選択し、「出力一覧に追加」をクリックします。\n\n\n\n企業タグ\n\n\n企業の抽出が終わったら、つぎは「項目」タグを押して、入手したい財務項目を選択します。\n\n\n9.3.2 項目選択\n下のパートは、選択した企業や財務項目に対して、データ入手期間や、入手するデータの種類を選択する場所です。\n「項目一覧」から入手したい財務項目が記載されている財務諸表や区分を選択します。 たとえば、「貸借対照表（資産）」を選択すると、右側に「貸借対照表（資産）」の区分から入手可能な項目のリストが表示されます。 その中で必要な項目を選択し、「出力一覧に追加」をクリックすると、選択した項目が下の「出力一覧」に表示されます。\nデータを取得する際に、必ず入手しておいた方がよい項目は、\n\nR001 決算月数\nR018 上場場部：コード\nR022 日経業種：コード\n\nの3つです。 変則決算で決算月数が12でない企業-年度(firm-year)はサンプルから除外することが多いため、決算月数は必要です。 あとは上場場を変更した企業も把握したいことが多いため、上場場部コードも必要です。 あとは、年度と産業で固定効果を入れた回帰モデルを構築することが多いため、日経業種コードも必要です。\n\n\n\n項目選択\n\n\n\n\n\n\n\n\n注意点\n\n\n\n全上場企業に対して，非常に多くの財務項目を，非常に長い期間にわたって入手しようとすると，日経NEEDSのサーバーに負荷がかかり，アクセスが遮断されることがあります。 適正な利用を心がけましょう。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>日経NEEDSデータの処理</span>"
    ]
  },
  {
    "objectID": "chap08_needs.html#出力設定",
    "href": "chap08_needs.html#出力設定",
    "title": "9  日経NEEDSデータの処理",
    "section": "9.4 出力設定",
    "text": "9.4 出力設定\n上のパートで企業と項目を選択したら、次の下パートの「出力設定」で、データの入手期間や、データの種類を選択します。 左側の項目で、サンプルの期間や、決算の種類、レイアウトを選択します。\n\n9.4.1 期間（暦年）\nここでは、データの入手期間を指定します。 開始期間と終了期間を指定することができます。 開始期間だけを指定して、終了期間を指定しないと、開始期間から最新の期間までのデータを取得するため、特にこだわりが無ければ、開始期間だけを指定しておきましょう。\n\n\n9.4.2 連単基準\n連単基準では、次の項目が選択できます。\n\n連結（本）：本決算の連結財務諸表を取得\n単独（本）：本決算の個別財務諸表を取得\n単独（本・中間）：本決算と中間決算の個別財務諸表を取得\n単独（本、年度換算）：本決算の個別財務諸表を取得し、年度換算を行う\n連結優先（本）：一決算期に複数の基準のレコードがある場合、以下の優先順位に基づいて1レコードを表示出力\n\n連結（国際会計基準）\n連結（米国会計基準）\n連結（日本基準）\n単独\n\n連単両方（本）：本決算の連結と個別財務諸表を取得\n\nよく使うのは、連結（本）と連結優先（本）です。 IFRS採用企業や米国基準採用企業の項目を取得したい場合は、連結優先（本）を選択しておくと、日本基準とデータが重複しないので、便利です。\n「ダウンロード設定」の項目ではヘッダーに含める変数を選択します。 ここで、項目の「勘定グループ名」のチェックは外しておきましょう。 無駄に変数名が長くなることを防げます。 あとはそのままで大丈夫です。\n\n\n9.4.3 レイアウト\nレイアウトでは、データの並び順を指定します。 特に重要ではないので、そのままで大丈夫です。\n\n\n\n出力設定",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>日経NEEDSデータの処理</span>"
    ]
  },
  {
    "objectID": "chap08_needs.html#企業と項目の保存",
    "href": "chap08_needs.html#企業と項目の保存",
    "title": "9  日経NEEDSデータの処理",
    "section": "9.5 企業と項目の保存",
    "text": "9.5 企業と項目の保存\n日経NEEDS Financial Questとは違い、日経NEEDS社会科学情報検索システムでは、作業を自動化することができないため、上で行ったような選択の結果、抽出されている企業と項目を保存しておくことをおすすめします。\n\n\n\n企業と項目の保存",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>日経NEEDSデータの処理</span>"
    ]
  },
  {
    "objectID": "chap08_needs.html#データの入手",
    "href": "chap08_needs.html#データの入手",
    "title": "9  日経NEEDSデータの処理",
    "section": "9.6 データの入手",
    "text": "9.6 データの入手\n今までの作業で、企業と項目の選択が終わり、データの入手期間や連結単体の選択が終わったら、あとはデータをcsvファイルとしてダウンロードするだけです。\n\n\n\nデータの入手\n\n\n最後に、大事なことなのでもう一度いいます。 ダウンロードしたcsvファイルをMS Excelで開かないようにしよう。",
    "crumbs": [
      "第1部 R言語の基礎",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>日経NEEDSデータの処理</span>"
    ]
  },
  {
    "objectID": "part03.html#第1部の目次",
    "href": "part03.html#第1部の目次",
    "title": "第3部 データの可視化",
    "section": "第1部の目次",
    "text": "第1部の目次\n\n第11章 ggplot2の基礎\n第12章 ggpubrの基礎\n第13章 ggplotを関数\n第14章 ジブリ",
    "crumbs": [
      "第3部 データの可視化"
    ]
  },
  {
    "objectID": "part04.html#第1部の目次",
    "href": "part04.html#第1部の目次",
    "title": "第4部 財務分析",
    "section": "第1部の目次",
    "text": "第1部の目次",
    "crumbs": [
      "第4部 財務分析"
    ]
  },
  {
    "objectID": "chap15_financialAnalysis.html#生産性の分析",
    "href": "chap15_financialAnalysis.html#生産性の分析",
    "title": "\n16  財務分析\n",
    "section": "\n16.1 生産性の分析",
    "text": "16.1 生産性の分析\n\n16.1.1 付加価値とその測定\n付加価値(added value)とは，企業が新たに生み出した価値であり，生産性(productivity)とは付加価値を生み出す能力をいいます。 付加価値は，企業の生産性を測る指標として用いられます。\n\n16.1.2 付加価値の測定\n付加価値の測定方法には大きく，控除法と加算法の2つがあります。\n控除法は，売上高から企業が消費した価値の額を引いたものです。 売上高は把握できますが，消費額は外部からは把握できないため，付加価値の測定が難しいです。\n\n\n\n\n\n\n控除法\n\n\n\n\n付加価値 = 売上高 - 前段階の企業が生産した価値の消費額\n\n\n\nそのため，よく利用されるのが加算法です。 企業がつくり出した付加価値は， 従業員に分配した人件費と，借主に支払った賃借料，国・地方自治体に支払った税金，債権者に支払った負債利子の合計に， 企業の当期純利益を加えたものとして，計算されます。\n\n税金は連結損益計算書の法人税等から法人税調整額を加減したものとして計算します。\n\n\n\n\n\n\n\n加算法\n\n\n\n\n付加価値 = 人件費 + 賃借料 + 税金 + 負債利子 + 当期純利益\n\n\n\nデータの入手可能性から，加算法がよく利用されますが，人件費の特定が困難です。 資格試験では従業員数や給与の情報が与えられるので，そこから計算しますが，ここでは連結損益計算書の販売費及び一般管理費の内訳項目である「人件費・福利厚生費」を人件費として扱います。 dplyrパッケージのmutate()関数で付加価値の変数added_valueを計算します。\n\ndf &lt;- df |&gt;\n  mutate(\n    added_value = salary + rent_fee + (corporate_tax + tax_adjustment) + interest_expense + net_income\n  )\nsummary(df$added_value)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-1966993     3406     8211    32806    23898  2321237 \n\n\n付加価値を計算することできたので，付加価値を使った財務分析を行ってみます。\n\n16.1.3 労働生産性の分析\n労働生産性(labor productivity)とは，一定期間における付加価値を(平均)従業員数で割ったものです。 つまり，従業員一人が1年間に生み出した付加価値の額を示しています。\n\n労働生産性_t = \\frac{付加価値_t}{平均従業員数_t}\n 分子が付加価値というフロー情報であることから，分母の従業員数も期首と期末の平均をとることで対応させています。 では，計算してみましょう。 期首と期末の値を使って平均値を計算するため，group_by()関数とlag()関数を使います。\n\ndf &lt;- df |&gt;\n  group_by(nikkei_code) |&gt; # 企業ごとに\n  mutate(\n    ave_employee = (lag(num_employee) + num_employee) / 2, # 平均従業員数\n    labor_prod = added_value / ave_employee # 労働生産性\n  )\n\n新しく作った変数の記述統計量を確認します。\n\nsummary(df$ave_employee)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n     12     794    1576    5596    4367  285347    2026 \n\n\n最も従業員が少ない会社で12名，最大で約28万名と，従業員数のばらつきが大きいことが分かります。\n\nsummary(df$labor_prod)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n-49.957   2.778   5.257   7.262   9.027 453.811    2026 \n\n\n中央値が5.257で平均値が7.262と中央値の\nヒストグラムも作成してみます。\n\nggplot(df) + aes(labor_prod) + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 2026 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n分布が右に偏っており，大きな値に異常値がありそうです。\n\n16.1.4 労働生産性の分解\n売上高を用いた分解：売上高を挟みこむことで，労働生産性を，一人当たり売上高と付加価値率に分解できる。\n\n労働生産性 = \\frac{付加価値額}{平均従業員数} = \\underbrace{\\frac{売上高}{平均従業員数}}_{1人当たり売上高} \\times \\underbrace{\\frac{付加価値額}{売上高}}_{付加価値率}\n\n有形固定資産を用いた分解：有形固定資産を挟み込むことで，労働生産性を労働装備率と設備生産性に分解できる。\n\n労働生産性 =\\frac{付加価値額}{平均従業員数} = \\underbrace{\\frac{平均有形固定資産}{平均従業員数}}_{労働装備率} \\times \\underbrace{\\frac{付加価値額}{平均有形固定資産}}_{設備生産性}",
    "crumbs": [
      "第4部 財務分析",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>財務分析</span>"
    ]
  },
  {
    "objectID": "chap15_financialAnalysis.html#付加価値の分配",
    "href": "chap15_financialAnalysis.html#付加価値の分配",
    "title": "\n16  財務分析\n",
    "section": "\n16.2 3. 付加価値の分配",
    "text": "16.2 3. 付加価値の分配\n付加価値の分配状況をみる。最も大きい分配先は人件費であり，付加価値に占める人件費の割合を労働分配率という。\n\n一人当たり人件費 = \\frac{人件費}{平均従業員数} = \\underbrace{\\frac{付加価値額}{平均従業員数}}_{労働生産性} \\times \\underbrace{\\frac{人件費}{付加価値額}}_{労働分配率}\n\n一人当たり人件費は，労働生産性と労働分配率に分類できる。\n\n16.2.1 定義を覚える。\n\n付加価値 = 人件費 + 賃借料 + 税金 + 負債利子 + 当期純利益\n労働生産性 = 付加価値額 \\div 平均従業員数\n付加価値率 = 付加価値額 \\div 売上高\n労働装備率 = 平均有形固定資産 \\div 平均従業員数\n設備生産性 = 付加価値額 \\div 平均有形固定資産\n労働分配率 = 人件費 \\div 付加価値額\n\n16.2.2 関係を覚える\n\n労働生産性 = 一人当たり売上高 \\times 付加価値率\n労働生産性 = 労働装備率 \\times 設備生産性\n一人当たり人件費 =労働生産性 \\times 労働分配率",
    "crumbs": [
      "第4部 財務分析",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>財務分析</span>"
    ]
  },
  {
    "objectID": "chap15_financialAnalysis.html#不確実性の分析",
    "href": "chap15_financialAnalysis.html#不確実性の分析",
    "title": "\n16  財務分析\n",
    "section": "\n16.3 不確実性の分析",
    "text": "16.3 不確実性の分析\n\n16.3.1 費用構造が利益変動に及ぼす影響\n損益分岐点(cost-volume-profit)とは，売上と費用が同額となる点をいい，そのときの売上高を損益分岐点売上高という。 損益分岐点を計算するために必要な要素は，\n\n収益\n変動費\n固定費\n\nの3つである。\n横軸を個数，縦軸を金額とするグラフを考える。 売上高Sは，生産個数Xと販売単価Pの積であるため，P \\times Xとなる。 変動費Vは，操業度や生産個数に応じて変化する費用であり，変動費率Rと生産個数Xの積R \\times Xで表す。 ここで，変動費率Rは，変動費Vを販売単価Pで除したものである。 固定費は，操業度にかかわらず一定の費用であり，Fで表す。 変動費と固定費の合計である総費用Cは次のように表すことができる。\n\nC = R \\times X + F\n\n損益分岐点は定義より，S = C つまり，P\\times X =  V \\times X + F の点となる。よって，\n\n\\begin{aligned}\nP\\times X &=  R \\times X + F\\\\\n(P - R) X &= F\\\\\nX &= \\frac{F}{P-R}\\\\\nX &= \\frac{F}{1- \\frac{V}{P}}\n\\end{aligned}\n\nとなり，損益分岐点売上高がF / (1-V) となることが分かる。ここで，1-Vを限界利益という。日本語でかくと，\n\n損益分岐点売上高= \\frac{固定費}{限界利益}\n\nしかし，この計算を行うためには，総費用を変動費と固定費に分ける必要があるが，これは極めて困難である。そこで，簡便的な分類方法がある。\n\n16.3.2 総費用法\nこれは売上高と総費用の2期間比較によって，変動費率を計算する方法である。\n\n変動費率= \\frac{総費用_{t} - 総費用_{t-1}}{売上高_{t} - 売上高_{t-1}}\n\nここで計算された変動費率を売上高にかけることで，変動費を計算する。\n\n変動費=変動費率 \\times 売上高\n\n\n16.3.3 最小二乗法\n回帰分析手法である最小二乗法を用いて変動費率を計算する方法である。これは比較的データが多く取得可能なときに利用可能だが，年次データともなると，過去5年程度のデータが必要となり，長期間になればなるほど，固定費が変動費となってしまうため，四半期データを用いるなど工夫が必要となる。\n総費用を売上高で回帰する。\n\nY = a + bX+\\varepsilon\n\n総費用Y と売上高X のデータを用いて，変動費率と解釈できる回帰パラメータb を推定する。最小二乗法の定義より，回帰係数b は以下のようになる。\n\nb = \\frac{\\mathrm{cov}(Y,X)}{\\mathrm{var}(Y)}=\\frac{(X_i - \\bar X)(Y_i - \\bar Y)}{(Y_i - \\bar Y)^2}\n\nつまり，売上高と総費用の平均を計算し，各データから平均値を差し引く。総費用の平均偏差の二乗を分母に，分子には売上高と総費用の平均偏差のかけ算を行うことで回帰係数が計算できる。たぶん，試験にはでないだろう。\n\n16.3.4 費目別法\n費用項目ごとに，何が固定費で何が変動費かを考えて分類する方法である。問題文で条件が指示されれば可能かもしれないが，現実には無理だとおもうので，試験には出ないような気がする。\n結論，総費用法をしっかり覚えておく。\n\n16.3.5 損益分岐点比率と営業レバレッジ\n実際の売上高と損益分岐点売上高との相対的な規模比較をするための尺度が，損益分岐点比率である。\n\n損益分岐点比率 = \\frac{損益分岐点売上高}{実際の売上高}\n\n実際の売上高と損益分岐点売上高との間の距離のような尺度として安全余裕度がある。\n\n安全余裕度 = 1 - 損益分岐点比率\n\n安全余裕度が高いほど，売上高が減少しても，まだ損益分岐点売上高まで差があることを意味している。損益分岐点を低くするためには，\n\n売上高の増加\n変動費率の引き下げ\n固定費の削減\n\nが必要となる。\n売上高の変化が利益の変化に与える影響の度合いを示す尺度に，営業レバレッジがある。\n\n営業レバレッジ = \\frac{営業利益変化率}{売上高変化率} = \\frac{1}{1-損益分岐点比率} = \\frac{1}{安全余裕度}\n\nとなる。この式の導出は，以下のページを参照すること。\n営業レバレッジ\nここは，時間がかかりそうなので，何度も問題を解いてパターンになれておくこと。",
    "crumbs": [
      "第4部 財務分析",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>財務分析</span>"
    ]
  }
]