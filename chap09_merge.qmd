---
title: "データの結合"
---

```{r include=FALSE}
source("global.R")
```

利用するパッケージを読み込みます。

```{r}
#| warning: false
#| message: false
library(dplyr) # データ操作
library(knitr) # 作表
library(kableExtra) # 作表拡張
```

## データフレームの結合

次に、よく使うのだけれど、結構ややこしいデータフレームの**結合**(merge)について説明します。
データフレームの結合には、基本関数の`cbind()`や`rbind()`を使うこともできますが、`tidyverse`の`dplyr`パッケージのJOIN関数を使うと、より簡単に結合できます。

日本の自動車メーカーの会計情報を使います。
まずは`data.frame()`関数を使って、`name`，`year`，`sale`という3つの変数をもつデータフレームを作成します。

:::{.column-margin}
本によっては、`data.frame()`関数の代わりに`tibble()`関数を使ってデータフレームを作成するようにしているものもあります。
`tibble()`関数は、`data.frame()`関数の代わりに使うことができ、作成されるデータフレームには`tibble`というクラスが付与されます。
`tibble`クラスのデータフレームは、`data.frame`クラスのデータフレームと比べて、便利な特徴が与えられていますが、ここでは基本関数`data.frame()`を使ってデータフレームを作成します。
:::

```{r car_data}
df_car <- data.frame( # データフレームを作成
    name = c(rep("トヨタ",2),rep("日産",2),rep("ホンダ",2)), # 企業名
    year = rep(c("2022", "2023"),3), # 年度
    sale = c(31379507,37154298,8424585,10596695,14552696,16907725)  # 売上高
)
df_car |> kable() |> kable_styling(font_size = 24)
```

## データを縦に結合する

データを縦に結合する，ということは，データフレームの行を追加することです。具体的には観測値を追加することになり，変数の数は変わりません。

:::{.column-margin}
2つのデータフレームを結合して行だけが増える結合を**縦結合**、
列が増える結合を**横結合**と呼びます。
:::

ここでは，作成した`df_car`に、各社2024年の売上高のデータが入ったデータフレーム`df_car_2024`を追加したいとします。
2024年度の業績予想データが入ったデータフレームを作成します。

```{r}
df_car_2024 <- data.frame(
    name = c("トヨタ", "日産", "ホンダ"),
    year = c(rep(2024,3)),
    sale = c(38000000, 12400000, 18200000)
)
df_car_2024 |> kable() |> kable_styling(font_size = 24)
```

![データフレームの縦結合](img/rbind.png){width="60%"}

<!--
このように**追加されるデータフレームが元のデータフレームの変数の数と名前が一致している場合**、簡単にデータを縦に結合することができます。
-->

2つのデータフレームを縦に結合するには、基本関数の`rbind()`を使うか、`dplyr`パッケージの`bind_rows()`関数を使います。

### `rbind()`関数の場合

`rbind()`関数を使う場合は、以下のようにします。

```{r}
df_car_add <- rbind(df_car, df_car_2024)
df_car_add |> kable() |>
    row_spec(7:9, bold = TRUE, background = 'mistyrose')
```

データフレームに下から新たなデータが加わっていることが分かります。
たとえ，変数の順番が異なっていたとしても，変数名が一致していれば，簡単にデータを縦に結合することができます。
`sale`と`year`の変数の順番を入れ替えてみます。

```{r}
df_car_2 <- data.frame(
    name = c("トヨタ", "日産", "ホンダ"),
    sale = c(38000000, 12400000, 18200000),
    year = c(rep(2024,3))
    )
df_car_add2 <- rbind(df_car, df_car_2)
df_car_add2 |> kable() |>
    row_spec(7:9, bold = TRUE, background = 'mistyrose')
```

上手くいきました。
しかし変数の数や名前が一致しないと， `match.names(clabs, names(xi)) でエラー:  名前が以前の名前と一致しません `というエラーがでて結合できません。
したがって`rbind()`関数は変数名と変数の数が一致するデータフレーム同士の縦結合であれば、適切な処理が行われるため、`names()`関数や`dplyr::rename()`関数を使って，変数名が一致するように変更しておきましょう。


### `bind_rows()`関数の場合

`dplyr`パッケージの`bind_rows()`関数は、2つのデータフレームの変数名を参照して縦結合をしてくれます。
`bind_rows()`を使う場合は、以下のようにします。

```{r}
#| eval: false
df_car |> bind_rows(df_car_2024)
```


## データを横に結合する

データを横に結合する，とは，データフレームの列を追加することです。具体的には変数を追加することになり，観測値の数は変わりません。
ただ縦の結合とは異なり，横の結合は少し複雑になります。

データを横に結合する方法の1つは，基本関数の`cbind()`を使うことです。
データフレーム`df_car`に，各社の(親会社株主に帰属する)当期純利益`ni`もデータフレームに追加したいとします。
`ni`を変数とするデータフレームを作成します。
```{r}
df_car_ni <- data.frame(
    name = c(rep("トヨタ",3),rep("日産",3),rep("ホンダ",3)),
    year = rep(c("2022", "2023", "2024"),3), # 時点
    ni = c(2850110, 2451318, 2580000,
           215533, 221900, 315000,
           707067, 651416, 800000)
)
df_car_ni |> kable() |> kable_styling(font_size = 24)
```

これを`df_car_add`に右から結合します。

![cbindによる横結合](img/cbind.png){width="80%"}

```{r}
df_cbind <- cbind(df_car_add, df_car_ni)
df_cbind
```

`df_car`の右側に`df_car_ni`が結合されていることが分かります。
しかし、この結合に問題があることは一目瞭然です。
重複した変数があるうえに、`name`や`year`の順番がバラバラです。
つまり行が観測値を表しておらず、整然データではなくなりました。

この問題を解決するためには、`name`と`year`の2つの変数をキーとして、データを結合する必要があります。
このような結合を**マージ**と呼びます。以下では、マージの方法を説明します。

### JOIN関数を使う

データフレームの結合は基本関数でもできますが、`tidyverse`の`dplyr`パッケージのJOIN関数が便利です。

### JOIN関数

`dplyr`パッケージのJOIN関数には、以下の4つがあります。

- `inner_join()` : 内部結合
- `left_join()` : 左外部結合
- `right_join()` : 右外部結合
- `full_join()` : 完全外部結合

それぞれの結合の結果をベン図で表すと以下のようになります。

![結合](img/join.png){width="80%"}

結合のイメージ図は以下の通りです(この図は、Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemundによる"R for Data Science"の図を引用しています)。

![結合結果](img/R4D_join.png){width="80%"}

内部結合は、2つのデータフレームの共通の変数の値が一致する行のみを抽出するため、結合後のデータフレームが非常に小さくなりがちであるため、ほとんど使用しません。
最も利用する可能性が高いのは、結合元のデータフレームのすべての行を残す**左外部結合**です。
これは`dplyr::left_join()`で実行できます。

#### 左外部結合

![左外部結合](img/left_join_function.png)

`left_join()`の引数は、以下の通りです。

- `x` : 結合元のデータフレーム
- `y` : 結合するデータフレーム
- `by` : 結合する変数

`df_car`と`df_car_ni`を`name`と`year`の2つの変数をキーとして左外部結合します。
ここで重要なことは，**キーとなる変数で観測値がユニークになっている**，ということです。
ここの例だと，`name`がトヨタ，`year`が2023，という観測値(つまり行)は1つだけになっている，ということです。

:::{.callout-important}
JOIN関数で2つのデータフレームを結合するときは，1つ以上のキーとなる変数が，結合元のデータフレームと結合するデータフレームの両方に存在し，またキーの値により行が一意に決まる，つまり観測値がユニークになっていることが重要です。
:::


![左外部結合](img/left_join.png){width="80%"}


`dplyr`パッケージの`left_join()`関数次のようにします。

![左外部結合の書き方](img/left_join_style.png)

```{r}
#| message: false
# nameとyearで左外部結合
df_car_left <- df_car_add |> # 結合先
    left_join(df_car_ni, by = c("name", "year")) # 結合元
# 表にする
df_car_left |> kable() |>
    column_spec(4, bold = TRUE, background = 'mistyrose')
```

この結果をみると、うえで行った`cbind()`関数とは異なり、結合のキーに指定した`name`と`year`の順番が揃っていることが分かります。

![左外部結合の結果](img/left_join_result.png){width="80%"}


ここまでで，変数の数と名前が一致するデータフレーム同士の縦結合と，キーとなる変数で観測値がユニークになっているデータフレーム同士の横結合を説明しました。

次は，観測値が異なるデータフレームの結合や，キーにより観測値がユニークにならないデータフレームの結合について説明します。

## 異なるサイズのデータフレームの結合

`df_car_add`と`df_car_ni`は、同じサイズのデータフレームでしたが、異なるサイズのデータフレームを結合することもできます。
たとえば、元の`df_car`に、マツダの2022年と2023年の売上高を追加してみます。

```{r}
df_car_mazda <- data.frame(
    name = c("マツダ", "マツダ"),
    year = c(2022, 2023),
    sale = c(3120349, 3826752)
)
df_car_mazda <- rbind(df_car,df_car_mazda)
df_car_mazda
```

これに`df_car_ni`を左外部結合するとどうなるか確認してみましょう

![マツダのデータ](img/left_join2.png){width="80%"}

```{r}
df_car_mazda_left <- df_car_mazda |>
    left_join(df_car_ni, by = c("name", "year"))
df_car_mazda_left |> kable() |>
    row_spec(7:8, bold = TRUE, background = 'mistyrose')
```

左外部結合は，結合元のデータフレームのすべての行を残すため，結合後のデータフレームの行数は結合元のデータフレームの行数と同じになります。
したがって，`df_car_mazda`の行数は8行のままで，`ni`という変数が追加されていますが，マツダの2022年と2023年のデータには`NA`が入っています。
結合するデーレフレーム`df_car_ni`に入っていた2024年のデータは、結合先の`df_car_mazda`には存在しないためです。
基本的に主となるデータフレームのデータを維持したいことがおおいため，左外部結合を使うことが多いです。

## 観測値がユニークでない場合

キー変数で行がユニークにならないとき，1対多や多対1，多対多の関係があり，結合後のデータフレームの行数が増えることになります。
どのような挙動になるのかを理解して，データフレームの結合を行いましょう。
理想的には，1対1対応となるように，データを整理してから結合するのが望ましいです。


- 1対多の結合 : 結合するデータフレームがユニークでない
- 多対1の場合 : 結合先のデータフレームがユニークでない
- 多対多の場合 : どちらのデーレフレームもユニークでない

それぞれのケースに対して，`left_join()`関数を適用した結果がどうなるのかを理解しておきましょう。


### 多対1の結合

以下の例だと，結合元のデータフレーム`df_car`には，ホンダの2023年のデータが2つあります。
```{r}
df_car_duplicate <- data.frame( # データフレームを作成
    name = c(rep("トヨタ",2),rep("日産",2),rep("ホンダ",3)),
    year = c(rep(c("2022", "2023"),3), 2023), # 時点
    sale = c(31379507,37154298,8424585,10596695,14552696,16907725,18706224) # 気温
)
df_car_duplicate |> kable() |>
    row_spec(7, bold = TRUE, background = 'mistyrose')
```

このデータフレームには，ホンダの2023年のデータが2つあります。
たとえば，IFRS採用直後だと日本基準とIFRSのデータが記載されていることがあり，このように企業名と年度だけでは観測値がユニークにならないことがあります。

このデータフレームに`df_car_ni`を左外部結合するとどうなるか確認してみましょう

```{r}
df_car_duplicate_left <- df_car_duplicate |>
    left_join(df_car_ni, by = c("name", "year"))
df_car_duplicate_left |> kable() |>
    row_spec(6:7, bold = TRUE, background = 'mistyrose')
```

結合先のデータフレームがキーにでユニークになっていないので，エラーになるかと思いきや，エラーにならずに結合され，ホンダの2023年の2つの観測値に同じ当期純利益の数値が入っています。

多対1の場合は，結合先のデータフレームのキーが重複している行に，結合元のデータを割り当て，重複分だけ結合後のデータフレームの行数が増えてしまいます。

### 1対多の結合

逆のケースもやってみましょう。
結合元のデータフレームはユニークだが，結合するデータフレームがユニークではない場合です。
先ほどの例とは逆に，`df_car_ni`に`df_car_duplicate`を左外部結合するとどうなるか確認してみましょう

```{r}
# 左外部結合
df_car_ni_duplicate_left <- df_car_ni |>
    left_join(df_car_duplicate, by = c("name", "year"))
# 結合後のデータフレーム
df_car_ni_duplicate_left |>
    kable() |>
    row_spec(c(3,6,10), bold = TRUE, background = 'lightcyan') |>
    row_spec(8:9, bold = TRUE, background = 'mistyrose')
```

結合元の`df_car_ni`は2024年のデータがありますが，結合する`df_car_duplicate`には2024年のデータがないため，左外部結合したデータフレームの2024年の`sale`は欠損値`NA`になっています(青色の行)。

また注目すべきは，結合元のホンダの2023年の`ni`は1つだけだったのにたいして，結合後には2つになっており，そこに`sale`が左から結合されています(オレンジの行)。

つまり、結合先のデータフレームがユニークでない場合、結合元のデータが重複して`ni`の値に入っています。


### 多対多の結合

結合先も結合元もユニークでない場合、データフレームを結合しようとすると、Warningがでます。
JOIN関数の引数に`relationship = "many-to-many"`を設定することで、警告をけすことができます。

以下では、シンプルなデータフレームを用いて、多対多の結合の例を示します。

```{r}
df1 <- tibble(x = 1:3) # ユニーク
df2 <- tibble(x = c(1, 1, 2), y = c("first", "second", "third")) # ユニークでない　
df3 <- tibble(x = c(1, 1, 1, 3)) # ユニークでない
```

![練習用データフレーム](img/many_to_many_df.png)

`df1`に`df2`を左外部結合すると

```{r}
df1 |>
    left_join(df2, join_by(x)) |> # x列がキー
    kable(align = "cl",) |> # センタリング
    kable_styling(full_width = FALSE)
```

結合キーとなる`x`に対して、結合先の`df1`の`1`は1つですが、`df2`の1は2つあるため、1対多の結合となり、結合後は`x`の`1`が2行に増え、`df2`の`first`と`second`の値が入っていることが分かります。

図で書くとこうなってます。

![1対多](img/many-to-many_01.png)

次に，`df3`に`df2`を左外部結合すると

```{r}
df3 |> left_join(df2)
```

`warnings`がでます。
このようにレアケースとして多対多関係が予想される場合，`relationship = "many-to-many"`を設定して警告をけしましょう。

```{r}
df3 %>% left_join(df2, by = join_by(x), relationship = "many-to-many")
```

![多対多](img/many-to-many_02.png)


このように，結合するデータフレームのキーとなる変数で観測値がユニークでない場合は，`dplyr::left_join()`関数は，自動的にデータを補完して結合してしまうため，それを理解して使う必要があります。


## JOIN関数のオプション

`left_join()`の引数には，以下のものが用意されています。

- ` by` : 結合する変数を指定する。
- `join_by()` : 複数のキーを指定する。変数名を指定する場合は，`join_by(a == b, c == d)`のようにする。
- `copy` : 特殊なときにしか使わないのでここでは無視
- `suffix` : 同じ変数名があるときに，結合後の変数名に付ける接尾辞を指定する。デフォルトだと`x`がつく。
- `keep` : 結合キーの保持を決める。デフォルトは`null`で，結合先のキー変数のみが残る。`true`だと両データフレームのキー変数が保持される。

- `na_matches` : `NA`と`NaN`などの扱い。デフォルトは同じように処理する。
- `multiple` : 結合先の行が結合元に複数マッチする場合の処理を指定する。
結合先の各行に対して，デフォルトの`all`は、結合元で検出された全てのマッチを返します。これはSQLと同じ動作です。
- `unmatched` : 結合先の行が結合元にマッチしない場合の処理を指定する。デフォルトは`all`で，結合元の行を残す。
- `relationship` : 結合先と結合元のキーの対応関係を指定
  - `NULL` : デフォルトで，
  - `one-to-one` : 結合先と結合元のキーの対応関係が1対1のときに使う。
  - `one-to-many` : 結合元の各行が結合先の最大1行と対応
  - `many-to-one` : 結合先の各行が結合元の最大1行と対応
  - `many-to-many` : 多対多関係が想定されているときに使うらしい。



